{
  "version": 3,
  "sources": ["metric-util.ts"],
  "sourcesContent": ["import { Duration } from '../../../core';\nimport { MathExpression } from '../metric';\nimport { IMetric, MetricConfig, MetricExpressionConfig, MetricStatConfig } from '../metric-types';\n\nconst METRICKEY_SYMBOL = Symbol('@aws-cdk/aws-cloudwatch.MetricKey');\n\n/**\n * Return a unique string representation for this metric.\n *\n * Can be used to determine as a hash key to determine if 2 Metric objects\n * represent the same metric. Excludes rendering properties.\n */\nexport function metricKey(metric: IMetric): string {\n  // Cache on the object itself. This is safe because Metric objects are immutable.\n  if (metric.hasOwnProperty(METRICKEY_SYMBOL)) {\n    return (metric as any)[METRICKEY_SYMBOL];\n  }\n\n  const parts = new Array<string>();\n\n  const conf = metric.toMetricConfig();\n  if (conf.mathExpression) {\n    parts.push(conf.mathExpression.expression);\n    for (const id of Object.keys(conf.mathExpression.usingMetrics).sort()) {\n      parts.push(id);\n      parts.push(metricKey(conf.mathExpression.usingMetrics[id]));\n    }\n    if (conf.mathExpression.searchRegion) {\n      parts.push(conf.mathExpression.searchRegion);\n    }\n    if (conf.mathExpression.searchAccount) {\n      parts.push(conf.mathExpression.searchAccount);\n    }\n  }\n  if (conf.metricStat) {\n    parts.push(conf.metricStat.namespace);\n    parts.push(conf.metricStat.metricName);\n    for (const dim of conf.metricStat.dimensions || []) {\n      parts.push(dim.name);\n      parts.push(dim.value);\n    }\n    if (conf.metricStat.statistic) {\n      parts.push(conf.metricStat.statistic);\n    }\n    if (conf.metricStat.period) {\n      parts.push(`${conf.metricStat.period.toSeconds()}`);\n    }\n    if (conf.metricStat.region) {\n      parts.push(conf.metricStat.region);\n    }\n    if (conf.metricStat.account) {\n      parts.push(conf.metricStat.account);\n    }\n  }\n\n  const ret = parts.join('|');\n  Object.defineProperty(metric, METRICKEY_SYMBOL, { value: ret });\n  return ret;\n}\n\n/**\n * Return the period of a metric\n *\n * For a stat metric, return the immediate period.\n *\n * For an expression metric, all metrics used in it have been made to have the\n * same period, so we return the period of the first inner metric.\n */\nexport function metricPeriod(metric: IMetric): Duration {\n  return dispatchMetric(metric, {\n    withStat(stat) {\n      return stat.period;\n    },\n    withExpression() {\n      return (metric as MathExpression).period || Duration.minutes(5);\n    },\n  });\n}\n\n/**\n * Given a metric object, inspect it and call the correct function for the type of output\n *\n * In addition to the metric object itself, takes a callback object with two\n * methods, to be invoked for the particular type of metric.\n *\n * If the metric represent a metric query (nominally generated through an\n * instantiation of `Metric` but can be generated by any class that implements\n * `IMetric`) a particular field in its `toMetricConfig()` output will be set\n * (to wit, `metricStat`) and the `withStat()` callback will be called with\n * that object.\n *\n * If the metric represents an expression (usually by instantiating `MathExpression`\n * but users can implement `IMetric` arbitrarily) the `mathExpression` field\n * will be set in the object returned from `toMetricConfig` and the callback\n * called `withExpression` will be applied to that object.\n *\n * Will return the values returned by the callbacks.\n *\n * To be used as such:\n *\n * ```ts\n * const ret = dispatchMetric(someMetric, {\n *   withStat(stat) {\n *     // do something with stat\n *     return 1;\n *   },\n *   withExpression(expr) {\n *     // do something with expr\n *     return 2;\n *   },\n * });\n * ```\n *\n * This function encapsulates some type analysis that would otherwise have to be\n * repeated in all places where code needs to make a distinction on the type\n * of metric object that is being passed.\n */\n// eslint-disable-next-line max-len\nexport function dispatchMetric<A, B>(metric: IMetric, fns: { withStat: (x: MetricStatConfig, c: MetricConfig) => A, withExpression: (x: MetricExpressionConfig, c: MetricConfig) => B }): A | B {\n  const conf = metric.toMetricConfig();\n  if (conf.metricStat && conf.mathExpression) {\n    throw new Error('Metric object must not produce both \\'metricStat\\' and \\'mathExpression\\'');\n  } else if (conf.metricStat) {\n    return fns.withStat(conf.metricStat, conf);\n  } else if (conf.mathExpression) {\n    return fns.withExpression(conf.mathExpression, conf);\n  } else {\n    throw new Error('Metric object must have either \\'metricStat\\' or \\'mathExpression\\'');\n  }\n}"],
  "mappings": "yIAAA,KAAA,QAAA,QAAA,iBAIM,iBAAmB,OAAO,qCAQhC,mBAA0B,OAAe,CAEvC,GAAI,OAAO,eAAe,kBACxB,MAAQ,QAAe,kBAGzB,KAAM,OAAQ,GAAI,OAEZ,KAAO,OAAO,iBACpB,GAAI,KAAK,eAAgB,CACvB,MAAM,KAAK,KAAK,eAAe,YAC/B,SAAW,MAAM,QAAO,KAAK,KAAK,eAAe,cAAc,OAC7D,MAAM,KAAK,IACX,MAAM,KAAK,UAAU,KAAK,eAAe,aAAa,MAExD,AAAI,KAAK,eAAe,cACtB,MAAM,KAAK,KAAK,eAAe,cAE7B,KAAK,eAAe,eACtB,MAAM,KAAK,KAAK,eAAe,eAGnC,GAAI,KAAK,WAAY,CACnB,MAAM,KAAK,KAAK,WAAW,WAC3B,MAAM,KAAK,KAAK,WAAW,YAC3B,SAAW,OAAO,MAAK,WAAW,YAAc,GAC9C,MAAM,KAAK,IAAI,MACf,MAAM,KAAK,IAAI,OAEjB,AAAI,KAAK,WAAW,WAClB,MAAM,KAAK,KAAK,WAAW,WAEzB,KAAK,WAAW,QAClB,MAAM,KAAK,GAAG,KAAK,WAAW,OAAO,eAEnC,KAAK,WAAW,QAClB,MAAM,KAAK,KAAK,WAAW,QAEzB,KAAK,WAAW,SAClB,MAAM,KAAK,KAAK,WAAW,SAI/B,KAAM,KAAM,MAAM,KAAK,KACvB,cAAO,eAAe,OAAQ,iBAAkB,CAAE,MAAO,MAClD,IA7CT,QAAA,UAAA,UAwDA,sBAA6B,OAAe,CAC1C,MAAO,gBAAe,OAAQ,CAC5B,SAAS,KAAI,CACX,MAAO,MAAK,QAEd,gBAAc,CACZ,MAAQ,QAA0B,QAAU,OAAA,SAAS,QAAQ,MANnE,QAAA,aAAA,aAkDA,wBAAqC,OAAiB,IAAiI,CACrL,KAAM,MAAO,OAAO,iBACpB,GAAI,KAAK,YAAc,KAAK,eAC1B,KAAM,IAAI,OAAM,yEACX,GAAI,KAAK,WACd,MAAO,KAAI,SAAS,KAAK,WAAY,MAChC,GAAI,KAAK,eACd,MAAO,KAAI,eAAe,KAAK,eAAgB,MAE/C,KAAM,IAAI,OAAM,mEATpB,QAAA,eAAA",
  "names": []
}
