{
  "version": 3,
  "sources": ["env-tokens.ts"],
  "sourcesContent": ["import * as cdk from '../../../core';\n\n/**\n * Make a Token that renders to given region if used in a different stack, otherwise undefined\n */\nexport function regionIfDifferentFromStack(region: string): string {\n  return cdk.Token.asString(new StackDependentToken(region, stack => stack.region));\n}\n\n/**\n * Make a Token that renders to given account if used in a different stack, otherwise undefined\n */\nexport function accountIfDifferentFromStack(account: string): string {\n  return cdk.Token.asString(new StackDependentToken(account, stack => stack.account));\n}\n\n/**\n * A lazy token that requires an instance of Stack to evaluate\n */\nclass StackDependentToken implements cdk.IResolvable {\n  public readonly creationStack: string[];\n  constructor(private readonly originalValue: string, private readonly fn: (stack: cdk.Stack) => string) {\n    this.creationStack = cdk.captureStackTrace();\n  }\n\n  public resolve(context: cdk.IResolveContext) {\n    const stackValue = this.fn(cdk.Stack.of(context.scope));\n\n    // Don't render if the values are definitely the same. If the stack\n    // is unresolved we don't know, better output the value.\n    if (!cdk.Token.isUnresolved(stackValue) && stackValue === this.originalValue) {\n      return undefined;\n    }\n\n    return this.originalValue;\n  }\n\n  public toString() {\n    return cdk.Token.asString(this);\n  }\n\n  public toJSON() {\n    return this.originalValue;\n  }\n}\n"],
  "mappings": "kJAAA,KAAA,KAAA,QAAA,iBAKA,oCAA2C,OAAc,CACvD,MAAO,KAAI,MAAM,SAAS,GAAI,qBAAoB,OAAQ,OAAS,MAAM,SAD3E,QAAA,2BAAA,2BAOA,qCAA4C,QAAe,CACzD,MAAO,KAAI,MAAM,SAAS,GAAI,qBAAoB,QAAS,OAAS,MAAM,UAD5E,QAAA,4BAAA,4BAOA,yBAAyB,CAEvB,YAA6B,cAAwC,GAAgC,CAAxE,KAAA,cAAA,cAAwC,KAAA,GAAA,GACnE,KAAK,cAAgB,IAAI,oBAGpB,QAAQ,QAA4B,CACzC,KAAM,YAAa,KAAK,GAAG,IAAI,MAAM,GAAG,QAAQ,QAIhD,GAAI,GAAC,IAAI,MAAM,aAAa,aAAe,aAAe,KAAK,eAI/D,MAAO,MAAK,cAGP,UAAQ,CACb,MAAO,KAAI,MAAM,SAAS,MAGrB,QAAM,CACX,MAAO,MAAK",
  "names": []
}
