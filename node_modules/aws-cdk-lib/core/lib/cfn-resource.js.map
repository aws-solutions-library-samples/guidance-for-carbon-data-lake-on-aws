{
  "version": 3,
  "sources": ["cfn-resource.ts"],
  "sourcesContent": ["import * as cxapi from '../../cx-api';\nimport { CfnCondition } from './cfn-condition';\n// import required to be here, otherwise causes a cycle when running the generated JavaScript\n/* eslint-disable import/order */\nimport { CfnRefElement } from './cfn-element';\nimport { CfnCreationPolicy, CfnDeletionPolicy, CfnUpdatePolicy } from './cfn-resource-policy';\nimport { Construct, IConstruct, Node } from 'constructs';\nimport { addDependency } from './deps';\nimport { CfnReference } from './private/cfn-reference';\nimport { CLOUDFORMATION_TOKEN_RESOLVER } from './private/cloudformation-lang';\nimport { Reference } from './reference';\nimport { RemovalPolicy, RemovalPolicyOptions } from './removal-policy';\nimport { TagManager } from './tag-manager';\nimport { Tokenization } from './token';\nimport { capitalizePropertyNames, ignoreEmpty, PostResolveToken } from './util';\n\nexport interface CfnResourceProps {\n  /**\n   * CloudFormation resource type (e.g. `AWS::S3::Bucket`).\n   */\n  readonly type: string;\n\n  /**\n   * Resource properties.\n   *\n   * @default - No resource properties.\n   */\n  readonly properties?: { [name: string]: any };\n}\n\n/**\n * Represents a CloudFormation resource.\n */\nexport class CfnResource extends CfnRefElement {\n  /**\n   * Check whether the given construct is a CfnResource\n   */\n  public static isCfnResource(construct: IConstruct): construct is CfnResource {\n    return (construct as any).cfnResourceType !== undefined;\n  }\n\n  // MAINTAINERS NOTE: this class serves as the base class for the generated L1\n  // (\"CFN\") resources (such as `s3.CfnBucket`). These resources will have a\n  // property for each CloudFormation property of the resource. This means that\n  // if at some point in the future a property is introduced with a name similar\n  // to one of the properties here, it will be \"masked\" by the derived class. To\n  // that end, we prefix all properties in this class with `cfnXxx` with the\n  // hope to avoid those conflicts in the future.\n\n  /**\n   * Options for this resource, such as condition, update policy etc.\n   */\n  public readonly cfnOptions: ICfnResourceOptions = {};\n\n  /**\n   * AWS resource type.\n   */\n  public readonly cfnResourceType: string;\n\n  /**\n   * AWS CloudFormation resource properties.\n   *\n   * This object is returned via cfnProperties\n   * @internal\n   */\n  protected readonly _cfnProperties: any;\n\n  /**\n   * An object to be merged on top of the entire resource definition.\n   */\n  private readonly rawOverrides: any = {};\n\n  /**\n   * Logical IDs of dependencies.\n   *\n   * Is filled during prepare().\n   */\n  private readonly dependsOn = new Set<CfnResource>();\n\n  /**\n   * Creates a resource construct.\n   * @param cfnResourceType The CloudFormation type of this resource (e.g. AWS::DynamoDB::Table)\n   */\n  constructor(scope: Construct, id: string, props: CfnResourceProps) {\n    super(scope, id);\n\n    if (!props.type) {\n      throw new Error('The `type` property is required');\n    }\n\n    this.cfnResourceType = props.type;\n    this._cfnProperties = props.properties || {};\n\n    // if aws:cdk:enable-path-metadata is set, embed the current construct's\n    // path in the CloudFormation template, so it will be possible to trace\n    // back to the actual construct path.\n    if (Node.of(this).tryGetContext(cxapi.PATH_METADATA_ENABLE_CONTEXT)) {\n      this.addMetadata(cxapi.PATH_METADATA_KEY, Node.of(this).path);\n    }\n  }\n\n  /**\n   * Sets the deletion policy of the resource based on the removal policy specified.\n   *\n   * The Removal Policy controls what happens to this resource when it stops\n   * being managed by CloudFormation, either because you've removed it from the\n   * CDK application or because you've made a change that requires the resource\n   * to be replaced.\n   *\n   * The resource can be deleted (`RemovalPolicy.DESTROY`), or left in your AWS\n   * account for data recovery and cleanup later (`RemovalPolicy.RETAIN`).\n   */\n  public applyRemovalPolicy(policy: RemovalPolicy | undefined, options: RemovalPolicyOptions = {}) {\n    policy = policy || options.default || RemovalPolicy.RETAIN;\n\n    let deletionPolicy;\n\n    switch (policy) {\n      case RemovalPolicy.DESTROY:\n        deletionPolicy = CfnDeletionPolicy.DELETE;\n        break;\n\n      case RemovalPolicy.RETAIN:\n        deletionPolicy = CfnDeletionPolicy.RETAIN;\n        break;\n\n      case RemovalPolicy.SNAPSHOT:\n        deletionPolicy = CfnDeletionPolicy.SNAPSHOT;\n        break;\n\n      default:\n        throw new Error(`Invalid removal policy: ${policy}`);\n    }\n\n    this.cfnOptions.deletionPolicy = deletionPolicy;\n    if (options.applyToUpdateReplacePolicy !== false) {\n      this.cfnOptions.updateReplacePolicy = deletionPolicy;\n    }\n  }\n\n  /**\n   * Returns a token for an runtime attribute of this resource.\n   * Ideally, use generated attribute accessors (e.g. `resource.arn`), but this can be used for future compatibility\n   * in case there is no generated attribute.\n   * @param attributeName The name of the attribute.\n   */\n  public getAtt(attributeName: string): Reference {\n    return CfnReference.for(this, attributeName);\n  }\n\n  /**\n   * Adds an override to the synthesized CloudFormation resource. To add a\n   * property override, either use `addPropertyOverride` or prefix `path` with\n   * \"Properties.\" (i.e. `Properties.TopicName`).\n   *\n   * If the override is nested, separate each nested level using a dot (.) in the path parameter.\n   * If there is an array as part of the nesting, specify the index in the path.\n   *\n   * To include a literal `.` in the property name, prefix with a `\\`. In most\n   * programming languages you will need to write this as `\"\\\\.\"` because the\n   * `\\` itself will need to be escaped.\n   *\n   * For example,\n   * ```typescript\n   * cfnResource.addOverride('Properties.GlobalSecondaryIndexes.0.Projection.NonKeyAttributes', ['myattribute']);\n   * cfnResource.addOverride('Properties.GlobalSecondaryIndexes.1.ProjectionType', 'INCLUDE');\n   * ```\n   * would add the overrides\n   * ```json\n   * \"Properties\": {\n   *   \"GlobalSecondaryIndexes\": [\n   *     {\n   *       \"Projection\": {\n   *         \"NonKeyAttributes\": [ \"myattribute\" ]\n   *         ...\n   *       }\n   *       ...\n   *     },\n   *     {\n   *       \"ProjectionType\": \"INCLUDE\"\n   *       ...\n   *     },\n   *   ]\n   *   ...\n   * }\n   * ```\n   *\n   * The `value` argument to `addOverride` will not be processed or translated\n   * in any way. Pass raw JSON values in here with the correct capitalization\n   * for CloudFormation. If you pass CDK classes or structs, they will be\n   * rendered with lowercased key names, and CloudFormation will reject the\n   * template.\n   *\n   * @param path - The path of the property, you can use dot notation to\n   *        override values in complex types. Any intermdediate keys\n   *        will be created as needed.\n   * @param value - The value. Could be primitive or complex.\n   */\n  public addOverride(path: string, value: any) {\n    const parts = splitOnPeriods(path);\n    let curr: any = this.rawOverrides;\n\n    while (parts.length > 1) {\n      const key = parts.shift()!;\n\n      // if we can't recurse further or the previous value is not an\n      // object overwrite it with an object.\n      const isObject = curr[key] != null && typeof(curr[key]) === 'object' && !Array.isArray(curr[key]);\n      if (!isObject) {\n        curr[key] = {};\n      }\n\n      curr = curr[key];\n    }\n\n    const lastKey = parts.shift()!;\n    curr[lastKey] = value;\n  }\n\n  /**\n   * Syntactic sugar for `addOverride(path, undefined)`.\n   * @param path The path of the value to delete\n   */\n  public addDeletionOverride(path: string) {\n    this.addOverride(path, undefined);\n  }\n\n  /**\n   * Adds an override to a resource property.\n   *\n   * Syntactic sugar for `addOverride(\"Properties.<...>\", value)`.\n   *\n   * @param propertyPath The path of the property\n   * @param value The value\n   */\n  public addPropertyOverride(propertyPath: string, value: any) {\n    this.addOverride(`Properties.${propertyPath}`, value);\n  }\n\n  /**\n   * Adds an override that deletes the value of a property from the resource definition.\n   * @param propertyPath The path to the property.\n   */\n  public addPropertyDeletionOverride(propertyPath: string) {\n    this.addPropertyOverride(propertyPath, undefined);\n  }\n\n  /**\n   * Indicates that this resource depends on another resource and cannot be\n   * provisioned unless the other resource has been successfully provisioned.\n   *\n   * This can be used for resources across stacks (or nested stack) boundaries\n   * and the dependency will automatically be transferred to the relevant scope.\n   */\n  public addDependsOn(target: CfnResource) {\n    // skip this dependency if the target is not part of the output\n    if (!target.shouldSynthesize()) {\n      return;\n    }\n\n    addDependency(this, target, `\"${Node.of(this).path}\" depends on \"${Node.of(target).path}\"`);\n  }\n\n  /**\n   * Add a value to the CloudFormation Resource Metadata\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n   *\n   * Note that this is a different set of metadata from CDK node metadata; this\n   * metadata ends up in the stack template under the resource, whereas CDK\n   * node metadata ends up in the Cloud Assembly.\n   */\n  public addMetadata(key: string, value: any) {\n    if (!this.cfnOptions.metadata) {\n      this.cfnOptions.metadata = {};\n    }\n\n    this.cfnOptions.metadata[key] = value;\n  }\n\n  /**\n   * Retrieve a value value from the CloudFormation Resource Metadata\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/metadata-section-structure.html\n   *\n   * Note that this is a different set of metadata from CDK node metadata; this\n   * metadata ends up in the stack template under the resource, whereas CDK\n   * node metadata ends up in the Cloud Assembly.\n   */\n  public getMetadata(key: string): any {\n    return this.cfnOptions.metadata?.[key];\n  }\n\n  /**\n   * @returns a string representation of this resource\n   */\n  public toString() {\n    return `${super.toString()} [${this.cfnResourceType}]`;\n  }\n\n  /**\n   * Called by the `addDependency` helper function in order to realize a direct\n   * dependency between two resources that are directly defined in the same\n   * stacks.\n   *\n   * Use `resource.addDependsOn` to define the dependency between two resources,\n   * which also takes stack boundaries into account.\n   *\n   * @internal\n   */\n  public _addResourceDependency(target: CfnResource) {\n    this.dependsOn.add(target);\n  }\n\n  /**\n   * Emits CloudFormation for this resource.\n   * @internal\n   */\n  public _toCloudFormation(): object {\n    if (!this.shouldSynthesize()) {\n      return { };\n    }\n\n    try {\n      const ret = {\n        Resources: {\n          // Post-Resolve operation since otherwise deepMerge is going to mix values into\n          // the Token objects returned by ignoreEmpty.\n          [this.logicalId]: new PostResolveToken({\n            Type: this.cfnResourceType,\n            Properties: ignoreEmpty(this.cfnProperties),\n            DependsOn: ignoreEmpty(renderDependsOn(this.dependsOn)),\n            CreationPolicy: capitalizePropertyNames(this, renderCreationPolicy(this.cfnOptions.creationPolicy)),\n            UpdatePolicy: capitalizePropertyNames(this, this.cfnOptions.updatePolicy),\n            UpdateReplacePolicy: capitalizePropertyNames(this, this.cfnOptions.updateReplacePolicy),\n            DeletionPolicy: capitalizePropertyNames(this, this.cfnOptions.deletionPolicy),\n            Version: this.cfnOptions.version,\n            Description: this.cfnOptions.description,\n            Metadata: ignoreEmpty(this.cfnOptions.metadata),\n            Condition: this.cfnOptions.condition && this.cfnOptions.condition.logicalId,\n          }, resourceDef => {\n            const renderedProps = this.renderProperties(resourceDef.Properties || {});\n            if (renderedProps) {\n              const hasDefined = Object.values(renderedProps).find(v => v !== undefined);\n              resourceDef.Properties = hasDefined !== undefined ? renderedProps : undefined;\n            }\n            const resolvedRawOverrides = Tokenization.resolve(this.rawOverrides, {\n              scope: this,\n              resolver: CLOUDFORMATION_TOKEN_RESOLVER,\n              // we need to preserve the empty elements here,\n              // as that's how removing overrides are represented as\n              removeEmpty: false,\n            });\n            return deepMerge(resourceDef, resolvedRawOverrides);\n          }),\n        },\n      };\n      return ret;\n    } catch (e) {\n      // Change message\n      e.message = `While synthesizing ${this.node.path}: ${e.message}`;\n      // Adjust stack trace (make it look like node built it, too...)\n      const trace = this.creationStack;\n      if (trace) {\n        const creationStack = ['--- resource created at ---', ...trace].join('\\n  at ');\n        const problemTrace = e.stack.substr(e.stack.indexOf(e.message) + e.message.length);\n        e.stack = `${e.message}\\n  ${creationStack}\\n  --- problem discovered at ---${problemTrace}`;\n      }\n\n      // Re-throw\n      throw e;\n    }\n\n    // returns the set of logical ID (tokens) this resource depends on\n    // sorted by construct paths to ensure test determinism\n    function renderDependsOn(dependsOn: Set<CfnResource>) {\n      return Array\n        .from(dependsOn)\n        .sort((x, y) => x.node.path.localeCompare(y.node.path))\n        .map(r => r.logicalId);\n    }\n\n    function renderCreationPolicy(policy: CfnCreationPolicy | undefined): any {\n      if (!policy) { return undefined; }\n      const result: any = { ...policy };\n      if (policy.resourceSignal && policy.resourceSignal.timeout) {\n        result.resourceSignal = policy.resourceSignal;\n      }\n      return result;\n    }\n  }\n\n  protected get cfnProperties(): { [key: string]: any } {\n    const props = this._cfnProperties || {};\n    if (TagManager.isTaggable(this)) {\n      const tagsProp: { [key: string]: any } = {};\n      tagsProp[this.tags.tagPropertyName] = this.tags.renderTags();\n      return deepMerge(props, tagsProp);\n    }\n    return props;\n  }\n\n  protected renderProperties(props: {[key: string]: any}): { [key: string]: any } {\n    return props;\n  }\n\n  /**\n   * Return properties modified after initiation\n   *\n   * Resources that expose mutable properties should override this function to\n   * collect and return the properties object for this resource.\n   */\n  protected get updatedProperites(): { [key: string]: any } {\n    return this._cfnProperties;\n  }\n\n  protected validateProperties(_properties: any) {\n    // Nothing\n  }\n\n  /**\n   * Can be overridden by subclasses to determine if this resource will be rendered\n   * into the cloudformation template.\n   *\n   * @returns `true` if the resource should be included or `false` is the resource\n   * should be omitted.\n   */\n  protected shouldSynthesize() {\n    return true;\n  }\n}\n\nexport enum TagType {\n  STANDARD = 'StandardTag',\n  AUTOSCALING_GROUP = 'AutoScalingGroupTag',\n  MAP = 'StringToStringMap',\n  KEY_VALUE = 'KeyValue',\n  NOT_TAGGABLE = 'NotTaggable',\n}\n\nexport interface ICfnResourceOptions {\n  /**\n   * A condition to associate with this resource. This means that only if the condition evaluates to 'true' when the stack\n   * is deployed, the resource will be included. This is provided to allow CDK projects to produce legacy templates, but noramlly\n   * there is no need to use it in CDK projects.\n   */\n  condition?: CfnCondition;\n\n  /**\n   * Associate the CreationPolicy attribute with a resource to prevent its status from reaching create complete until\n   * AWS CloudFormation receives a specified number of success signals or the timeout period is exceeded. To signal a\n   * resource, you can use the cfn-signal helper script or SignalResource API. AWS CloudFormation publishes valid signals\n   * to the stack events so that you track the number of signals sent.\n   */\n  creationPolicy?: CfnCreationPolicy;\n\n  /**\n   * With the DeletionPolicy attribute you can preserve or (in some cases) backup a resource when its stack is deleted.\n   * You specify a DeletionPolicy attribute for each resource that you want to control. If a resource has no DeletionPolicy\n   * attribute, AWS CloudFormation deletes the resource by default. Note that this capability also applies to update operations\n   * that lead to resources being removed.\n   */\n  deletionPolicy?: CfnDeletionPolicy;\n\n  /**\n   * Use the UpdatePolicy attribute to specify how AWS CloudFormation handles updates to the AWS::AutoScaling::AutoScalingGroup\n   * resource. AWS CloudFormation invokes one of three update policies depending on the type of change you make or whether a\n   * scheduled action is associated with the Auto Scaling group.\n   */\n  updatePolicy?: CfnUpdatePolicy;\n\n  /**\n   * Use the UpdateReplacePolicy attribute to retain or (in some cases) backup the existing physical instance of a resource\n   * when it is replaced during a stack update operation.\n   */\n  updateReplacePolicy?: CfnDeletionPolicy;\n\n  /**\n   * The version of this resource.\n   * Used only for custom CloudFormation resources.\n   *\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cfn-customresource.html\n   */\n  version?: string;\n\n  /**\n   * The description of this resource.\n   * Used for informational purposes only, is not processed in any way\n   * (and stays with the CloudFormation template, is not passed to the underlying resource,\n   * even if it does have a 'description' property).\n   */\n  description?: string;\n\n  /**\n   * Metadata associated with the CloudFormation resource. This is not the same as the construct metadata which can be added\n   * using construct.addMetadata(), but would not appear in the CloudFormation template automatically.\n   */\n  metadata?: { [key: string]: any };\n}\n\n/**\n * Merges `source` into `target`, overriding any existing values.\n * `null`s will cause a value to be deleted.\n */\nfunction deepMerge(target: any, ...sources: any[]) {\n  for (const source of sources) {\n    if (typeof(source) !== 'object' || typeof(target) !== 'object') {\n      throw new Error(`Invalid usage. Both source (${JSON.stringify(source)}) and target (${JSON.stringify(target)}) must be objects`);\n    }\n\n    for (const key of Object.keys(source)) {\n      const value = source[key];\n      if (typeof(value) === 'object' && value != null && !Array.isArray(value)) {\n        // if the value at the target is not an object, override it with an\n        // object so we can continue the recursion\n        if (typeof(target[key]) !== 'object') {\n          target[key] = {};\n        }\n\n        deepMerge(target[key], value);\n\n        // if the result of the merge is an empty object, it's because the\n        // eventual value we assigned is `undefined`, and there are no\n        // sibling concrete values alongside, so we can delete this tree.\n        const output = target[key];\n        if (typeof(output) === 'object' && Object.keys(output).length === 0) {\n          delete target[key];\n        }\n      } else if (value === undefined) {\n        delete target[key];\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Split on periods while processing escape characters \\\n */\nfunction splitOnPeriods(x: string): string[] {\n  // Build this list in reverse because it's more convenient to get the \"current\"\n  // item by doing ret[0] than by ret[ret.length - 1].\n  const ret = [''];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] === '\\\\' && i + 1 < x.length) {\n      ret[0] += x[i + 1];\n      i++;\n    } else if (x[i] === '.') {\n      ret.unshift('');\n    } else {\n      ret[0] += x[i];\n    }\n  }\n\n  ret.reverse();\n  return ret;\n}\n"],
  "mappings": "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",
  "names": []
}
