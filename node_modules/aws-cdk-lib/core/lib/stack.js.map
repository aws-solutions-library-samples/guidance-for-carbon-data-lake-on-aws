{
  "version": 3,
  "sources": ["stack.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport * as cxschema from '../../cloud-assembly-schema';\nimport * as cxapi from '../../cx-api';\nimport { IConstruct, Construct, Node } from 'constructs';\nimport { Annotations } from './annotations';\nimport { App } from './app';\nimport { Arn, ArnComponents, ArnFormat } from './arn';\nimport { DockerImageAssetLocation, DockerImageAssetSource, FileAssetLocation, FileAssetSource } from './assets';\nimport { CfnElement } from './cfn-element';\nimport { Fn } from './cfn-fn';\nimport { Aws, ScopedAws } from './cfn-pseudo';\nimport { CfnResource, TagType } from './cfn-resource';\nimport { ContextProvider } from './context-provider';\nimport { Environment } from './environment';\nimport { FeatureFlags } from './feature-flags';\nimport { CLOUDFORMATION_TOKEN_RESOLVER, CloudFormationLang } from './private/cloudformation-lang';\nimport { LogicalIDs } from './private/logical-id';\nimport { resolve } from './private/resolve';\nimport { makeUniqueId } from './private/uniqueid';\n\nconst STACK_SYMBOL = Symbol.for('@aws-cdk/core.Stack');\nconst MY_STACK_CACHE = Symbol.for('@aws-cdk/core.Stack.myStack');\n\nexport const STACK_RESOURCE_LIMIT_CONTEXT = '@aws-cdk/core:stackResourceLimit';\n\nconst VALID_STACK_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-]*$/;\n\nconst MAX_RESOURCES = 500;\n\nexport interface StackProps {\n  /**\n   * A description of the stack.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n\n  /**\n   * The AWS environment (account/region) where this stack will be deployed.\n   *\n   * Set the `region`/`account` fields of `env` to either a concrete value to\n   * select the indicated environment (recommended for production stacks), or to\n   * the values of environment variables\n   * `CDK_DEFAULT_REGION`/`CDK_DEFAULT_ACCOUNT` to let the target environment\n   * depend on the AWS credentials/configuration that the CDK CLI is executed\n   * under (recommended for development stacks).\n   *\n   * If the `Stack` is instantiated inside a `Stage`, any undefined\n   * `region`/`account` fields from `env` will default to the same field on the\n   * encompassing `Stage`, if configured there.\n   *\n   * If either `region` or `account` are not set nor inherited from `Stage`, the\n   * Stack will be considered \"*environment-agnostic*\"\". Environment-agnostic\n   * stacks can be deployed to any environment but may not be able to take\n   * advantage of all features of the CDK. For example, they will not be able to\n   * use environmental context lookups such as `ec2.Vpc.fromLookup` and will not\n   * automatically translate Service Principals to the right format based on the\n   * environment's AWS partition, and other such enhancements.\n   *\n   * @example\n   *\n   * // Use a concrete account and region to deploy this stack to:\n   * // `.account` and `.region` will simply return these values.\n   * new Stack(app, 'Stack1', {\n   *   env: {\n   *     account: '123456789012',\n   *     region: 'us-east-1'\n   *   },\n   * });\n   *\n   * // Use the CLI's current credentials to determine the target environment:\n   * // `.account` and `.region` will reflect the account+region the CLI\n   * // is configured to use (based on the user CLI credentials)\n   * new Stack(app, 'Stack2', {\n   *   env: {\n   *     account: process.env.CDK_DEFAULT_ACCOUNT,\n   *     region: process.env.CDK_DEFAULT_REGION\n   *   },\n   * });\n   *\n   * // Define multiple stacks stage associated with an environment\n   * const myStage = new Stage(app, 'MyStage', {\n   *   env: {\n   *     account: '123456789012',\n   *     region: 'us-east-1'\n   *   }\n   * });\n   *\n   * // both of these stacks will use the stage's account/region:\n   * // `.account` and `.region` will resolve to the concrete values as above\n   * new MyStack(myStage, 'Stack1');\n   * new YourStack(myStage, 'Stack2');\n   *\n   * // Define an environment-agnostic stack:\n   * // `.account` and `.region` will resolve to `{ \"Ref\": \"AWS::AccountId\" }` and `{ \"Ref\": \"AWS::Region\" }` respectively.\n   * // which will only resolve to actual values by CloudFormation during deployment.\n   * new MyStack(app, 'Stack1');\n   *\n   * @default - The environment of the containing `Stage` if available,\n   * otherwise create the stack will be environment-agnostic.\n   */\n  readonly env?: Environment;\n\n  /**\n   * Name to deploy the stack with\n   *\n   * @default - Derived from construct path.\n   */\n  readonly stackName?: string;\n\n  /**\n   * Stack tags that will be applied to all the taggable resources and the stack itself.\n   *\n   * @default {}\n   */\n  readonly tags?: { [key: string]: string };\n\n  /**\n   * Synthesis method to use while deploying this stack\n   *\n   * @default - `DefaultStackSynthesizer` if the `@aws-cdk/core:newStyleStackSynthesis` feature flag\n   * is set, `LegacyStackSynthesizer` otherwise.\n   */\n  readonly synthesizer?: IStackSynthesizer;\n\n  /**\n   * Whether to enable termination protection for this stack.\n   *\n   * @default false\n   */\n  readonly terminationProtection?: boolean;\n\n  /**\n   * Include runtime versioning information in this Stack\n   *\n   * @default `analyticsReporting` setting of containing `App`, or value of\n   * 'aws:cdk:version-reporting' context key\n   */\n  readonly analyticsReporting?: boolean;\n}\n\n/**\n * A root construct which represents a single CloudFormation stack.\n */\nexport class Stack extends Construct implements ITaggable {\n  /**\n   * Return whether the given object is a Stack.\n   *\n   * We do attribute detection since we can't reliably use 'instanceof'.\n   */\n  public static isStack(x: any): x is Stack {\n    return x !== null && typeof(x) === 'object' && STACK_SYMBOL in x;\n  }\n\n  /**\n   * Looks up the first stack scope in which `construct` is defined. Fails if there is no stack up the tree.\n   * @param construct The construct to start the search from.\n   */\n  public static of(construct: IConstruct): Stack {\n    // we want this to be as cheap as possible. cache this result by mutating\n    // the object. anecdotally, at the time of this writing, @aws-cdk/core unit\n    // tests hit this cache 1,112 times, @aws-cdk/aws-cloudformation unit tests\n    // hit this 2,435 times).\n    const cache = (construct as any)[MY_STACK_CACHE] as Stack | undefined;\n    if (cache) {\n      return cache;\n    } else {\n      const value = _lookup(construct);\n      Object.defineProperty(construct, MY_STACK_CACHE, {\n        enumerable: false,\n        writable: false,\n        configurable: false,\n        value,\n      });\n      return value;\n    }\n\n    function _lookup(c: IConstruct): Stack {\n      if (Stack.isStack(c)) {\n        return c;\n      }\n\n      const _scope = Node.of(c).scope;\n      if (Stage.isStage(c) || !_scope) {\n        throw new Error(`${construct.constructor?.name ?? 'Construct'} at '${Node.of(construct).path}' should be created in the scope of a Stack, but no Stack found`);\n      }\n\n      return _lookup(_scope);\n    }\n  }\n\n  /**\n   * Tags to be applied to the stack.\n   */\n  public readonly tags: TagManager;\n\n  /**\n   * Options for CloudFormation template (like version, transform, description).\n   */\n  public readonly templateOptions: ITemplateOptions;\n\n  /**\n   * The AWS region into which this stack will be deployed (e.g. `us-west-2`).\n   *\n   * This value is resolved according to the following rules:\n   *\n   * 1. The value provided to `env.region` when the stack is defined. This can\n   *    either be a concerete region (e.g. `us-west-2`) or the `Aws.region`\n   *    token.\n   * 3. `Aws.region`, which is represents the CloudFormation intrinsic reference\n   *    `{ \"Ref\": \"AWS::Region\" }` encoded as a string token.\n   *\n   * Preferably, you should use the return value as an opaque string and not\n   * attempt to parse it to implement your logic. If you do, you must first\n   * check that it is a concerete value an not an unresolved token. If this\n   * value is an unresolved token (`Token.isUnresolved(stack.region)` returns\n   * `true`), this implies that the user wishes that this stack will synthesize\n   * into a **region-agnostic template**. In this case, your code should either\n   * fail (throw an error, emit a synth error using `Annotations.of(construct).addError()`) or\n   * implement some other region-agnostic behavior.\n   */\n  public readonly region: string;\n\n  /**\n   * The AWS account into which this stack will be deployed.\n   *\n   * This value is resolved according to the following rules:\n   *\n   * 1. The value provided to `env.account` when the stack is defined. This can\n   *    either be a concerete account (e.g. `585695031111`) or the\n   *    `Aws.accountId` token.\n   * 3. `Aws.accountId`, which represents the CloudFormation intrinsic reference\n   *    `{ \"Ref\": \"AWS::AccountId\" }` encoded as a string token.\n   *\n   * Preferably, you should use the return value as an opaque string and not\n   * attempt to parse it to implement your logic. If you do, you must first\n   * check that it is a concerete value an not an unresolved token. If this\n   * value is an unresolved token (`Token.isUnresolved(stack.account)` returns\n   * `true`), this implies that the user wishes that this stack will synthesize\n   * into a **account-agnostic template**. In this case, your code should either\n   * fail (throw an error, emit a synth error using `Annotations.of(construct).addError()`) or\n   * implement some other region-agnostic behavior.\n   */\n  public readonly account: string;\n\n  /**\n   * The environment coordinates in which this stack is deployed. In the form\n   * `aws://account/region`. Use `stack.account` and `stack.region` to obtain\n   * the specific values, no need to parse.\n   *\n   * You can use this value to determine if two stacks are targeting the same\n   * environment.\n   *\n   * If either `stack.account` or `stack.region` are not concrete values (e.g.\n   * `Aws.account` or `Aws.region`) the special strings `unknown-account` and/or\n   * `unknown-region` will be used respectively to indicate this stack is\n   * region/account-agnostic.\n   */\n  public readonly environment: string;\n\n  /**\n   * Whether termination protection is enabled for this stack.\n   */\n  public readonly terminationProtection?: boolean;\n\n  /**\n   * If this is a nested stack, this represents its `AWS::CloudFormation::Stack`\n   * resource. `undefined` for top-level (non-nested) stacks.\n   *\n   */\n  public readonly nestedStackResource?: CfnResource;\n\n  /**\n   * The name of the CloudFormation template file emitted to the output\n   * directory during synthesis.\n   *\n   * Example value: `MyStack.template.json`\n   */\n  public readonly templateFile: string;\n\n  /**\n   * The ID of the cloud assembly artifact for this stack.\n   */\n  public readonly artifactId: string;\n\n  /**\n   * Synthesis method for this stack\n   *\n   */\n  public readonly synthesizer: IStackSynthesizer;\n\n  /**\n   * Whether version reporting is enabled for this stack\n   *\n   * Controls whether the CDK Metadata resource is injected\n   *\n   * @internal\n   */\n  public readonly _versionReportingEnabled: boolean;\n\n  /**\n   * Logical ID generation strategy\n   */\n  private readonly _logicalIds: LogicalIDs;\n\n  /**\n   * Other stacks this stack depends on\n   */\n  private readonly _stackDependencies: { [uniqueId: string]: StackDependency };\n\n  /**\n   * Lists all missing contextual information.\n   * This is returned when the stack is synthesized under the 'missing' attribute\n   * and allows tooling to obtain the context and re-synthesize.\n   */\n  private readonly _missingContext: cxschema.MissingContext[];\n\n  private readonly _stackName: string;\n\n  /**\n   * Creates a new stack.\n   *\n   * @param scope Parent of this stack, usually an `App` or a `Stage`, but could be any construct.\n   * @param id The construct ID of this stack. If `stackName` is not explicitly\n   * defined, this id (and any parent IDs) will be used to determine the\n   * physical ID of the stack.\n   * @param props Stack properties.\n   */\n  public constructor(scope?: Construct, id?: string, props: StackProps = {}) {\n    // For unit test scope and id are optional for stacks, but we still want an App\n    // as the parent because apps implement much of the synthesis logic.\n    scope = scope ?? new App({\n      autoSynth: false,\n      outdir: FileSystem.mkdtemp('cdk-test-app-'),\n    });\n\n    // \"Default\" is a \"hidden id\" from a `node.uniqueId` perspective\n    id = id ?? 'Default';\n\n    super(scope, id);\n\n    this._missingContext = new Array<cxschema.MissingContext>();\n    this._stackDependencies = { };\n    this.templateOptions = { };\n\n    Object.defineProperty(this, STACK_SYMBOL, { value: true });\n\n    this._logicalIds = new LogicalIDs();\n\n    const { account, region, environment } = this.parseEnvironment(props.env);\n\n    this.account = account;\n    this.region = region;\n    this.environment = environment;\n    this.terminationProtection = props.terminationProtection;\n\n    if (props.description !== undefined) {\n      // Max length 1024 bytes\n      // Typically 2 bytes per character, may be more for more exotic characters\n      if (props.description.length > 512) {\n        throw new Error(`Stack description must be <= 1024 bytes. Received description: '${props.description}'`);\n      }\n      this.templateOptions.description = props.description;\n    }\n\n    this._stackName = props.stackName ?? this.generateStackName();\n    this.tags = new TagManager(TagType.KEY_VALUE, 'aws:cdk:stack', props.tags);\n\n    if (!VALID_STACK_NAME_REGEX.test(this.stackName)) {\n      throw new Error(`Stack name must match the regular expression: ${VALID_STACK_NAME_REGEX.toString()}, got '${this.stackName}'`);\n    }\n\n    // the preferred behavior is to generate a unique id for this stack and use\n    // it as the artifact ID in the assembly. this allows multiple stacks to use\n    // the same name. however, this behavior is breaking for 1.x so it's only\n    // applied under a feature flag which is applied automatically for new\n    // projects created using `cdk init`.\n    //\n    // Also use the new behavior if we are using the new CI/CD-ready synthesizer; that way\n    // people only have to flip one flag.\n    const featureFlags = FeatureFlags.of(this);\n    const stackNameDupeContext = featureFlags.isEnabled(cxapi.ENABLE_STACK_NAME_DUPLICATES_CONTEXT);\n    const newStyleSynthesisContext = featureFlags.isEnabled(cxapi.NEW_STYLE_STACK_SYNTHESIS_CONTEXT);\n    this.artifactId = (stackNameDupeContext || newStyleSynthesisContext)\n      ? this.generateStackArtifactId()\n      : this.stackName;\n\n    this.templateFile = `${this.artifactId}.template.json`;\n\n    // Not for nested stacks\n    this._versionReportingEnabled = (props.analyticsReporting ?? this.node.tryGetContext(cxapi.ANALYTICS_REPORTING_ENABLED_CONTEXT))\n      && !this.nestedStackParent;\n\n    this.synthesizer = props.synthesizer ?? (newStyleSynthesisContext\n      ? new DefaultStackSynthesizer()\n      : new LegacyStackSynthesizer());\n    this.synthesizer.bind(this);\n  }\n\n  /**\n   * Resolve a tokenized value in the context of the current stack.\n   */\n  public resolve(obj: any): any {\n    return resolve(obj, {\n      scope: this,\n      prefix: [],\n      resolver: CLOUDFORMATION_TOKEN_RESOLVER,\n      preparing: false,\n    });\n  }\n\n  /**\n   * Convert an object, potentially containing tokens, to a JSON string\n   */\n  public toJsonString(obj: any, space?: number): string {\n    return CloudFormationLang.toJSON(obj, space).toString();\n  }\n\n  /**\n   * DEPRECATED\n   * @deprecated use `reportMissingContextKey()`\n   */\n  public reportMissingContext(report: cxapi.MissingContext) {\n    if (!Object.values(cxschema.ContextProvider).includes(report.provider as cxschema.ContextProvider)) {\n      throw new Error(`Unknown context provider requested in: ${JSON.stringify(report)}`);\n    }\n    this.reportMissingContextKey(report as cxschema.MissingContext);\n  }\n\n  /**\n   * Indicate that a context key was expected\n   *\n   * Contains instructions which will be emitted into the cloud assembly on how\n   * the key should be supplied.\n   *\n   * @param report The set of parameters needed to obtain the context\n   */\n  public reportMissingContextKey(report: cxschema.MissingContext) {\n    this._missingContext.push(report);\n  }\n\n  /**\n   * Rename a generated logical identities\n   *\n   * To modify the naming scheme strategy, extend the `Stack` class and\n   * override the `allocateLogicalId` method.\n   */\n  public renameLogicalId(oldId: string, newId: string) {\n    this._logicalIds.addRename(oldId, newId);\n  }\n\n  /**\n   * Allocates a stack-unique CloudFormation-compatible logical identity for a\n   * specific resource.\n   *\n   * This method is called when a `CfnElement` is created and used to render the\n   * initial logical identity of resources. Logical ID renames are applied at\n   * this stage.\n   *\n   * This method uses the protected method `allocateLogicalId` to render the\n   * logical ID for an element. To modify the naming scheme, extend the `Stack`\n   * class and override this method.\n   *\n   * @param element The CloudFormation element for which a logical identity is\n   * needed.\n   */\n  public getLogicalId(element: CfnElement): string {\n    const logicalId = this.allocateLogicalId(element);\n    return this._logicalIds.applyRename(logicalId);\n  }\n\n  /**\n   * Add a dependency between this stack and another stack.\n   *\n   * This can be used to define dependencies between any two stacks within an\n   * app, and also supports nested stacks.\n   */\n  public addDependency(target: Stack, reason?: string) {\n    addDependency(this, target, reason);\n  }\n\n  /**\n   * Return the stacks this stack depends on\n   */\n  public get dependencies(): Stack[] {\n    return Object.values(this._stackDependencies).map(x => x.stack);\n  }\n\n  /**\n   * The concrete CloudFormation physical stack name.\n   *\n   * This is either the name defined explicitly in the `stackName` prop or\n   * allocated based on the stack's location in the construct tree. Stacks that\n   * are directly defined under the app use their construct `id` as their stack\n   * name. Stacks that are defined deeper within the tree will use a hashed naming\n   * scheme based on the construct path to ensure uniqueness.\n   *\n   * If you wish to obtain the deploy-time AWS::StackName intrinsic,\n   * you can use `Aws.stackName` directly.\n   */\n  public get stackName(): string {\n    return this._stackName;\n  }\n\n  /**\n   * The partition in which this stack is defined\n   */\n  public get partition(): string {\n    // Always return a non-scoped partition intrinsic. These will usually\n    // be used to construct an ARN, but there are no cross-partition\n    // calls anyway.\n    return Aws.PARTITION;\n  }\n\n  /**\n   * The Amazon domain suffix for the region in which this stack is defined\n   */\n  public get urlSuffix(): string {\n    // Since URL Suffix always follows partition, it is unscoped like partition is.\n    return Aws.URL_SUFFIX;\n  }\n\n  /**\n   * The ID of the stack\n   *\n   * @example\n   * // After resolving, looks like\n   * 'arn:aws:cloudformation:us-west-2:123456789012:stack/teststack/51af3dc0-da77-11e4-872e-1234567db123'\n   */\n  public get stackId(): string {\n    return new ScopedAws(this).stackId;\n  }\n\n  /**\n   * Returns the list of notification Amazon Resource Names (ARNs) for the current stack.\n   */\n  public get notificationArns(): string[] {\n    return new ScopedAws(this).notificationArns;\n  }\n\n  /**\n   * Indicates if this is a nested stack, in which case `parentStack` will include a reference to it's parent.\n   */\n  public get nested(): boolean {\n    return this.nestedStackResource !== undefined;\n  }\n\n  /**\n   * Creates an ARN from components.\n   *\n   * If `partition`, `region` or `account` are not specified, the stack's\n   * partition, region and account will be used.\n   *\n   * If any component is the empty string, an empty string will be inserted\n   * into the generated ARN at the location that component corresponds to.\n   *\n   * The ARN will be formatted as follows:\n   *\n   *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}}{resource-name}\n   *\n   * The required ARN pieces that are omitted will be taken from the stack that\n   * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope\n   * can be 'undefined'.\n   */\n  public formatArn(components: ArnComponents): string {\n    return Arn.format(components, this);\n  }\n\n  /**\n   * Given an ARN, parses it and returns components.\n   *\n   * IF THE ARN IS A CONCRETE STRING...\n   *\n   * ...it will be parsed and validated. The separator (`sep`) will be set to '/'\n   * if the 6th component includes a '/', in which case, `resource` will be set\n   * to the value before the '/' and `resourceName` will be the rest. In case\n   * there is no '/', `resource` will be set to the 6th components and\n   * `resourceName` will be set to the rest of the string.\n   *\n   * IF THE ARN IS A TOKEN...\n   *\n   * ...it cannot be validated, since we don't have the actual value yet at the\n   * time of this function call. You will have to supply `sepIfToken` and\n   * whether or not ARNs of the expected format usually have resource names\n   * in order to parse it properly. The resulting `ArnComponents` object will\n   * contain tokens for the subexpressions of the ARN, not string literals.\n   *\n   * If the resource name could possibly contain the separator char, the actual\n   * resource name cannot be properly parsed. This only occurs if the separator\n   * char is '/', and happens for example for S3 object ARNs, IAM Role ARNs,\n   * IAM OIDC Provider ARNs, etc. To properly extract the resource name from a\n   * Tokenized ARN, you must know the resource type and call\n   * `Arn.extractResourceName`.\n   *\n   * @param arn The ARN string to parse\n   * @param sepIfToken The separator used to separate resource from resourceName\n   * @param hasName Whether there is a name component in the ARN at all. For\n   * example, SNS Topics ARNs have the 'resource' component contain the topic\n   * name, and no 'resourceName' component.\n   *\n   * @returns an ArnComponents object which allows access to the various\n   * components of the ARN.\n   *\n   * @returns an ArnComponents object which allows access to the various\n   *      components of the ARN.\n   *\n   * @deprecated use splitArn instead\n   */\n  public parseArn(arn: string, sepIfToken: string = '/', hasName: boolean = true): ArnComponents {\n    return Arn.parse(arn, sepIfToken, hasName);\n  }\n\n  /**\n   * Splits the provided ARN into its components.\n   * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',\n   * and a Token representing a dynamic CloudFormation expression\n   * (in which case the returned components will also be dynamic CloudFormation expressions,\n   * encoded as Tokens).\n   *\n   * @param arn the ARN to split into its components\n   * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses\n   */\n  public splitArn(arn: string, arnFormat: ArnFormat): ArnComponents {\n    return Arn.split(arn, arnFormat);\n  }\n\n  /**\n   * Returns the list of AZs that are available in the AWS environment\n   * (account/region) associated with this stack.\n   *\n   * If the stack is environment-agnostic (either account and/or region are\n   * tokens), this property will return an array with 2 tokens that will resolve\n   * at deploy-time to the first two availability zones returned from CloudFormation's\n   * `Fn::GetAZs` intrinsic function.\n   *\n   * If they are not available in the context, returns a set of dummy values and\n   * reports them as missing, and let the CLI resolve them by calling EC2\n   * `DescribeAvailabilityZones` on the target environment.\n   *\n   * To specify a different strategy for selecting availability zones override this method.\n   */\n  public get availabilityZones(): string[] {\n    // if account/region are tokens, we can't obtain AZs through the context\n    // provider, so we fallback to use Fn::GetAZs. the current lowest common\n    // denominator is 2 AZs across all AWS regions.\n    const agnostic = Token.isUnresolved(this.account) || Token.isUnresolved(this.region);\n    if (agnostic) {\n      return this.node.tryGetContext(cxapi.AVAILABILITY_ZONE_FALLBACK_CONTEXT_KEY) || [\n        Fn.select(0, Fn.getAzs()),\n        Fn.select(1, Fn.getAzs()),\n      ];\n    }\n\n    const value = ContextProvider.getValue(this, {\n      provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER,\n      dummyValue: ['dummy1a', 'dummy1b', 'dummy1c'],\n    }).value;\n\n    if (!Array.isArray(value)) {\n      throw new Error(`Provider ${cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER} expects a list`);\n    }\n\n    return value;\n  }\n\n  /**\n   * Register a file asset on this Stack\n   *\n   * @deprecated Use `stack.synthesizer.addFileAsset()` if you are calling,\n   * and a different IStackSynthesizer class if you are implementing.\n   */\n  public addFileAsset(asset: FileAssetSource): FileAssetLocation {\n    return this.synthesizer.addFileAsset(asset);\n  }\n\n  /**\n   * Register a docker image asset on this Stack\n   *\n   * @deprecated Use `stack.synthesizer.addDockerImageAsset()` if you are calling,\n   * and a different `IStackSynthesizer` class if you are implementing.\n   */\n  public addDockerImageAsset(asset: DockerImageAssetSource): DockerImageAssetLocation {\n    return this.synthesizer.addDockerImageAsset(asset);\n  }\n\n  /**\n   * If this is a nested stack, returns it's parent stack.\n   */\n  public get nestedStackParent() {\n    return this.nestedStackResource && Stack.of(this.nestedStackResource);\n  }\n\n  /**\n   * Returns the parent of a nested stack.\n   *\n   * @deprecated use `nestedStackParent`\n   */\n  public get parentStack() {\n    return this.nestedStackParent;\n  }\n\n  /**\n   * Add a Transform to this stack. A Transform is a macro that AWS\n   * CloudFormation uses to process your template.\n   *\n   * Duplicate values are removed when stack is synthesized.\n   *\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html\n   * @param transform The transform to add\n   *\n   * @example\n   * declare const stack: Stack;\n   *\n   * stack.addTransform('AWS::Serverless-2016-10-31')\n   */\n  public addTransform(transform: string) {\n    if (!this.templateOptions.transforms) {\n      this.templateOptions.transforms = [];\n    }\n    this.templateOptions.transforms.push(transform);\n  }\n\n  /**\n   * Called implicitly by the `addDependency` helper function in order to\n   * realize a dependency between two top-level stacks at the assembly level.\n   *\n   * Use `stack.addDependency` to define the dependency between any two stacks,\n   * and take into account nested stack relationships.\n   *\n   * @internal\n   */\n  public _addAssemblyDependency(target: Stack, reason?: string) {\n    // defensive: we should never get here for nested stacks\n    if (this.nested || target.nested) {\n      throw new Error('Cannot add assembly-level dependencies for nested stacks');\n    }\n\n    reason = reason || 'dependency added using stack.addDependency()';\n    const cycle = target.stackDependencyReasons(this);\n    if (cycle !== undefined) {\n      // eslint-disable-next-line max-len\n      throw new Error(`'${target.node.path}' depends on '${this.node.path}' (${cycle.join(', ')}). Adding this dependency (${reason}) would create a cyclic reference.`);\n    }\n\n    let dep = this._stackDependencies[Names.uniqueId(target)];\n    if (!dep) {\n      dep = this._stackDependencies[Names.uniqueId(target)] = {\n        stack: target,\n        reasons: [],\n      };\n    }\n\n    dep.reasons.push(reason);\n\n    if (process.env.CDK_DEBUG_DEPS) {\n      // eslint-disable-next-line no-console\n      console.error(`[CDK_DEBUG_DEPS] stack \"${this.node.path}\" depends on \"${target.node.path}\" because: ${reason}`);\n    }\n  }\n\n  /**\n   * Synthesizes the cloudformation template into a cloud assembly.\n   * @internal\n   */\n  public _synthesizeTemplate(session: ISynthesisSession, lookupRoleArn?: string): void {\n    // In principle, stack synthesis is delegated to the\n    // StackSynthesis object.\n    //\n    // However, some parts of synthesis currently use some private\n    // methods on Stack, and I don't really see the value in refactoring\n    // this right now, so some parts still happen here.\n    const builder = session.assembly;\n\n    const template = this._toCloudFormation();\n\n    // write the CloudFormation template as a JSON file\n    const outPath = path.join(builder.outdir, this.templateFile);\n\n    if (this.maxResources > 0) {\n      const resources = template.Resources || {};\n      const numberOfResources = Object.keys(resources).length;\n\n      if (numberOfResources > this.maxResources) {\n        throw new Error(`Number of resources in stack '${this.node.path}': ${numberOfResources} is greater than allowed maximum of ${this.maxResources}`);\n      } else if (numberOfResources >= (this.maxResources * 0.8)) {\n        Annotations.of(this).addInfo(`Number of resources: ${numberOfResources} is approaching allowed maximum of ${this.maxResources}`);\n      }\n    }\n    fs.writeFileSync(outPath, JSON.stringify(template, undefined, 2));\n\n    for (const ctx of this._missingContext) {\n      if (lookupRoleArn != null) {\n        builder.addMissing({ ...ctx, props: { ...ctx.props, lookupRoleArn } });\n      } else {\n        builder.addMissing(ctx);\n      }\n    }\n  }\n\n  /**\n   * Look up a fact value for the given fact for the region of this stack\n   *\n   * Will return a definite value only if the region of the current stack is resolved.\n   * If not, a lookup map will be added to the stack and the lookup will be done at\n   * CDK deployment time.\n   *\n   * What regions will be included in the lookup map is controlled by the\n   * `@aws-cdk/core:target-partitions` context value: it must be set to a list\n   * of partitions, and only regions from the given partitions will be included.\n   * If no such context key is set, all regions will be included.\n   *\n   * This function is intended to be used by construct library authors. Application\n   * builders can rely on the abstractions offered by construct libraries and do\n   * not have to worry about regional facts.\n   *\n   * If `defaultValue` is not given, it is an error if the fact is unknown for\n   * the given region.\n   */\n  public regionalFact(factName: string, defaultValue?: string): string {\n    if (!Token.isUnresolved(this.region)) {\n      const ret = Fact.find(this.region, factName) ?? defaultValue;\n      if (ret === undefined) {\n        throw new Error(`region-info: don't know ${factName} for region ${this.region}. Use 'Fact.register' to provide this value.`);\n      }\n      return ret;\n    }\n\n    const partitions = Node.of(this).tryGetContext(cxapi.TARGET_PARTITIONS);\n    if (partitions !== undefined && !Array.isArray(partitions)) {\n      throw new Error(`Context value '${cxapi.TARGET_PARTITIONS}' should be a list of strings, got: ${JSON.stringify(cxapi.TARGET_PARTITIONS)}`);\n    }\n\n    const lookupMap = partitions ? RegionInfo.limitedRegionMap(factName, partitions) : RegionInfo.regionMap(factName);\n\n    return deployTimeLookup(this, factName, lookupMap, defaultValue);\n  }\n\n\n  /**\n   * Create a CloudFormation Export for a value\n   *\n   * Returns a string representing the corresponding `Fn.importValue()`\n   * expression for this Export. You can control the name for the export by\n   * passing the `name` option.\n   *\n   * If you don't supply a value for `name`, the value you're exporting must be\n   * a Resource attribute (for example: `bucket.bucketName`) and it will be\n   * given the same name as the automatic cross-stack reference that would be created\n   * if you used the attribute in another Stack.\n   *\n   * One of the uses for this method is to *remove* the relationship between\n   * two Stacks established by automatic cross-stack references. It will\n   * temporarily ensure that the CloudFormation Export still exists while you\n   * remove the reference from the consuming stack. After that, you can remove\n   * the resource and the manual export.\n   *\n   * ## Example\n   *\n   * Here is how the process works. Let's say there are two stacks,\n   * `producerStack` and `consumerStack`, and `producerStack` has a bucket\n   * called `bucket`, which is referenced by `consumerStack` (perhaps because\n   * an AWS Lambda Function writes into it, or something like that).\n   *\n   * It is not safe to remove `producerStack.bucket` because as the bucket is being\n   * deleted, `consumerStack` might still be using it.\n   *\n   * Instead, the process takes two deployments:\n   *\n   * ### Deployment 1: break the relationship\n   *\n   * - Make sure `consumerStack` no longer references `bucket.bucketName` (maybe the consumer\n   *   stack now uses its own bucket, or it writes to an AWS DynamoDB table, or maybe you just\n   *   remove the Lambda Function altogether).\n   * - In the `ProducerStack` class, call `this.exportValue(this.bucket.bucketName)`. This\n   *   will make sure the CloudFormation Export continues to exist while the relationship\n   *   between the two stacks is being broken.\n   * - Deploy (this will effectively only change the `consumerStack`, but it's safe to deploy both).\n   *\n   * ### Deployment 2: remove the bucket resource\n   *\n   * - You are now free to remove the `bucket` resource from `producerStack`.\n   * - Don't forget to remove the `exportValue()` call as well.\n   * - Deploy again (this time only the `producerStack` will be changed -- the bucket will be deleted).\n   */\n  public exportValue(exportedValue: any, options: ExportValueOptions = {}) {\n    if (options.name) {\n      new CfnOutput(this, `Export${options.name}`, {\n        value: exportedValue,\n        exportName: options.name,\n      });\n      return Fn.importValue(options.name);\n    }\n\n    const resolvable = Tokenization.reverse(exportedValue);\n    if (!resolvable || !Reference.isReference(resolvable)) {\n      throw new Error('exportValue: either supply \\'name\\' or make sure to export a resource attribute (like \\'bucket.bucketName\\')');\n    }\n\n    // \"teleport\" the value here, in case it comes from a nested stack. This will also\n    // ensure the value is from our own scope.\n    const exportable = referenceNestedStackValueInParent(resolvable, this);\n\n    // Ensure a singleton \"Exports\" scoping Construct\n    // This mostly exists to trigger LogicalID munging, which would be\n    // disabled if we parented constructs directly under Stack.\n    // Also it nicely prevents likely construct name clashes\n    const exportsScope = getCreateExportsScope(this);\n\n    // Ensure a singleton CfnOutput for this value\n    const resolved = this.resolve(exportable);\n    const id = 'Output' + JSON.stringify(resolved);\n    const exportName = generateExportName(exportsScope, id);\n\n    if (Token.isUnresolved(exportName)) {\n      throw new Error(`unresolved token in generated export name: ${JSON.stringify(this.resolve(exportName))}`);\n    }\n\n    const output = exportsScope.node.tryFindChild(id) as CfnOutput;\n    if (!output) {\n      new CfnOutput(exportsScope, id, { value: Token.asString(exportable), exportName });\n    }\n\n    return Fn.importValue(exportName);\n  }\n\n  /**\n   * Returns the naming scheme used to allocate logical IDs. By default, uses\n   * the `HashedAddressingScheme` but this method can be overridden to customize\n   * this behavior.\n   *\n   * In order to make sure logical IDs are unique and stable, we hash the resource\n   * construct tree path (i.e. toplevel/secondlevel/.../myresource) and add it as\n   * a suffix to the path components joined without a separator (CloudFormation\n   * IDs only allow alphanumeric characters).\n   *\n   * The result will be:\n   *\n   *   <path.join('')><md5(path.join('/')>\n   *     \"human\"      \"hash\"\n   *\n   * If the \"human\" part of the ID exceeds 240 characters, we simply trim it so\n   * the total ID doesn't exceed CloudFormation's 255 character limit.\n   *\n   * We only take 8 characters from the md5 hash (0.000005 chance of collision).\n   *\n   * Special cases:\n   *\n   * - If the path only contains a single component (i.e. it's a top-level\n   *   resource), we won't add the hash to it. The hash is not needed for\n   *   disamiguation and also, it allows for a more straightforward migration an\n   *   existing CloudFormation template to a CDK stack without logical ID changes\n   *   (or renames).\n   * - For aesthetic reasons, if the last components of the path are the same\n   *   (i.e. `L1/L2/Pipeline/Pipeline`), they will be de-duplicated to make the\n   *   resulting human portion of the ID more pleasing: `L1L2Pipeline<HASH>`\n   *   instead of `L1L2PipelinePipeline<HASH>`\n   * - If a component is named \"Default\" it will be omitted from the path. This\n   *   allows refactoring higher level abstractions around constructs without affecting\n   *   the IDs of already deployed resources.\n   * - If a component is named \"Resource\" it will be omitted from the user-visible\n   *   path, but included in the hash. This reduces visual noise in the human readable\n   *   part of the identifier.\n   *\n   * @param cfnElement The element for which the logical ID is allocated.\n   */\n  protected allocateLogicalId(cfnElement: CfnElement): string {\n    const scopes = cfnElement.node.scopes;\n    const stackIndex = scopes.indexOf(cfnElement.stack);\n    const pathComponents = scopes.slice(stackIndex + 1).map(x => x.node.id);\n    return makeUniqueId(pathComponents);\n  }\n\n  /**\n   * Validate stack name\n   *\n   * CloudFormation stack names can include dashes in addition to the regular identifier\n   * character classes, and we don't allow one of the magic markers.\n   *\n   * @internal\n   */\n  protected _validateId(name: string) {\n    if (name && !VALID_STACK_NAME_REGEX.test(name)) {\n      throw new Error(`Stack name must match the regular expression: ${VALID_STACK_NAME_REGEX.toString()}, got '${name}'`);\n    }\n  }\n\n  /**\n   * Returns the CloudFormation template for this stack by traversing\n   * the tree and invoking _toCloudFormation() on all Entity objects.\n   *\n   * @internal\n   */\n  protected _toCloudFormation() {\n    let transform: string | string[] | undefined;\n\n    if (this.templateOptions.transform) {\n      // eslint-disable-next-line max-len\n      Annotations.of(this).addWarning('This stack is using the deprecated `templateOptions.transform` property. Consider switching to `addTransform()`.');\n      this.addTransform(this.templateOptions.transform);\n    }\n\n    if (this.templateOptions.transforms) {\n      if (this.templateOptions.transforms.length === 1) { // Extract single value\n        transform = this.templateOptions.transforms[0];\n      } else { // Remove duplicate values\n        transform = Array.from(new Set(this.templateOptions.transforms));\n      }\n    }\n\n    const template: any = {\n      Description: this.templateOptions.description,\n      Transform: transform,\n      AWSTemplateFormatVersion: this.templateOptions.templateFormatVersion,\n      Metadata: this.templateOptions.metadata,\n    };\n\n    const elements = cfnElements(this);\n    const fragments = elements.map(e => this.resolve(e._toCloudFormation()));\n\n    // merge in all CloudFormation fragments collected from the tree\n    for (const fragment of fragments) {\n      merge(template, fragment);\n    }\n\n    // resolve all tokens and remove all empties\n    const ret = this.resolve(template) || {};\n\n    this._logicalIds.assertAllRenamesApplied();\n\n    return ret;\n  }\n\n  /**\n   * Deprecated.\n   *\n   * @see https://github.com/aws/aws-cdk/pull/7187\n   * @returns reference itself without any change\n   * @deprecated cross reference handling has been moved to `App.prepare()`.\n   */\n  protected prepareCrossReference(_sourceStack: Stack, reference: Reference): IResolvable {\n    return reference;\n  }\n\n  /**\n   * Determine the various stack environment attributes.\n   *\n   */\n  private parseEnvironment(env: Environment = {}) {\n    // if an environment property is explicitly specified when the stack is\n    // created, it will be used. if not, use tokens for account and region.\n    //\n    // (They do not need to be anchored to any construct like resource attributes\n    // are, because we'll never Export/Fn::ImportValue them -- the only situation\n    // in which Export/Fn::ImportValue would work is if the value are the same\n    // between producer and consumer anyway, so we can just assume that they are).\n    const containingAssembly = Stage.of(this);\n    const account = env.account ?? containingAssembly?.account ?? Aws.ACCOUNT_ID;\n    const region = env.region ?? containingAssembly?.region ?? Aws.REGION;\n\n    // this is the \"aws://\" env specification that will be written to the cloud assembly\n    // manifest. it will use \"unknown-account\" and \"unknown-region\" to indicate\n    // environment-agnosticness.\n    const envAccount = !Token.isUnresolved(account) ? account : cxapi.UNKNOWN_ACCOUNT;\n    const envRegion = !Token.isUnresolved(region) ? region : cxapi.UNKNOWN_REGION;\n\n    return {\n      account,\n      region,\n      environment: cxapi.EnvironmentUtils.format(envAccount, envRegion),\n    };\n  }\n\n  /**\n   * Maximum number of resources in the stack\n   *\n   * Set to 0 to mean \"unlimited\".\n   */\n  private get maxResources(): number {\n    const contextLimit = this.node.tryGetContext(STACK_RESOURCE_LIMIT_CONTEXT);\n    return contextLimit !== undefined ? parseInt(contextLimit, 10) : MAX_RESOURCES;\n  }\n\n  /**\n   * Check whether this stack has a (transitive) dependency on another stack\n   *\n   * Returns the list of reasons on the dependency path, or undefined\n   * if there is no dependency.\n   */\n  private stackDependencyReasons(other: Stack): string[] | undefined {\n    if (this === other) { return []; }\n    for (const dep of Object.values(this._stackDependencies)) {\n      const ret = dep.stack.stackDependencyReasons(other);\n      if (ret !== undefined) {\n        return [...dep.reasons, ...ret];\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Calculate the stack name based on the construct path\n   *\n   * The stack name is the name under which we'll deploy the stack,\n   * and incorporates containing Stage names by default.\n   *\n   * Generally this looks a lot like how logical IDs are calculated.\n   * The stack name is calculated based on the construct root path,\n   * as follows:\n   *\n   * - Path is calculated with respect to containing App or Stage (if any)\n   * - If the path is one component long just use that component, otherwise\n   *   combine them with a hash.\n   *\n   * Since the hash is quite ugly and we'd like to avoid it if possible -- but\n   * we can't anymore in the general case since it has been written into legacy\n   * stacks. The introduction of Stages makes it possible to make this nicer however.\n   * When a Stack is nested inside a Stage, we use the path components below the\n   * Stage, and prefix the path components of the Stage before it.\n   */\n  private generateStackName() {\n    const assembly = Stage.of(this);\n    const prefix = (assembly && assembly.stageName) ? `${assembly.stageName}-` : '';\n    return `${prefix}${this.generateStackId(assembly)}`;\n  }\n\n  /**\n   * The artifact ID for this stack\n   *\n   * Stack artifact ID is unique within the App's Cloud Assembly.\n   */\n  private generateStackArtifactId() {\n    return this.generateStackId(this.node.root);\n  }\n\n  /**\n   * Generate an ID with respect to the given container construct.\n   */\n  private generateStackId(container: IConstruct | undefined) {\n    const rootPath = rootPathTo(this, container);\n    const ids = rootPath.map(c => Node.of(c).id);\n\n    // In unit tests our Stack (which is the only component) may not have an\n    // id, so in that case just pretend it's \"Stack\".\n    if (ids.length === 1 && !ids[0]) {\n      throw new Error('unexpected: stack id must always be defined');\n    }\n\n    return makeStackName(ids);\n  }\n}\n\nfunction merge(template: any, fragment: any): void {\n  for (const section of Object.keys(fragment)) {\n    const src = fragment[section];\n\n    // create top-level section if it doesn't exist\n    const dest = template[section];\n    if (!dest) {\n      template[section] = src;\n    } else {\n      template[section] = mergeSection(section, dest, src);\n    }\n  }\n}\n\nfunction mergeSection(section: string, val1: any, val2: any): any {\n  switch (section) {\n    case 'Description':\n      return `${val1}\\n${val2}`;\n    case 'AWSTemplateFormatVersion':\n      if (val1 != null && val2 != null && val1 !== val2) {\n        throw new Error(`Conflicting CloudFormation template versions provided: '${val1}' and '${val2}`);\n      }\n      return val1 ?? val2;\n    case 'Transform':\n      return mergeSets(val1, val2);\n    default:\n      return mergeObjectsWithoutDuplicates(section, val1, val2);\n  }\n}\n\nfunction mergeSets(val1: any, val2: any): any {\n  const array1 = val1 == null ? [] : (Array.isArray(val1) ? val1 : [val1]);\n  const array2 = val2 == null ? [] : (Array.isArray(val2) ? val2 : [val2]);\n  for (const value of array2) {\n    if (!array1.includes(value)) {\n      array1.push(value);\n    }\n  }\n  return array1.length === 1 ? array1[0] : array1;\n}\n\nfunction mergeObjectsWithoutDuplicates(section: string, dest: any, src: any): any {\n  if (typeof dest !== 'object') {\n    throw new Error(`Expecting ${JSON.stringify(dest)} to be an object`);\n  }\n  if (typeof src !== 'object') {\n    throw new Error(`Expecting ${JSON.stringify(src)} to be an object`);\n  }\n\n  // add all entities from source section to destination section\n  for (const id of Object.keys(src)) {\n    if (id in dest) {\n      throw new Error(`section '${section}' already contains '${id}'`);\n    }\n    dest[id] = src[id];\n  }\n\n  return dest;\n}\n\n/**\n * CloudFormation template options for a stack.\n */\nexport interface ITemplateOptions {\n  /**\n   * Gets or sets the description of this stack.\n   * If provided, it will be included in the CloudFormation template's \"Description\" attribute.\n   */\n  description?: string;\n\n  /**\n   * Gets or sets the AWSTemplateFormatVersion field of the CloudFormation template.\n   */\n  templateFormatVersion?: string;\n\n  /**\n   * Gets or sets the top-level template transform for this stack (e.g. \"AWS::Serverless-2016-10-31\").\n   *\n   * @deprecated use `transforms` instead.\n   */\n  transform?: string;\n\n  /**\n   * Gets or sets the top-level template transform(s) for this stack (e.g. `[\"AWS::Serverless-2016-10-31\"]`).\n   */\n  transforms?: string[];\n\n  /**\n   * Metadata associated with the CloudFormation template.\n   */\n  metadata?: { [key: string]: any };\n}\n\n/**\n * Collect all CfnElements from a Stack.\n *\n * @param node Root node to collect all CfnElements from\n * @param into Array to append CfnElements to\n * @returns The same array as is being collected into\n */\nfunction cfnElements(node: IConstruct, into: CfnElement[] = []): CfnElement[] {\n  if (CfnElement.isCfnElement(node)) {\n    into.push(node);\n  }\n\n  for (const child of Node.of(node).children) {\n    // Don't recurse into a substack\n    if (Stack.isStack(child)) { continue; }\n\n    cfnElements(child, into);\n  }\n\n  return into;\n}\n\n/**\n * Return the construct root path of the given construct relative to the given ancestor\n *\n * If no ancestor is given or the ancestor is not found, return the entire root path.\n */\nexport function rootPathTo(construct: IConstruct, ancestor?: IConstruct): IConstruct[] {\n  const scopes = Node.of(construct).scopes;\n  for (let i = scopes.length - 2; i >= 0; i--) {\n    if (scopes[i] === ancestor) {\n      return scopes.slice(i + 1);\n    }\n  }\n  return scopes;\n}\n\n/**\n * makeUniqueId, specialized for Stack names\n *\n * Stack names may contain '-', so we allow that character if the stack name\n * has only one component. Otherwise we fall back to the regular \"makeUniqueId\"\n * behavior.\n */\nfunction makeStackName(components: string[]) {\n  if (components.length === 1) { return components[0]; }\n  return makeUniqueId(components);\n}\n\nfunction getCreateExportsScope(stack: Stack) {\n  const exportsName = 'Exports';\n  let stackExports = stack.node.tryFindChild(exportsName) as Construct;\n  if (stackExports === undefined) {\n    stackExports = new Construct(stack, exportsName);\n  }\n\n  return stackExports;\n}\n\nfunction generateExportName(stackExports: Construct, id: string) {\n  const stackRelativeExports = FeatureFlags.of(stackExports).isEnabled(cxapi.STACK_RELATIVE_EXPORTS_CONTEXT);\n  const stack = Stack.of(stackExports);\n\n  const components = [\n    ...stackExports.node.scopes\n      .slice(stackRelativeExports ? stack.node.scopes.length : 2)\n      .map(c => c.node.id),\n    id,\n  ];\n  const prefix = stack.stackName ? stack.stackName + ':' : '';\n  const localPart = makeUniqueId(components);\n  const maxLength = 255;\n  return prefix + localPart.slice(Math.max(0, localPart.length - maxLength + prefix.length));\n}\n\ninterface StackDependency {\n  stack: Stack;\n  reasons: string[];\n}\n\n\n/**\n * Options for the `stack.exportValue()` method\n */\nexport interface ExportValueOptions {\n  /**\n   * The name of the export to create\n   *\n   * @default - A name is automatically chosen\n   */\n  readonly name?: string;\n}\n\n// These imports have to be at the end to prevent circular imports\nimport { CfnOutput } from './cfn-output';\nimport { addDependency } from './deps';\nimport { FileSystem } from './fs';\nimport { Names } from './names';\nimport { Reference } from './reference';\nimport { IResolvable } from './resolvable';\nimport { DefaultStackSynthesizer, IStackSynthesizer, ISynthesisSession, LegacyStackSynthesizer } from './stack-synthesizers';\nimport { Stage } from './stage';\nimport { ITaggable, TagManager } from './tag-manager';\nimport { Token, Tokenization } from './token';\nimport { referenceNestedStackValueInParent } from './private/refs';\nimport { Fact, RegionInfo } from '../../region-info';\nimport { deployTimeLookup } from './private/region-lookup';\n\n"],
  "mappings": "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",
  "names": []
}
