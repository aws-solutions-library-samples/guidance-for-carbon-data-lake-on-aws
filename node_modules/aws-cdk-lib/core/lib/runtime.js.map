{
  "version": 3,
  "sources": ["runtime.ts"],
  "sourcesContent": ["import { Construct } from 'constructs';\n\n// ----------------------------------------------------------------------\n// PROPERTY MAPPERS\n//\n// These are used while converting generated classes/property bags to CloudFormation property objects\n//\n// We use identity mappers for the primitive types. These don't do anything but are there to make the code\n// generation work out nicely (so the code generator doesn't need to emit different code for primitive\n// vs. complex types).\nexport type Mapper = (x: any) => any;\n\nfunction identity(x: any) {\n  return x;\n}\n\nexport const stringToCloudFormation: Mapper = identity;\nexport const booleanToCloudFormation: Mapper = identity;\nexport const objectToCloudFormation: Mapper = identity;\nexport const numberToCloudFormation: Mapper = identity;\n\n/**\n * The date needs to be formatted as an ISO date in UTC\n *\n * Some usage sites require a date, some require a timestamp. We'll\n * always output a timestamp and hope the parser on the other end\n * is smart enough to ignore the time part... (?)\n */\nexport function dateToCloudFormation(x?: Date): any {\n  if (!x) {\n    return undefined;\n  }\n\n  // eslint-disable-next-line max-len\n  return `${x.getUTCFullYear()}-${pad(x.getUTCMonth() + 1)}-${pad(x.getUTCDate())}T${pad(x.getUTCHours())}:${pad(x.getUTCMinutes())}:${pad(x.getUTCSeconds())}`;\n}\n\n/**\n * Pad a number to 2 decimal places\n */\nfunction pad(x: number) {\n  if (x < 10) {\n    return '0' + x.toString();\n  }\n  return x.toString();\n}\n\n/**\n * Turn a tag object into the proper CloudFormation representation\n */\nexport function cfnTagToCloudFormation(x: any): any {\n  return {\n    Key: x.key,\n    Value: x.value,\n  };\n}\n\nexport function listMapper(elementMapper: Mapper): Mapper {\n  return (x: any) => {\n    if (!canInspect(x)) { return x; }\n    return x.map(elementMapper);\n  };\n}\n\nexport function hashMapper(elementMapper: Mapper): Mapper {\n  return (x: any) => {\n    if (!canInspect(x)) { return x; }\n\n    const ret: any = {};\n\n    Object.keys(x).forEach((key) => {\n      ret[key] = elementMapper(x[key]);\n    });\n\n    return ret;\n  };\n}\n\n/**\n * Return a union mapper\n *\n * Takes a list of validators and a list of mappers, which should correspond pairwise.\n *\n * The mapper of the first successful validator will be called.\n */\nexport function unionMapper(validators: Validator[], mappers: Mapper[]): Mapper {\n  if (validators.length !== mappers.length) {\n    throw Error('Not the same amount of validators and mappers passed to unionMapper()');\n  }\n\n  return (x: any) => {\n    if (!canInspect(x)) { return x; }\n\n    for (let i = 0; i < validators.length; i++) {\n      if (validators[i](x).isSuccess) {\n        return mappers[i](x);\n      }\n    }\n\n    // Should not be possible because the union must have passed validation before this function\n    // will be called, but catch it anyway.\n    throw new TypeError('No validators matched in the union()');\n  };\n}\n\n// ----------------------------------------------------------------------\n// VALIDATORS\n//\n// These are used while checking that supplied property bags match the expected schema\n//\n// We have a couple of datatypes that model validation errors and collections of validation\n// errors (together forming a tree of errors so that we can trace validation errors through\n// an object graph), and validators.\n//\n// Validators are simply functions that take a value and return a validation results. Then\n// we have some combinators to turn primitive validators into more complex validators.\n//\n\n/**\n * Representation of validation results\n *\n * Models a tree of validation errors so that we have as much information as possible\n * about the failure that occurred.\n */\nexport class ValidationResult {\n  constructor(readonly errorMessage: string = '', readonly results: ValidationResults = new ValidationResults()) {\n  }\n\n  public get isSuccess(): boolean {\n    return !this.errorMessage && this.results.isSuccess;\n  }\n\n  /**\n   * Turn a failed validation into an exception\n   */\n  public assertSuccess() {\n    if (!this.isSuccess) {\n      let message = this.errorTree();\n      // The first letter will be lowercase, so uppercase it for a nicer error message\n      message = message.substr(0, 1).toUpperCase() + message.substr(1);\n      throw new CfnSynthesisError(message);\n    }\n  }\n\n  /**\n   * Return a string rendering of the tree of validation failures\n   */\n  public errorTree(): string {\n    const childMessages = this.results.errorTreeList();\n    return this.errorMessage + (childMessages.length ? `\\n  ${childMessages.replace(/\\n/g, '\\n  ')}` : '');\n  }\n\n  /**\n   * Wrap this result with an error message, if it concerns an error\n   */\n  public prefix(message: string): ValidationResult {\n    if (this.isSuccess) { return this; }\n    return new ValidationResult(`${message}: ${this.errorMessage}`, this.results);\n  }\n}\n\n/**\n * A collection of validation results\n */\nexport class ValidationResults {\n  constructor(public results: ValidationResult[] = []) {\n  }\n\n  public collect(result: ValidationResult) {\n    // Only collect failures\n    if (!result.isSuccess) {\n      this.results.push(result);\n    }\n  }\n\n  public get isSuccess(): boolean {\n    return this.results.every(x => x.isSuccess);\n  }\n\n  public errorTreeList(): string {\n    return this.results.map(child => child.errorTree()).join('\\n');\n  }\n\n  /**\n   * Wrap up all validation results into a single tree node\n   *\n   * If there are failures in the collection, add a message, otherwise\n   * return a success.\n   */\n  public wrap(message: string): ValidationResult {\n    if (this.isSuccess) {\u00A0return VALIDATION_SUCCESS; }\n    return new ValidationResult(message, this);\n  }\n}\n\n// Singleton object to save on allocations\nexport const VALIDATION_SUCCESS = new ValidationResult();\n\nexport type Validator = (x: any) => ValidationResult;\n\n/**\n * Return whether this object can be validated at all\n *\n * True unless it's undefined or a CloudFormation intrinsic\n */\nexport function canInspect(x: any) {\n  // Note: using weak equality on purpose, we also want to catch undefined\n  return (x != null && !isCloudFormationIntrinsic(x) && !isCloudFormationDynamicReference(x));\n}\n\n// CloudFormation validators for primitive types\nexport function validateString(x: any): ValidationResult {\n  if (canInspect(x) && typeof x !== 'string') {\n    return new ValidationResult(`${JSON.stringify(x)} should be a string`);\n  }\n  return VALIDATION_SUCCESS;\n}\n\nexport function validateNumber(x: any): ValidationResult {\n  if (canInspect(x) && typeof x !== 'number') {\n    return new ValidationResult(`${JSON.stringify(x)} should be a number`);\n  }\n  return VALIDATION_SUCCESS;\n}\n\nexport function validateBoolean(x: any): ValidationResult {\n  if (canInspect(x) && typeof x !== 'boolean') {\n    return new ValidationResult(`${JSON.stringify(x)} should be a boolean`);\n  }\n  return VALIDATION_SUCCESS;\n}\n\nexport function validateDate(x: any): ValidationResult {\n  if (canInspect(x) && !(x instanceof Date)) {\n    return new ValidationResult(`${JSON.stringify(x)} should be a Date`);\n  }\n\n  if (x !== undefined && isNaN(x.getTime())) {\n    return new ValidationResult('got an unparseable Date');\n  }\n\n  return VALIDATION_SUCCESS;\n}\n\nexport function validateObject(x: any): ValidationResult {\n  if (canInspect(x) && typeof x !== 'object') {\n    return new ValidationResult(`${JSON.stringify(x)} should be an 'object'`);\n  }\n  return VALIDATION_SUCCESS;\n}\n\nexport function validateCfnTag(x: any): ValidationResult {\n  if (!canInspect(x)) { return VALIDATION_SUCCESS; }\n\n  if (x.key == null || x.value == null) {\n    return new ValidationResult(`${JSON.stringify(x)} should have a 'key' and a 'value' property`);\n  }\n\n  return VALIDATION_SUCCESS;\n}\n\n/**\n * Return a list validator based on the given element validator\n */\nexport function listValidator(elementValidator: Validator): Validator {\n  return (x: any) => {\n    if (!canInspect(x)) { return VALIDATION_SUCCESS; }\n\n    if (!x.forEach) {\n      return new ValidationResult(`${JSON.stringify(x)} should be a list`);\n    }\n\n    for (let i = 0; i < x.length; i++) {\n      const element = x[i];\n      const result = elementValidator(element);\n      if (!result.isSuccess) { return result.prefix(`element ${i}`); }\n    }\n\n    return VALIDATION_SUCCESS;\n  };\n}\n\n/**\n * Return a hash validator based on the given element validator\n */\nexport function hashValidator(elementValidator: Validator): Validator {\n  return (x: any) => {\n    if (!canInspect(x)) { return VALIDATION_SUCCESS; }\n\n    for (const key of Object.keys(x)) {\n      const result = elementValidator(x[key]);\n      if (!result.isSuccess) { return result.prefix(`element '${key}'`); }\n    }\n\n    return VALIDATION_SUCCESS;\n  };\n}\n\n/**\n * Decorate a validator with a message clarifying the property the failure is for.\n */\nexport function propertyValidator(propName: string, validator: Validator): Validator {\n  return (x: any) => {\n    return validator(x).prefix(propName);\n  };\n}\n\n/**\n * Return a validator that will fail if the passed property is not present\n *\n * Does not distinguish between the property actually not being present, vs being present but 'null'\n * or 'undefined' (courtesy of JavaScript), which is generally the behavior that we want.\n *\n * Empty strings are considered \"present\"--don't know if this agrees with how CloudFormation looks\n * at the world.\n */\nexport function requiredValidator(x: any) {\n  if (x == null) {\n    return new ValidationResult('required but missing');\n  }\n  return VALIDATION_SUCCESS;\n}\n\n/**\n * Require a property from a property bag.\n *\n * @param props  the property bag from which a property is required.\n * @param name   the name of the required property.\n * @param typeName the name of the construct type that requires the property\n *\n * @returns the value of ``props[name]``\n *\n * @throws if the property ``name`` is not present in ``props``.\n */\nexport function requireProperty(props: { [name: string]: any }, name: string, context: Construct): any {\n  const value = props[name];\n  if (value == null) {\n    throw new Error(`${context.toString()} is missing required property: ${name}`);\n  }\n  // Possibly add type-checking here...\n  return value;\n}\n\n/**\n * Validates if any of the given validators matches\n *\n * We add either/or words to the front of the error mesages so that they read\n * more nicely. Example:\n *\n *   Properties not correct for 'FunctionProps'\n *     codeUri: not one of the possible types\n *       either: properties not correct for 'S3LocationProperty'\n *         bucket: required but missing\n *         key: required but missing\n *         version: required but missing\n *       or: '3' should be a 'string'\n *\n */\nexport function unionValidator(...validators: Validator[]): Validator {\n  return (x: any) => {\n    const results = new ValidationResults();\n    let eitherOr = 'either';\n\n    for (const validator of validators) {\n      const result = validator(x);\n      if (result.isSuccess) { return result; }\n      results.collect(result.prefix(eitherOr));\n      eitherOr = 'or';\n    }\n    return results.wrap('not one of the possible types');\n  };\n}\n\n/**\n * Return whether the indicated value represents a CloudFormation intrinsic.\n *\n * CloudFormation intrinsics are modeled as objects with a single key, which\n * look like: { \"Fn::GetAtt\": [...] } or similar.\n */\nfunction isCloudFormationIntrinsic(x: any) {\n  if (!(typeof x === 'object')) { return false; }\n  const keys = Object.keys(x);\n  if (keys.length !== 1) { return false; }\n\n  return keys[0] === 'Ref' || keys[0].substr(0, 4) === 'Fn::';\n}\n\n/**\n * Check whether the indicated value is a CloudFormation dynamic reference.\n *\n * CloudFormation dynamic references take the format: '{{resolve:service-name:reference-key}}'\n */\nfunction isCloudFormationDynamicReference(x: any) {\n  return (typeof x === 'string' && x.startsWith('{{resolve:') && x.endsWith('}}'));\n}\n\n// Cannot be public because JSII gets confused about es5.d.ts\nclass CfnSynthesisError extends Error {\n  public readonly type = 'CfnSynthesisError';\n}\n"],
  "mappings": "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",
  "names": []
}
