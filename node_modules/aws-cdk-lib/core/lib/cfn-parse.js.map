{
  "version": 3,
  "sources": ["cfn-parse.ts"],
  "sourcesContent": ["import { CfnCondition } from './cfn-condition';\nimport { CfnElement } from './cfn-element';\nimport { Fn } from './cfn-fn';\nimport { CfnMapping } from './cfn-mapping';\nimport { Aws } from './cfn-pseudo';\nimport { CfnResource } from './cfn-resource';\nimport {\n  CfnAutoScalingReplacingUpdate, CfnAutoScalingRollingUpdate, CfnAutoScalingScheduledAction, CfnCodeDeployLambdaAliasUpdate,\n  CfnCreationPolicy, CfnDeletionPolicy, CfnResourceAutoScalingCreationPolicy, CfnResourceSignal, CfnUpdatePolicy,\n} from './cfn-resource-policy';\nimport { CfnTag } from './cfn-tag';\nimport { Lazy } from './lazy';\nimport { CfnReference, ReferenceRendering } from './private/cfn-reference';\nimport { IResolvable } from './resolvable';\nimport { Validator } from './runtime';\nimport { isResolvableObject, Token } from './token';\nimport { undefinedIfAllValuesAreEmpty } from './util';\n\n/**\n * The class used as the intermediate result from the generated L1 methods\n * that convert from CloudFormation's UpperCase to CDK's lowerCase property names.\n * Saves any extra properties that were present in the argument object,\n * but that were not found in the CFN schema,\n * so that they're not lost from the final CDK-rendered template.\n */\nexport class FromCloudFormationResult<T> {\n  public readonly value: T;\n  public readonly extraProperties: { [key: string]: any };\n\n  public constructor(value: T) {\n    this.value = value;\n    this.extraProperties = {};\n  }\n\n  public appendExtraProperties(prefix: string, properties: { [key: string]: any } | undefined): void {\n    for (const [key, val] of Object.entries(properties ?? {})) {\n      this.extraProperties[`${prefix}.${key}`] = val;\n    }\n  }\n}\n\n/**\n * A property object we will accumulate properties into\n */\nexport class FromCloudFormationPropertyObject<T extends Record<string, any>> extends FromCloudFormationResult<T> {\n  private readonly recognizedProperties = new Set<string>();\n\n  public constructor() {\n    super({} as any); // We're still accumulating\n  }\n\n  /**\n   * Add a parse result under a given key\n   */\n  public addPropertyResult(cdkPropName: keyof T, cfnPropName: string, result?: FromCloudFormationResult<any>): void {\n    this.recognizedProperties.add(cfnPropName);\n    if (!result) { return; }\n    this.value[cdkPropName] = result.value;\n    this.appendExtraProperties(cfnPropName, result.extraProperties);\n  }\n\n  public addUnrecognizedPropertiesAsExtra(properties: object): void {\n    for (const [key, val] of Object.entries(properties)) {\n      if (!this.recognizedProperties.has(key)) {\n        this.extraProperties[key] = val;\n      }\n    }\n  }\n}\n\n/**\n * This class contains static methods called when going from\n * translated values received from {@link CfnParser.parseValue}\n * to the actual L1 properties -\n * things like changing IResolvable to the appropriate type\n * (string, string array, or number), etc.\n *\n * While this file not exported from the module\n * (to not make it part of the public API),\n * it is directly referenced in the generated L1 code.\n *\n */\nexport class FromCloudFormation {\n  // nothing to for any but return it\n  public static getAny(value: any): FromCloudFormationResult<any> {\n    return new FromCloudFormationResult(value);\n  }\n\n  public static getBoolean(value: any): FromCloudFormationResult<boolean | IResolvable> {\n    if (typeof value === 'string') {\n      // CloudFormation allows passing strings as boolean\n      switch (value) {\n        case 'true': return new FromCloudFormationResult(true);\n        case 'false': return new FromCloudFormationResult(false);\n        default: throw new Error(`Expected 'true' or 'false' for boolean value, got: '${value}'`);\n      }\n    }\n\n    // in all other cases, just return the value,\n    // and let a validator handle if it's not a boolean\n    return new FromCloudFormationResult(value);\n  }\n\n  public static getDate(value: any): FromCloudFormationResult<Date | IResolvable> {\n    // if the date is a deploy-time value, just return it\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(value);\n    }\n\n    // if the date has been given as a string, convert it\n    if (typeof value === 'string') {\n      return new FromCloudFormationResult(new Date(value));\n    }\n\n    // all other cases - just return the value,\n    // if it's not a Date, a validator should catch it\n    return new FromCloudFormationResult(value);\n  }\n\n  // won't always return a string; if the input can't be resolved to a string,\n  // the input will be returned.\n  public static getString(value: any): FromCloudFormationResult<string> {\n    // if the string is a deploy-time value, serialize it to a Token\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(value.toString());\n    }\n\n    // CloudFormation treats numbers and strings interchangeably;\n    // so, if we get a number here, convert it to a string\n    if (typeof value === 'number') {\n      return new FromCloudFormationResult(value.toString());\n    }\n\n    // CloudFormation treats booleans and strings interchangeably;\n    // so, if we get a boolean here, convert it to a string\n    if (typeof value === 'boolean') {\n      return new FromCloudFormationResult(value.toString());\n    }\n\n    // in all other cases, just return the input,\n    // and let a validator handle it if it's not a string\n    return new FromCloudFormationResult(value);\n  }\n\n  // won't always return a number; if the input can't be parsed to a number,\n  // the input will be returned.\n  public static getNumber(value: any): FromCloudFormationResult<number> {\n    // if the string is a deploy-time value, serialize it to a Token\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(Token.asNumber(value));\n    }\n\n    // return a number, if the input can be parsed as one\n    if (typeof value === 'string') {\n      const parsedValue = parseFloat(value);\n      if (!isNaN(parsedValue)) {\n        return new FromCloudFormationResult(parsedValue);\n      }\n    }\n\n    // otherwise return the input,\n    // and let a validator handle it if it's not a number\n    return new FromCloudFormationResult(value);\n  }\n\n  public static getStringArray(value: any): FromCloudFormationResult<string[]> {\n    // if the array is a deploy-time value, serialize it to a Token\n    if (isResolvableObject(value)) {\n      return new FromCloudFormationResult(Token.asList(value));\n    }\n\n    // in all other cases, delegate to the standard mapping logic\n    return this.getArray(this.getString)(value);\n  }\n\n  public static getArray<T>(mapper: (arg: any) => FromCloudFormationResult<T>): (x: any) => FromCloudFormationResult<T[]> {\n    return (value: any) => {\n      if (!Array.isArray(value)) {\n        // break the type system, and just return the given value,\n        // which hopefully will be reported as invalid by the validator\n        // of the property we're transforming\n        // (unless it's a deploy-time value,\n        // which we can't map over at build time anyway)\n        return new FromCloudFormationResult(value);\n      }\n\n      const values = new Array<any>();\n      const ret = new FromCloudFormationResult(values);\n      for (let i = 0; i < value.length; i++) {\n        const result = mapper(value[i]);\n        values.push(result.value);\n        ret.appendExtraProperties(`${i}`, result.extraProperties);\n      }\n      return ret;\n    };\n  }\n\n  public static getMap<T>(mapper: (arg: any) => FromCloudFormationResult<T>): (x: any) => FromCloudFormationResult<{ [key: string]: T }> {\n    return (value: any) => {\n      if (typeof value !== 'object') {\n        // if the input is not a map (= object in JS land),\n        // just return it, and let the validator of this property handle it\n        // (unless it's a deploy-time value,\n        // which we can't map over at build time anyway)\n        return new FromCloudFormationResult(value);\n      }\n\n      const values: { [key: string]: T } = {};\n      const ret = new FromCloudFormationResult(values);\n      for (const [key, val] of Object.entries(value)) {\n        const result = mapper(val);\n        values[key] = result.value;\n        ret.appendExtraProperties(key, result.extraProperties);\n      }\n      return ret;\n    };\n  }\n\n  public static getCfnTag(tag: any): FromCloudFormationResult<CfnTag> {\n    return tag == null\n      ? new FromCloudFormationResult({ } as any) // break the type system - this should be detected at runtime by a tag validator\n      : new FromCloudFormationResult({\n        key: tag.Key,\n        value: tag.Value,\n      });\n  }\n\n  /**\n   * Return a function that, when applied to a value, will return the first validly deserialized one\n   */\n  public static getTypeUnion(validators: Validator[], mappers: Array<(x: any) => FromCloudFormationResult<any>>):\n  (x: any) => FromCloudFormationResult<any> {\n    return (value: any) => {\n      for (let i = 0; i < validators.length; i++) {\n        const candidate = mappers[i](value);\n        if (validators[i](candidate.value).isSuccess) {\n          return candidate;\n        }\n      }\n\n      // if nothing matches, just return the input unchanged, and let validators catch it\n      return new FromCloudFormationResult(value);\n    };\n  }\n}\n\n/**\n * An interface that represents callbacks into a CloudFormation template.\n * Used by the fromCloudFormation methods in the generated L1 classes.\n */\nexport interface ICfnFinder {\n  /**\n   * Return the Condition with the given name from the template.\n   * If there is no Condition with that name in the template,\n   * returns undefined.\n   */\n  findCondition(conditionName: string): CfnCondition | undefined;\n\n  /**\n   * Return the Mapping with the given name from the template.\n   * If there is no Mapping with that name in the template,\n   * returns undefined.\n   */\n  findMapping(mappingName: string): CfnMapping | undefined;\n\n  /**\n   * Returns the element referenced using a Ref expression with the given name.\n   * If there is no element with this name in the template,\n   * return undefined.\n   */\n  findRefTarget(elementName: string): CfnElement | undefined;\n\n  /**\n   * Returns the resource with the given logical ID in the template.\n   * If a resource with that logical ID was not found in the template,\n   * returns undefined.\n   */\n  findResource(logicalId: string): CfnResource | undefined;\n}\n\n/**\n * The interface used as the last argument to the fromCloudFormation\n * static method of the generated L1 classes.\n */\nexport interface FromCloudFormationOptions {\n  /**\n   * The parser used to convert CloudFormation to values the CDK understands.\n   */\n  readonly parser: CfnParser;\n}\n\n/**\n * The context in which the parsing is taking place.\n *\n * Some fragments of CloudFormation templates behave differently than others\n * (for example, the 'Conditions' sections treats { \"Condition\": \"NameOfCond\" }\n * differently than the 'Resources' section).\n * This enum can be used to change the created {@link CfnParser} behavior,\n * based on the template context.\n */\nexport enum CfnParsingContext {\n  /** We're currently parsing the 'Conditions' section. */\n  CONDITIONS,\n\n  /** We're currently parsing the 'Rules' section. */\n  RULES,\n}\n\n/**\n * The options for {@link FromCloudFormation.parseValue}.\n */\nexport interface ParseCfnOptions {\n  /**\n   * The finder interface used to resolve references in the template.\n   */\n  readonly finder: ICfnFinder;\n\n  /**\n   * The context we're parsing the template in.\n   *\n   * @default - the default context (no special behavior)\n   */\n  readonly context?: CfnParsingContext;\n\n  /**\n   * Values provided here will replace references to parameters in the parsed template.\n   */\n  readonly parameters: { [parameterName: string]: any };\n}\n\n/**\n * This class contains methods for translating from a pure CFN value\n * (like a JS object { \"Ref\": \"Bucket\" })\n * to a form CDK understands\n * (like Fn.ref('Bucket')).\n *\n * While this file not exported from the module\n * (to not make it part of the public API),\n * it is directly referenced in the generated L1 code,\n * so any renames of it need to be reflected in cfn2ts/codegen.ts as well.\n *\n */\nexport class CfnParser {\n  private readonly options: ParseCfnOptions;\n\n  constructor(options: ParseCfnOptions) {\n    this.options = options;\n  }\n\n  public handleAttributes(resource: CfnResource, resourceAttributes: any, logicalId: string): void {\n    const cfnOptions = resource.cfnOptions;\n\n    cfnOptions.creationPolicy = this.parseCreationPolicy(resourceAttributes.CreationPolicy);\n    cfnOptions.updatePolicy = this.parseUpdatePolicy(resourceAttributes.UpdatePolicy);\n    cfnOptions.deletionPolicy = this.parseDeletionPolicy(resourceAttributes.DeletionPolicy);\n    cfnOptions.updateReplacePolicy = this.parseDeletionPolicy(resourceAttributes.UpdateReplacePolicy);\n    cfnOptions.version = this.parseValue(resourceAttributes.Version);\n    cfnOptions.description = this.parseValue(resourceAttributes.Description);\n    cfnOptions.metadata = this.parseValue(resourceAttributes.Metadata);\n\n    // handle Condition\n    if (resourceAttributes.Condition) {\n      const condition = this.finder.findCondition(resourceAttributes.Condition);\n      if (!condition) {\n        throw new Error(`Resource '${logicalId}' uses Condition '${resourceAttributes.Condition}' that doesn't exist`);\n      }\n      cfnOptions.condition = condition;\n    }\n\n    // handle DependsOn\n    resourceAttributes.DependsOn = resourceAttributes.DependsOn ?? [];\n    const dependencies: string[] = Array.isArray(resourceAttributes.DependsOn) ?\n      resourceAttributes.DependsOn : [resourceAttributes.DependsOn];\n    for (const dep of dependencies) {\n      const depResource = this.finder.findResource(dep);\n      if (!depResource) {\n        throw new Error(`Resource '${logicalId}' depends on '${dep}' that doesn't exist`);\n      }\n      resource.node.addDependency(depResource);\n    }\n  }\n\n  private parseCreationPolicy(policy: any): CfnCreationPolicy | undefined {\n    if (typeof policy !== 'object') { return undefined; }\n\n    // change simple JS values to their CDK equivalents\n    policy = this.parseValue(policy);\n\n    return undefinedIfAllValuesAreEmpty({\n      autoScalingCreationPolicy: parseAutoScalingCreationPolicy(policy.AutoScalingCreationPolicy),\n      resourceSignal: parseResourceSignal(policy.ResourceSignal),\n    });\n\n    function parseAutoScalingCreationPolicy(p: any): CfnResourceAutoScalingCreationPolicy | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        minSuccessfulInstancesPercent: FromCloudFormation.getNumber(p.MinSuccessfulInstancesPercent).value,\n      });\n    }\n\n    function parseResourceSignal(p: any): CfnResourceSignal | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        count: FromCloudFormation.getNumber(p.Count).value,\n        timeout: FromCloudFormation.getString(p.Timeout).value,\n      });\n    }\n  }\n\n  private parseUpdatePolicy(policy: any): CfnUpdatePolicy | undefined {\n    if (typeof policy !== 'object') { return undefined; }\n\n    // change simple JS values to their CDK equivalents\n    policy = this.parseValue(policy);\n\n    return undefinedIfAllValuesAreEmpty({\n      autoScalingReplacingUpdate: parseAutoScalingReplacingUpdate(policy.AutoScalingReplacingUpdate),\n      autoScalingRollingUpdate: parseAutoScalingRollingUpdate(policy.AutoScalingRollingUpdate),\n      autoScalingScheduledAction: parseAutoScalingScheduledAction(policy.AutoScalingScheduledAction),\n      codeDeployLambdaAliasUpdate: parseCodeDeployLambdaAliasUpdate(policy.CodeDeployLambdaAliasUpdate),\n      enableVersionUpgrade: FromCloudFormation.getBoolean(policy.EnableVersionUpgrade).value,\n      useOnlineResharding: FromCloudFormation.getBoolean(policy.UseOnlineResharding).value,\n    });\n\n    function parseAutoScalingReplacingUpdate(p: any): CfnAutoScalingReplacingUpdate | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        willReplace: p.WillReplace,\n      });\n    }\n\n    function parseAutoScalingRollingUpdate(p: any): CfnAutoScalingRollingUpdate | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        maxBatchSize: FromCloudFormation.getNumber(p.MaxBatchSize).value,\n        minInstancesInService: FromCloudFormation.getNumber(p.MinInstancesInService).value,\n        minSuccessfulInstancesPercent: FromCloudFormation.getNumber(p.MinSuccessfulInstancesPercent).value,\n        pauseTime: FromCloudFormation.getString(p.PauseTime).value,\n        suspendProcesses: FromCloudFormation.getStringArray(p.SuspendProcesses).value,\n        waitOnResourceSignals: FromCloudFormation.getBoolean(p.WaitOnResourceSignals).value,\n      });\n    }\n\n    function parseCodeDeployLambdaAliasUpdate(p: any): CfnCodeDeployLambdaAliasUpdate | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return {\n        beforeAllowTrafficHook: FromCloudFormation.getString(p.BeforeAllowTrafficHook).value,\n        afterAllowTrafficHook: FromCloudFormation.getString(p.AfterAllowTrafficHook).value,\n        applicationName: FromCloudFormation.getString(p.ApplicationName).value,\n        deploymentGroupName: FromCloudFormation.getString(p.DeploymentGroupName).value,\n      };\n    }\n\n    function parseAutoScalingScheduledAction(p: any): CfnAutoScalingScheduledAction | undefined {\n      if (typeof p !== 'object') { return undefined; }\n\n      return undefinedIfAllValuesAreEmpty({\n        ignoreUnmodifiedGroupSizeProperties: FromCloudFormation.getBoolean(p.IgnoreUnmodifiedGroupSizeProperties).value,\n      });\n    }\n  }\n\n  private parseDeletionPolicy(policy: any): CfnDeletionPolicy | undefined {\n    switch (policy) {\n      case null: return undefined;\n      case undefined: return undefined;\n      case 'Delete': return CfnDeletionPolicy.DELETE;\n      case 'Retain': return CfnDeletionPolicy.RETAIN;\n      case 'Snapshot': return CfnDeletionPolicy.SNAPSHOT;\n      default: throw new Error(`Unrecognized DeletionPolicy '${policy}'`);\n    }\n  }\n\n  public parseValue(cfnValue: any): any {\n    // == null captures undefined as well\n    if (cfnValue == null) {\n      return undefined;\n    }\n    // if we have any late-bound values,\n    // just return them\n    if (isResolvableObject(cfnValue)) {\n      return cfnValue;\n    }\n    if (Array.isArray(cfnValue)) {\n      return cfnValue.map(el => this.parseValue(el));\n    }\n    if (typeof cfnValue === 'object') {\n      // an object can be either a CFN intrinsic, or an actual object\n      const cfnIntrinsic = this.parseIfCfnIntrinsic(cfnValue);\n      if (cfnIntrinsic !== undefined) {\n        return cfnIntrinsic;\n      }\n      const ret: any = {};\n      for (const [key, val] of Object.entries(cfnValue)) {\n        ret[key] = this.parseValue(val);\n      }\n      return ret;\n    }\n    // in all other cases, just return the input\n    return cfnValue;\n  }\n\n  public get finder(): ICfnFinder {\n    return this.options.finder;\n  }\n\n  private parseIfCfnIntrinsic(object: any): any {\n    const key = this.looksLikeCfnIntrinsic(object);\n    switch (key) {\n      case undefined:\n        return undefined;\n      case 'Ref': {\n        const refTarget = object[key];\n        const specialRef = this.specialCaseRefs(refTarget);\n        if (specialRef !== undefined) {\n          return specialRef;\n        } else {\n          const refElement = this.finder.findRefTarget(refTarget);\n          if (!refElement) {\n            throw new Error(`Element used in Ref expression with logical ID: '${refTarget}' not found`);\n          }\n          return CfnReference.for(refElement, 'Ref');\n        }\n      }\n      case 'Fn::GetAtt': {\n        const value = object[key];\n        let logicalId: string, attributeName: string, stringForm: boolean;\n        // Fn::GetAtt takes as arguments either a string...\n        if (typeof value === 'string') {\n          // ...in which case the logical ID and the attribute name are separated with '.'\n          const dotIndex = value.indexOf('.');\n          if (dotIndex === -1) {\n            throw new Error(`Short-form Fn::GetAtt must contain a '.' in its string argument, got: '${value}'`);\n          }\n          logicalId = value.substr(0, dotIndex);\n          attributeName = value.substr(dotIndex + 1); // the +1 is to skip the actual '.'\n          stringForm = true;\n        } else {\n          // ...or a 2-element list\n          logicalId = value[0];\n          attributeName = value[1];\n          stringForm = false;\n        }\n        const target = this.finder.findResource(logicalId);\n        if (!target) {\n          throw new Error(`Resource used in GetAtt expression with logical ID: '${logicalId}' not found`);\n        }\n        return CfnReference.for(target, attributeName, stringForm ? ReferenceRendering.GET_ATT_STRING : undefined);\n      }\n      case 'Fn::Join': {\n        // Fn::Join takes a 2-element list as its argument,\n        // where the first element is the delimiter,\n        // and the second is the list of elements to join\n        const value = this.parseValue(object[key]);\n        // wrap the array as a Token,\n        // as otherwise Fn.join() will try to concatenate\n        // the non-token parts,\n        // causing a diff with the original template\n        return Fn.join(value[0], Lazy.list({ produce: () => value[1] }));\n      }\n      case 'Fn::Cidr': {\n        const value = this.parseValue(object[key]);\n        return Fn.cidr(value[0], value[1], value[2]);\n      }\n      case 'Fn::FindInMap': {\n        const value = this.parseValue(object[key]);\n        // the first argument to FindInMap is the mapping name\n        let mappingName: string;\n        if (Token.isUnresolved(value[0])) {\n          // the first argument can be a dynamic expression like Ref: Param;\n          // if it is, we can't find the mapping in advance\n          mappingName = value[0];\n        } else {\n          const mapping = this.finder.findMapping(value[0]);\n          if (!mapping) {\n            throw new Error(`Mapping used in FindInMap expression with name '${value[0]}' was not found in the template`);\n          }\n          mappingName = mapping.logicalId;\n        }\n        return Fn._findInMap(mappingName, value[1], value[2]);\n      }\n      case 'Fn::Select': {\n        const value = this.parseValue(object[key]);\n        return Fn.select(value[0], value[1]);\n      }\n      case 'Fn::GetAZs': {\n        const value = this.parseValue(object[key]);\n        return Fn.getAzs(value);\n      }\n      case 'Fn::ImportValue': {\n        const value = this.parseValue(object[key]);\n        return Fn.importValue(value);\n      }\n      case 'Fn::Split': {\n        const value = this.parseValue(object[key]);\n        return Fn.split(value[0], value[1]);\n      }\n      case 'Fn::Transform': {\n        const value = this.parseValue(object[key]);\n        return Fn.transform(value.Name, value.Parameters);\n      }\n      case 'Fn::Base64': {\n        const value = this.parseValue(object[key]);\n        return Fn.base64(value);\n      }\n      case 'Fn::If': {\n        // Fn::If takes a 3-element list as its argument,\n        // where the first element is the name of a Condition\n        const value = this.parseValue(object[key]);\n        const condition = this.finder.findCondition(value[0]);\n        if (!condition) {\n          throw new Error(`Condition '${value[0]}' used in an Fn::If expression does not exist in the template`);\n        }\n        return Fn.conditionIf(condition.logicalId, value[1], value[2]);\n      }\n      case 'Fn::Equals': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionEquals(value[0], value[1]);\n      }\n      case 'Fn::And': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionAnd(...value);\n      }\n      case 'Fn::Not': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionNot(value[0]);\n      }\n      case 'Fn::Or': {\n        const value = this.parseValue(object[key]);\n        return Fn.conditionOr(...value);\n      }\n      case 'Fn::Sub': {\n        const value = this.parseValue(object[key]);\n        let fnSubString: string;\n        let map: { [key: string]: any } | undefined;\n        if (typeof value === 'string') {\n          fnSubString = value;\n          map = undefined;\n        } else {\n          fnSubString = value[0];\n          map = value[1];\n        }\n\n        return this.parseFnSubString(fnSubString, map);\n      }\n      case 'Condition': {\n        // a reference to a Condition from another Condition\n        const condition = this.finder.findCondition(object[key]);\n        if (!condition) {\n          throw new Error(`Referenced Condition with name '${object[key]}' was not found in the template`);\n        }\n        return { Condition: condition.logicalId };\n      }\n      default:\n        if (this.options.context === CfnParsingContext.RULES) {\n          return this.handleRulesIntrinsic(key, object);\n        } else {\n          throw new Error(`Unsupported CloudFormation function '${key}'`);\n        }\n    }\n  }\n\n  private looksLikeCfnIntrinsic(object: object): string | undefined {\n    const objectKeys = Object.keys(object);\n    // a CFN intrinsic is always an object with a single key\n    if (objectKeys.length !== 1) {\n      return undefined;\n    }\n\n    const key = objectKeys[0];\n    return key === 'Ref' || key.startsWith('Fn::') ||\n        // special intrinsic only available in the 'Conditions' section\n        (this.options.context === CfnParsingContext.CONDITIONS && key === 'Condition')\n      ? key\n      : undefined;\n  }\n\n  private parseFnSubString(templateString: string, expressionMap: { [key: string]: any } | undefined): string {\n    const map = expressionMap ?? {};\n    const self = this;\n    return Fn.sub(go(templateString), Object.keys(map).length === 0 ? expressionMap : map);\n\n    function go(value: string): string {\n      const leftBrace = value.indexOf('${');\n      if (leftBrace === -1) {\n        return value;\n      }\n      // search for the closing brace to the right of the opening '${'\n      // (in theory, there could be other braces in the string,\n      // for example if it represents a JSON object)\n      const rightBrace = value.indexOf('}', leftBrace);\n      if (rightBrace === -1) {\n        return value;\n      }\n\n      const leftHalf = value.substring(0, leftBrace);\n      const rightHalf = value.substring(rightBrace + 1);\n      // don't include left and right braces when searching for the target of the reference\n      const refTarget = value.substring(leftBrace + 2, rightBrace).trim();\n      if (refTarget[0] === '!') {\n        return value.substring(0, rightBrace + 1) + go(rightHalf);\n      }\n\n      // lookup in map\n      if (refTarget in map) {\n        return leftHalf + '${' + refTarget + '}' + go(rightHalf);\n      }\n\n      // since it's not in the map, check if it's a pseudo-parameter\n      // (or a value to be substituted for a Parameter, provided by the customer)\n      const specialRef = self.specialCaseSubRefs(refTarget);\n      if (specialRef !== undefined) {\n        if (Token.isUnresolved(specialRef)) {\n          // specialRef can only be a Token if the value passed by the customer\n          // for substituting a Parameter was a Token.\n          // This is actually bad here,\n          // because the Token can potentially be something that doesn't render\n          // well inside an Fn::Sub template string, like a { Ref } object.\n          // To handle this case,\n          // instead of substituting the Parameter directly with the token in the template string,\n          // add a new entry to the Fn::Sub map,\n          // with key refTarget, and the token as the value.\n          // This is safe, because this sort of shadowing is legal in CloudFormation,\n          // and also because we're certain the Fn::Sub map doesn't contain an entry for refTarget\n          // (as we check that condition in the code right above this).\n          map[refTarget] = specialRef;\n          return leftHalf + '${' + refTarget + '}' + go(rightHalf);\n        } else {\n          return leftHalf + specialRef + go(rightHalf);\n        }\n      }\n\n      const dotIndex = refTarget.indexOf('.');\n      const isRef = dotIndex === -1;\n      if (isRef) {\n        const refElement = self.finder.findRefTarget(refTarget);\n        if (!refElement) {\n          throw new Error(`Element referenced in Fn::Sub expression with logical ID: '${refTarget}' was not found in the template`);\n        }\n        return leftHalf + CfnReference.for(refElement, 'Ref', ReferenceRendering.FN_SUB).toString() + go(rightHalf);\n      } else {\n        const targetId = refTarget.substring(0, dotIndex);\n        const refResource = self.finder.findResource(targetId);\n        if (!refResource) {\n          throw new Error(`Resource referenced in Fn::Sub expression with logical ID: '${targetId}' was not found in the template`);\n        }\n        const attribute = refTarget.substring(dotIndex + 1);\n        return leftHalf + CfnReference.for(refResource, attribute, ReferenceRendering.FN_SUB).toString() + go(rightHalf);\n      }\n    }\n  }\n\n  private handleRulesIntrinsic(key: string, object: any): any {\n    // Rules have their own set of intrinsics:\n    // https://docs.aws.amazon.com/servicecatalog/latest/adminguide/intrinsic-function-reference-rules.html\n    switch (key) {\n      case 'Fn::ValueOf': {\n        // ValueOf is special,\n        // as it takes the name of a Parameter as its first argument\n        const value = this.parseValue(object[key]);\n        const parameterName = value[0];\n        if (parameterName in this.parameters) {\n          // since ValueOf returns the value of a specific attribute,\n          // fail here - this substitution is not allowed\n          throw new Error(`Cannot substitute parameter '${parameterName}' used in Fn::ValueOf expression with attribute '${value[1]}'`);\n        }\n        const param = this.finder.findRefTarget(parameterName);\n        if (!param) {\n          throw new Error(`Rule references parameter '${parameterName}' which was not found in the template`);\n        }\n        // create an explicit IResolvable,\n        // as Fn.valueOf() returns a string,\n        // which is incorrect\n        // (Fn::ValueOf can also return an array)\n        return Lazy.any({ produce: () => ({ 'Fn::ValueOf': [param.logicalId, value[1]] }) });\n      }\n      default:\n        // I don't want to hard-code the list of supported Rules-specific intrinsics in this function;\n        // so, just return undefined here,\n        // and they will be treated as a regular JSON object\n        return undefined;\n    }\n  }\n\n  private specialCaseRefs(value: any): any {\n    if (value in this.parameters) {\n      return this.parameters[value];\n    }\n    switch (value) {\n      case 'AWS::AccountId': return Aws.ACCOUNT_ID;\n      case 'AWS::Region': return Aws.REGION;\n      case 'AWS::Partition': return Aws.PARTITION;\n      case 'AWS::URLSuffix': return Aws.URL_SUFFIX;\n      case 'AWS::NotificationARNs': return Aws.NOTIFICATION_ARNS;\n      case 'AWS::StackId': return Aws.STACK_ID;\n      case 'AWS::StackName': return Aws.STACK_NAME;\n      case 'AWS::NoValue': return Aws.NO_VALUE;\n      default: return undefined;\n    }\n  }\n\n  private specialCaseSubRefs(value: string): string | undefined {\n    if (value in this.parameters) {\n      return this.parameters[value];\n    }\n    return value.indexOf('::') === -1 ? undefined: '${' + value + '}';\n  }\n\n  private get parameters(): { [parameterName: string]: any } {\n    return this.options.parameters || {};\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
