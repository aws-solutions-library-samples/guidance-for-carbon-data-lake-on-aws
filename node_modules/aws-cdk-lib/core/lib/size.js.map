{
  "version": 3,
  "sources": ["size.ts"],
  "sourcesContent": ["import { Token } from './token';\n\n/**\n * Represents the amount of digital storage.\n *\n * The amount can be specified either as a literal value (e.g: `10`) which\n * cannot be negative, or as an unresolved number token.\n *\n * When the amount is passed as a token, unit conversion is not possible.\n */\nexport class Size {\n  /**\n   * Create a Storage representing an amount kibibytes.\n   * 1 KiB = 1024 bytes\n   *\n   * @param amount the amount of kibibytes to be represented\n   *\n   * @returns a new `Size` instance\n   */\n  public static kibibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Kibibytes);\n  }\n\n  /**\n   * Create a Storage representing an amount mebibytes.\n   * 1 MiB = 1024 KiB\n   *\n   * @param amount the amount of mebibytes to be represented\n   *\n   * @returns a new `Size` instance\n   */\n  public static mebibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Mebibytes);\n  }\n\n  /**\n   * Create a Storage representing an amount gibibytes.\n   * 1 GiB = 1024 MiB\n   *\n   * @param amount the amount of gibibytes to be represented\n   *\n   * @returns a new `Size` instance\n   */\n  public static gibibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Gibibytes);\n  }\n\n  /**\n   * Create a Storage representing an amount tebibytes.\n   * 1 TiB = 1024 GiB\n   *\n   * @param amount the amount of tebibytes to be represented\n   *\n   * @returns a new `Size` instance\n   */\n  public static tebibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Tebibytes);\n  }\n\n  /**\n   * Create a Storage representing an amount pebibytes.\n   * 1 PiB = 1024 TiB\n   *\n   * @deprecated use `pebibytes` instead\n   */\n  public static pebibyte(amount: number): Size {\n    return Size.pebibytes(amount);\n  }\n\n  /**\n   * Create a Storage representing an amount pebibytes.\n   * 1 PiB = 1024 TiB\n   *\n   * @param amount the amount of pebibytes to be represented\n   *\n   * @returns a new `Size` instance\n   */\n  public static pebibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Pebibytes);\n  }\n\n  private readonly amount: number;\n  private readonly unit: StorageUnit;\n\n  private constructor(amount: number, unit: StorageUnit) {\n    if (!Token.isUnresolved(amount) && amount < 0) {\n      throw new Error(`Storage amounts cannot be negative. Received: ${amount}`);\n    }\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  /**\n   * Return this storage as a total number of kibibytes.\n   *\n   * @param opts the conversion options\n   *\n   * @returns the quantity of bytes expressed in kibibytes\n   */\n  public toKibibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Kibibytes, opts);\n  }\n\n  /**\n   * Return this storage as a total number of mebibytes.\n   *\n   * @param opts the conversion options\n   *\n   * @returns the quantity of bytes expressed in mebibytes\n   */\n  public toMebibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Mebibytes, opts);\n  }\n\n  /**\n   * Return this storage as a total number of gibibytes.\n   *\n   * @param opts the conversion options\n   *\n   * @returns the quantity of bytes expressed in gibibytes\n   */\n  public toGibibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Gibibytes, opts);\n  }\n\n  /**\n   * Return this storage as a total number of tebibytes.\n   *\n   * @param opts the conversion options\n   *\n   * @returns the quantity of bytes expressed in tebibytes\n   */\n  public toTebibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Tebibytes, opts);\n  }\n\n  /**\n   * Return this storage as a total number of pebibytes.\n   *\n   * @param opts the conversion options\n   *\n   * @returns the quantity of bytes expressed in pebibytes\n   */\n  public toPebibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Pebibytes, opts);\n  }\n}\n\n/**\n * Rounding behaviour when converting between units of `Size`.\n */\nexport enum SizeRoundingBehavior {\n  /** Fail the conversion if the result is not an integer. */\n  FAIL,\n  /** If the result is not an integer, round it to the closest integer less than the result */\n  FLOOR,\n  /** Don't round. Return even if the result is a fraction. */\n  NONE,\n}\n\n/**\n * Options for how to convert time to a different unit.\n */\nexport interface SizeConversionOptions {\n  /**\n   * How conversions should behave when it encounters a non-integer result\n   * @default SizeRoundingBehavior.FAIL\n   */\n  readonly rounding?: SizeRoundingBehavior;\n}\n\nclass StorageUnit {\n  public static readonly Kibibytes = new StorageUnit('kibibytes', 1);\n  public static readonly Mebibytes = new StorageUnit('mebibytes', 1024);\n  public static readonly Gibibytes = new StorageUnit('gibibytes', 1024 * 1024);\n  public static readonly Tebibytes = new StorageUnit('tebibytes', 1024 * 1024 * 1024);\n  public static readonly Pebibytes = new StorageUnit('pebibytes', 1024 * 1024 * 1024 * 1024);\n\n  private constructor(public readonly label: string, public readonly inKibiBytes: number) {\n    // MAX_SAFE_INTEGER is 2^53, so by representing storage in kibibytes,\n    // the highest storage we can represent is 8 exbibytes.\n  }\n\n  public toString() {\n    return this.label;\n  }\n}\n\nfunction convert(amount: number, fromUnit: StorageUnit, toUnit: StorageUnit, options: SizeConversionOptions = {}) {\n  const rounding = options.rounding ?? SizeRoundingBehavior.FAIL;\n  if (fromUnit.inKibiBytes === toUnit.inKibiBytes) { return amount; }\n  if (Token.isUnresolved(amount)) {\n    throw new Error(`Unable to perform time unit conversion on un-resolved token ${amount}.`);\n  }\n\n  const multiplier = fromUnit.inKibiBytes / toUnit.inKibiBytes;\n  const value = amount * multiplier;\n  switch (rounding) {\n    case SizeRoundingBehavior.NONE:\n      return value;\n    case SizeRoundingBehavior.FLOOR:\n      return Math.floor(value);\n    default:\n    case SizeRoundingBehavior.FAIL:\n      if (!Number.isInteger(value)) {\n        throw new Error(`'${amount} ${fromUnit}' cannot be converted into a whole number of ${toUnit}.`);\n      }\n      return value;\n  }\n}\n"],
  "mappings": "wOAAA,QAAA,QAAA,WAUA,UAAiB,CA0Ef,YAAoB,OAAgB,KAAiB,CACnD,GAAI,CAAC,QAAA,MAAM,aAAa,SAAW,OAAS,EAC1C,KAAM,IAAI,OAAM,iDAAiD,UAEnE,KAAK,OAAS,OACd,KAAK,KAAO,WAtEA,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAWxB,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAWxB,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAWxB,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBASxB,UAAS,OAAc,CACnC,MAAO,MAAK,UAAU,cAWV,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,WAqB/B,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAUzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAUzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAUzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAUzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,OAtIlE,QAAA,KAAA,8EA6IA,GAAY,sBAAZ,AAAA,UAAY,sBAAoB,CAE9B,sBAAA,sBAAA,KAAA,GAAA,OAEA,sBAAA,sBAAA,MAAA,GAAA,QAEA,sBAAA,sBAAA,KAAA,GAAA,SANU,qBAAA,QAAA,sBAAA,SAAA,qBAAoB,KAoBhC,iBAAiB,CAOf,YAAoC,MAA+B,YAAmB,CAAlD,KAAA,MAAA,MAA+B,KAAA,YAAA,YAK5D,UAAQ,CACb,MAAO,MAAK,OAZS,YAAA,UAAY,GAAI,aAAY,YAAa,GACzC,YAAA,UAAY,GAAI,aAAY,YAAa,MACzC,YAAA,UAAY,GAAI,aAAY,YAAa,KAAO,MAChD,YAAA,UAAY,GAAI,aAAY,YAAa,KAAO,KAAO,MACvD,YAAA,UAAY,GAAI,aAAY,YAAa,KAAO,KAAO,KAAO,MAYvF,iBAAiB,OAAgB,SAAuB,OAAqB,QAAiC,GAAE,QAC9G,KAAM,UAAQ,IAAG,QAAQ,YAAQ,MAAA,KAAA,OAAA,GAAI,qBAAqB,KAC1D,GAAI,SAAS,cAAgB,OAAO,YAAe,MAAO,QAC1D,GAAI,QAAA,MAAM,aAAa,QACrB,KAAM,IAAI,OAAM,+DAA+D,WAGjF,KAAM,YAAa,SAAS,YAAc,OAAO,YAC3C,MAAQ,OAAS,WACvB,OAAQ,cACD,sBAAqB,KACxB,MAAO,WACJ,sBAAqB,MACxB,MAAO,MAAK,MAAM,mBAEf,sBAAqB,KACxB,GAAI,CAAC,OAAO,UAAU,OACpB,KAAM,IAAI,OAAM,IAAI,UAAU,wDAAwD,WAExF,MAAO",
  "names": []
}
