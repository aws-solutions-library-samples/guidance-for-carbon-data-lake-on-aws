{
  "version": 3,
  "sources": ["resolvable.ts"],
  "sourcesContent": ["import { IConstruct } from 'constructs';\nimport { TokenString } from './private/encoding';\nimport { TokenMap } from './private/token-map';\nimport { TokenizedStringFragments } from './string-fragments';\n\n/**\n * Current resolution context for tokens\n */\nexport interface IResolveContext {\n  /**\n   * The scope from which resolution has been initiated\n   */\n  readonly scope: IConstruct;\n\n  /**\n   * True when we are still preparing, false if we're rendering the final output\n   */\n  readonly preparing: boolean;\n\n  /**\n   * Resolve an inner object\n   */\n  resolve(x: any, options?: ResolveChangeContextOptions): any;\n\n  /**\n   * Use this postprocessor after the entire token structure has been resolved\n   */\n  registerPostProcessor(postProcessor: IPostProcessor): void;\n}\n\n/**\n * Options that can be changed while doing a recursive resolve\n */\nexport interface ResolveChangeContextOptions {\n  /**\n   * Change the 'allowIntrinsicKeys' option\n   *\n   * @default - Unchanged\n   */\n  readonly allowIntrinsicKeys?: boolean;\n}\n\n/**\n * Interface for values that can be resolvable later\n *\n * Tokens are special objects that participate in synthesis.\n */\nexport interface IResolvable {\n  /**\n   * The creation stack of this resolvable which will be appended to errors\n   * thrown during resolution.\n   *\n   * This may return an array with a single informational element indicating how\n   * to get this property populated, if it was skipped for performance reasons.\n   */\n  readonly creationStack: string[];\n\n  /**\n   * Produce the Token's value at resolution time\n   */\n  resolve(context: IResolveContext): any;\n\n  /**\n   * Return a string representation of this resolvable object.\n   *\n   * Returns a reversible string representation.\n   */\n  toString(): string;\n}\n\n/**\n * A Token that can post-process the complete resolved value, after resolve() has recursed over it\n */\nexport interface IPostProcessor {\n  /**\n   * Process the completely resolved value, after full recursion/resolution has happened\n   */\n  postProcess(input: any, context: IResolveContext): any;\n}\n\n/**\n * How to resolve tokens\n */\nexport interface ITokenResolver {\n  /**\n   * Resolve a single token\n   */\n  resolveToken(t: IResolvable, context: IResolveContext, postProcessor: IPostProcessor): any;\n\n  /**\n   * Resolve a string with at least one stringified token in it\n   *\n   * (May use concatenation)\n   */\n  resolveString(s: TokenizedStringFragments, context: IResolveContext): any;\n\n  /**\n   * Resolve a tokenized list\n   */\n  resolveList(l: string[], context: IResolveContext): any;\n}\n\n/**\n * Function used to concatenate symbols in the target document language\n *\n * Interface so it could potentially be exposed over jsii.\n *\n */\nexport interface IFragmentConcatenator {\n  /**\n   * Join the fragment on the left and on the right\n   */\n  join(left: any | undefined, right: any | undefined): any;\n}\n\n/**\n * Converts all fragments to strings and concats those\n *\n * Drops 'undefined's.\n */\nexport class StringConcat implements IFragmentConcatenator {\n  public join(left: any | undefined, right: any | undefined): any {\n    if (left === undefined) { return right !== undefined ? `${right}` : undefined; }\n    if (right === undefined) { return `${left}`; }\n    return `${left}${right}`;\n  }\n}\n\n/**\n * Default resolver implementation\n *\n */\nexport class DefaultTokenResolver implements ITokenResolver {\n  constructor(private readonly concat: IFragmentConcatenator) {\n  }\n\n  /**\n   * Default Token resolution\n   *\n   * Resolve the Token, recurse into whatever it returns,\n   * then finally post-process it.\n   */\n  public resolveToken(t: IResolvable, context: IResolveContext, postProcessor: IPostProcessor) {\n    try {\n      let resolved = t.resolve(context);\n\n      // The token might have returned more values that need resolving, recurse\n      resolved = context.resolve(resolved);\n      resolved = postProcessor.postProcess(resolved, context);\n      return resolved;\n    } catch (e) {\n      let message = `Resolution error: ${e.message}.`;\n      if (t.creationStack && t.creationStack.length > 0) {\n        message += `\\nObject creation stack:\\n  at ${t.creationStack.join('\\n  at ')}`;\n      }\n\n      e.message = message;\n      throw e;\n    }\n  }\n\n  /**\n   * Resolve string fragments to Tokens\n   */\n  public resolveString(fragments: TokenizedStringFragments, context: IResolveContext) {\n    return fragments.mapTokens({ mapToken: context.resolve }).join(this.concat);\n  }\n\n  public resolveList(xs: string[], context: IResolveContext) {\n    // Must be a singleton list token, because concatenation is not allowed.\n    if (xs.length !== 1) {\n      throw new Error(`Cannot add elements to list token, got: ${xs}`);\n    }\n\n    const str = TokenString.forListToken(xs[0]);\n    const tokenMap = TokenMap.instance();\n    const fragments = str.split(tokenMap.lookupToken.bind(tokenMap));\n    if (fragments.length !== 1) {\n      throw new Error(`Cannot concatenate strings in a tokenized string array, got: ${xs[0]}`);\n    }\n\n    return fragments.mapTokens({ mapToken: context.resolve }).firstValue;\n  }\n}\n"],
  "mappings": "mPACA,WAAA,QAAA,sBACA,YAAA,QAAA,uBAsHA,kBAAyB,CAChB,KAAK,KAAuB,MAAsB,CACvD,MAAI,QAAS,OAAoB,QAAU,OAAY,GAAG,QAAU,OAChE,QAAU,OAAoB,GAAG,OAC9B,GAAG,OAAO,SAJrB,QAAA,aAAA,sGAYA,0BAAiC,CAC/B,YAA6B,OAA6B,CAA7B,KAAA,OAAA,yEAStB,aAAa,EAAgB,QAA0B,cAA6B,mLACzF,GAAI,CACF,GAAI,UAAW,EAAE,QAAQ,SAGzB,gBAAW,QAAQ,QAAQ,UAC3B,SAAW,cAAc,YAAY,SAAU,SACxC,eACA,EAAP,CACA,GAAI,SAAU,qBAAqB,EAAE,WACrC,KAAI,GAAE,eAAiB,EAAE,cAAc,OAAS,GAC9C,UAAW;;OAAkC,EAAE,cAAc,KAAK;WAGpE,EAAE,QAAU,QACN,GAOH,cAAc,UAAqC,QAAwB,6IACzE,UAAU,UAAU,CAAE,SAAU,QAAQ,UAAW,KAAK,KAAK,QAG/D,YAAY,GAAc,QAAwB,CAEvD,gEAAI,GAAG,SAAW,EAChB,KAAM,IAAI,OAAM,2CAA2C,MAG7D,KAAM,KAAM,WAAA,YAAY,aAAa,GAAG,IAClC,SAAW,YAAA,SAAS,WACpB,UAAY,IAAI,MAAM,SAAS,YAAY,KAAK,WACtD,GAAI,UAAU,SAAW,EACvB,KAAM,IAAI,OAAM,gEAAgE,GAAG,MAGrF,MAAO,WAAU,UAAU,CAAE,SAAU,QAAQ,UAAW,YAjD9D,QAAA,qBAAA",
  "names": []
}
