{
  "version": 3,
  "sources": ["token.ts"],
  "sourcesContent": ["import { IConstruct } from 'constructs';\nimport { Lazy } from './lazy';\nimport { unresolved } from './private/encoding';\nimport { Intrinsic } from './private/intrinsic';\nimport { resolve } from './private/resolve';\nimport { TokenMap } from './private/token-map';\nimport { IResolvable, ITokenResolver } from './resolvable';\nimport { TokenizedStringFragments } from './string-fragments';\n\n/**\n * An enum-like class that represents the result of comparing two Tokens.\n * The return type of {@link Token.compareStrings}.\n */\nexport class TokenComparison {\n  /**\n   * This means we're certain the two components are NOT\n   * Tokens, and identical.\n   */\n  public static readonly SAME = new TokenComparison();\n\n  /**\n   * This means we're certain the two components are NOT\n   * Tokens, and different.\n   */\n  public static readonly DIFFERENT = new TokenComparison();\n\n  /** This means exactly one of the components is a Token. */\n  public static readonly ONE_UNRESOLVED = new TokenComparison();\n\n  /** This means both components are Tokens. */\n  public static readonly BOTH_UNRESOLVED = new TokenComparison();\n\n  private constructor() {\n  }\n}\n\n/**\n * Represents a special or lazily-evaluated value.\n *\n * Can be used to delay evaluation of a certain value in case, for example,\n * that it requires some context or late-bound data. Can also be used to\n * mark values that need special processing at document rendering time.\n *\n * Tokens can be embedded into strings while retaining their original\n * semantics.\n */\nexport class Token {\n  /**\n   * Returns true if obj represents an unresolved value\n   *\n   * One of these must be true:\n   *\n   * - `obj` is an IResolvable\n   * - `obj` is a string containing at least one encoded `IResolvable`\n   * - `obj` is either an encoded number or list\n   *\n   * This does NOT recurse into lists or objects to see if they\n   * containing resolvables.\n   *\n   * @param obj The object to test.\n   */\n  public static isUnresolved(obj: any): boolean {\n    return unresolved(obj);\n  }\n\n  /**\n   * Return a reversible string representation of this token\n   *\n   * If the Token is initialized with a literal, the stringified value of the\n   * literal is returned. Otherwise, a special quoted string representation\n   * of the Token is returned that can be embedded into other strings.\n   *\n   * Strings with quoted Tokens in them can be restored back into\n   * complex values with the Tokens restored by calling `resolve()`\n   * on the string.\n   */\n  public static asString(value: any, options: EncodingOptions = {}): string {\n    if (typeof value === 'string') { return value; }\n    return TokenMap.instance().registerString(Token.asAny(value), options.displayHint);\n  }\n\n  /**\n   * Return a reversible number representation of this token\n   */\n  public static asNumber(value: any): number {\n    if (typeof value === 'number') { return value; }\n    return TokenMap.instance().registerNumber(Token.asAny(value));\n  }\n\n  /**\n   * Return a reversible list representation of this token\n   */\n  public static asList(value: any, options: EncodingOptions = {}): string[] {\n    if (Array.isArray(value) && value.every(x => typeof x === 'string')) { return value; }\n    return TokenMap.instance().registerList(Token.asAny(value), options.displayHint);\n  }\n\n  /**\n   * Return a resolvable representation of the given value\n   */\n  public static asAny(value: any): IResolvable {\n    return isResolvableObject(value) ? value : new Intrinsic(value);\n  }\n\n  /** Compare two strings that might contain Tokens with each other. */\n  public static compareStrings(possibleToken1: string, possibleToken2: string): TokenComparison {\n    const firstIsUnresolved = Token.isUnresolved(possibleToken1);\n    const secondIsUnresolved = Token.isUnresolved(possibleToken2);\n\n    if (firstIsUnresolved && secondIsUnresolved) {\n      return TokenComparison.BOTH_UNRESOLVED;\n    }\n    if (firstIsUnresolved || secondIsUnresolved) {\n      return TokenComparison.ONE_UNRESOLVED;\n    }\n\n    return possibleToken1 === possibleToken2 ? TokenComparison.SAME : TokenComparison.DIFFERENT;\n  }\n\n  private constructor() {\n  }\n}\n\n/**\n * Less oft-needed functions to manipulate Tokens\n */\nexport class Tokenization {\n  /**\n   * Un-encode a string potentially containing encoded tokens\n   */\n  public static reverseString(s: string): TokenizedStringFragments {\n    return TokenMap.instance().splitString(s);\n  }\n\n  /**\n   * Un-encode a string which is either a complete encoded token, or doesn't contain tokens at all\n   *\n   * It's illegal for the string to be a concatenation of an encoded token and something else.\n   */\n  public static reverseCompleteString(s: string): IResolvable | undefined {\n    const fragments = Tokenization.reverseString(s);\n    if (fragments.length !== 1) {\n      throw new Error(`Tokenzation.reverseCompleteString: argument must not be a concatentation, got '${s}'`);\n    }\n    return fragments.firstToken;\n  }\n\n  /**\n   * Un-encode a Tokenized value from a number\n   */\n  public static reverseNumber(n: number): IResolvable | undefined {\n    return TokenMap.instance().lookupNumberToken(n);\n  }\n\n  /**\n   * Un-encode a Tokenized value from a list\n   */\n  public static reverseList(l: string[]): IResolvable | undefined {\n    return TokenMap.instance().lookupList(l);\n  }\n\n  /**\n   * Reverse any value into a Resolvable, if possible\n   *\n   * In case of a string, the string must not be a concatenation.\n   */\n  public static reverse(x: any, options: ReverseOptions = {}): IResolvable | undefined {\n    if (Tokenization.isResolvable(x)) { return x; }\n    if (typeof x === 'string') {\n      if (options.failConcat === false) {\n        // Handle this specially because reverseCompleteString might fail\n        const fragments = Tokenization.reverseString(x);\n        return fragments.length === 1 ? fragments.firstToken : undefined;\n      }\n      return Tokenization.reverseCompleteString(x);\n    }\n    if (Array.isArray(x)) { return Tokenization.reverseList(x); }\n    if (typeof x === 'number') { return Tokenization.reverseNumber(x); }\n    return undefined;\n  }\n\n  /**\n   * Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.\n   * Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.\n   *\n   * @param obj The object to resolve.\n   * @param options Prefix key path components for diagnostics.\n   */\n  public static resolve(obj: any, options: ResolveOptions): any {\n    return resolve(obj, {\n      scope: options.scope,\n      resolver: options.resolver,\n      preparing: (options.preparing ?? false),\n      removeEmpty: options.removeEmpty,\n    });\n  }\n\n  /**\n   * Return whether the given object is an IResolvable object\n   *\n   * This is different from Token.isUnresolved() which will also check for\n   * encoded Tokens, whereas this method will only do a type check on the given\n   * object.\n   */\n  public static isResolvable(obj: any): obj is IResolvable {\n    return isResolvableObject(obj);\n  }\n\n  /**\n   * Stringify a number directly or lazily if it's a Token. If it is an object (i.e., { Ref: 'SomeLogicalId' }), return it as-is.\n   */\n  public static stringifyNumber(x: number) {\n    // only convert numbers to strings so that Refs, conditions, and other things don't end up synthesizing as [object object]\n\n    if (Token.isUnresolved(x)) {\n      return Lazy.uncachedString({\n        produce: context => {\n          const resolved = context.resolve(x);\n          return typeof resolved !== 'number' ? resolved : `${resolved}`;\n        },\n      });\n    } else {\n      return typeof x !== 'number' ? x : `${x}`;\n    }\n  }\n\n  private constructor() {\n  }\n}\n\n/**\n * Options for the 'reverse()' operation\n */\nexport interface ReverseOptions {\n  /**\n   * Fail if the given string is a concatenation\n   *\n   * If `false`, just return `undefined`.\n   *\n   * @default true\n   */\n  readonly failConcat?: boolean;\n}\n\n/**\n * Options to the resolve() operation\n *\n * NOT the same as the ResolveContext; ResolveContext is exposed to Token\n * implementors and resolution hooks, whereas this struct is just to bundle\n * a number of things that would otherwise be arguments to resolve() in a\n * readable way.\n */\nexport interface ResolveOptions {\n  /**\n   * The scope from which resolution is performed\n   */\n  readonly scope: IConstruct;\n\n  /**\n   * The resolver to apply to any resolvable tokens found\n   */\n  readonly resolver: ITokenResolver;\n\n  /**\n   * Whether the resolution is being executed during the prepare phase or not.\n   * @default false\n   */\n  readonly preparing?: boolean;\n\n  /**\n   * Whether to remove undefined elements from arrays and objects when resolving.\n   *\n   * @default true\n   */\n  readonly removeEmpty?: boolean;\n}\n\n/**\n * Properties to string encodings\n */\nexport interface EncodingOptions {\n  /**\n   * A hint for the Token's purpose when stringifying it\n   */\n  readonly displayHint?: string;\n}\n\nexport function isResolvableObject(x: any): x is IResolvable {\n  return typeof(x) === 'object' && x !== null && typeof x.resolve === 'function';\n}\n\n/**\n * Call the given function only if all given values are resolved\n *\n * Exported as a function since it will be used by TypeScript modules, but\n * can't be exposed via JSII because of the generics.\n */\nexport function withResolved<A>(a: A, fn: (a: A) => void): void;\nexport function withResolved<A, B>(a: A, b: B, fn: (a: A, b: B) => void): void;\nexport function withResolved<A, B, C>(a: A, b: B, c: C, fn: (a: A, b: B, c: C) => void): void;\nexport function withResolved(...args: any[]) {\n  if (args.length < 2) { return; }\n  const argArray = args.slice(0, args.length - 1);\n  if (argArray.some(Token.isUnresolved)) { return; }\n  args[args.length - 1].apply(arguments, argArray);\n}\n"],
  "mappings": "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",
  "names": []
}
