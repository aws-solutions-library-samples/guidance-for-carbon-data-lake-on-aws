{
  "version": 3,
  "sources": ["intrinsic.ts"],
  "sourcesContent": ["import { IResolvable, IResolveContext } from '../resolvable';\nimport { captureStackTrace } from '../stack-trace';\nimport { Token } from '../token';\n\n/**\n * Customization properties for an Intrinsic token\n *\n */\nexport interface IntrinsicProps {\n  /**\n   * Capture the stack trace of where this token is created\n   *\n   * @default true\n   */\n  readonly stackTrace?: boolean;\n}\n\n/**\n * Token subclass that represents values intrinsic to the target document language\n *\n * WARNING: this class should not be externally exposed, but is currently visible\n * because of a limitation of jsii (https://github.com/aws/jsii/issues/524).\n *\n * This class will disappear in a future release and should not be used.\n *\n */\nexport class Intrinsic implements IResolvable {\n  /**\n   * The captured stack trace which represents the location in which this token was created.\n   */\n  public readonly creationStack: string[];\n\n  private readonly value: any;\n\n  constructor(value: any, options: IntrinsicProps = {}) {\n    if (isFunction(value)) {\n      throw new Error(`Argument to Intrinsic must be a plain value object, got ${value}`);\n    }\n\n    this.creationStack = options.stackTrace ?? true ? captureStackTrace() : [];\n    this.value = value;\n  }\n\n  public resolve(_context: IResolveContext) {\n    return this.value;\n  }\n\n  /**\n   * Convert an instance of this Token to a string\n   *\n   * This method will be called implicitly by language runtimes if the object\n   * is embedded into a string. We treat it the same as an explicit\n   * stringification.\n   */\n  public toString(): string {\n    return Token.asString(this);\n  }\n\n  /**\n   * Turn this Token into JSON\n   *\n   * Called automatically when JSON.stringify() is called on a Token.\n   */\n  public toJSON(): any {\n    // We can't do the right work here because in case we contain a function, we\n    // won't know the type of value that function represents (in the simplest\n    // case, string or number), and we can't know that without an\n    // IResolveContext to actually do the resolution, which we don't have.\n\n    // We used to throw an error, but since JSON.stringify() is often used in\n    // error messages to produce a readable representation of an object, if we\n    // throw here we'll obfuscate that descriptive error with something worse.\n    // So return a string representation that indicates this thing is a token\n    // and needs resolving.\n    return '<unresolved-token>';\n  }\n\n  /**\n   * Creates a throwable Error object that contains the token creation stack trace.\n   * @param message Error message\n   */\n  protected newError(message: string): any {\n    return new Error(`${message}\\nToken created:\\n    at ${this.creationStack.join('\\n    at ')}\\nError thrown:`);\n  }\n}\n\nfunction isFunction(x: any) {\n  return typeof x === 'function';\n}\n"],
  "mappings": "mNACA,cAAA,QAAA,kBACA,QAAA,QAAA,YAwBA,eAAsB,CAQpB,YAAY,MAAY,QAA0B,GAAE,QAClD,+DAAI,WAAW,OACb,KAAM,IAAI,OAAM,2DAA2D,SAG7E,KAAK,cAAgB,KAAA,QAAQ,cAAU,MAAA,KAAA,OAAA,GAAI,IAAO,cAAA,oBAAsB,GACxE,KAAK,MAAQ,MAGR,QAAQ,SAAyB,sEAC/B,KAAK,MAUP,UAAQ,CACb,MAAO,SAAA,MAAM,SAAS,MAQjB,QAAM,CAWX,MAAO,qBAOC,SAAS,QAAe,CAChC,MAAO,IAAI,OAAM,GAAG;;SAAmC,KAAK,cAAc,KAAK;;iBAxDnF,QAAA,UAAA,6FA4DA,oBAAoB,EAAM,CACxB,MAAO,OAAO,IAAM",
  "names": []
}
