{
  "version": 3,
  "sources": ["token-map.ts"],
  "sourcesContent": ["import { IResolvable } from '../resolvable';\nimport { TokenizedStringFragments } from '../string-fragments';\nimport { isResolvableObject, Token } from '../token';\nimport {\n  BEGIN_LIST_TOKEN_MARKER, BEGIN_STRING_TOKEN_MARKER, createTokenDouble,\n  END_TOKEN_MARKER, extractTokenDouble, TokenString, VALID_KEY_CHARS,\n} from './encoding';\n\nconst glob = global as any;\n\nconst STRING_SYMBOL = Symbol.for('@aws-cdk/core.TokenMap.STRING');\nconst LIST_SYMBOL = Symbol.for('@aws-cdk/core.TokenMap.LIST');\nconst NUMBER_SYMBOL = Symbol.for('@aws-cdk/core.TokenMap.NUMBER');\n\n/**\n * Central place where we keep a mapping from Tokens to their String representation\n *\n * The string representation is used to embed token into strings,\n * and stored to be able to reverse that mapping.\n *\n * All instances of TokenStringMap share the same storage, so that this process\n * works even when different copies of the library are loaded.\n */\nexport class TokenMap {\n  /**\n   * Singleton instance of the token string map\n   */\n  public static instance(): TokenMap {\n    if (!glob.__cdkTokenMap) {\n      glob.__cdkTokenMap = new TokenMap();\n    }\n    return glob.__cdkTokenMap;\n  }\n\n  private readonly stringTokenMap = new Map<string, IResolvable>();\n  private readonly numberTokenMap = new Map<number, IResolvable>();\n\n  /**\n   * Counter to assign unique IDs to tokens\n   *\n   * Start at a random number to prevent people from accidentally taking\n   * dependencies on token values between runs.\n   *\n   * This is most prominent in tests, where people will write:\n   *\n   * ```ts\n   * sha256(JSON.stringify({ ...some structure that can contain tokens ... }))\n   * ```\n   *\n   * This should have been:\n   *\n   * ```ts\n   * sha256(JSON.stringify(stack.resolve({ ...some structure that can contain tokens ... })))\n   * ```\n   *\n   * The hash value is hard to inspect for correctness. It will LOOK consistent\n   * during testing, but will break as soon as someone stringifies another\n   * token before the run.\n   *\n   * By changing the starting number for tokens, we ensure that the hash is almost\n   * guaranteed to be different during a few test runs, so the hashing of unresolved\n   * tokens can be detected.\n   */\n  private tokenCounter = Math.floor(Math.random() * 10);\n\n  /**\n   * Generate a unique string for this Token, returning a key\n   *\n   * Every call for the same Token will produce a new unique string, no\n   * attempt is made to deduplicate. Token objects should cache the\n   * value themselves, if required.\n   *\n   * The token can choose (part of) its own representation string with a\n   * hint. This may be used to produce aesthetically pleasing and\n   * recognizable token representations for humans.\n   */\n  public registerString(token: IResolvable, displayHint?: string): string {\n    return cachedValue(token, STRING_SYMBOL, () => {\n      const key = this.registerStringKey(token, displayHint);\n      return `${BEGIN_STRING_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`;\n    });\n  }\n\n  /**\n   * Generate a unique string for this Token, returning a key\n   */\n  public registerList(token: IResolvable, displayHint?: string): string[] {\n    return cachedValue(token, LIST_SYMBOL, () => {\n      const key = this.registerStringKey(token, displayHint);\n      return [`${BEGIN_LIST_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`];\n    });\n  }\n\n  /**\n   * Create a unique number representation for this Token and return it\n   */\n  public registerNumber(token: IResolvable): number {\n    return cachedValue(token, NUMBER_SYMBOL, () => {\n      return this.registerNumberKey(token);\n    });\n  }\n\n  /**\n   * Lookup a token from an encoded value\n   */\n  public tokenFromEncoding(x: any): IResolvable | undefined {\n    if (isResolvableObject(x)) { return x; }\n    if (typeof x === 'string') { return this.lookupString(x); }\n    if (Array.isArray(x)) { return this.lookupList(x); }\n    if (Token.isUnresolved(x)) { return x; }\n    return undefined;\n  }\n\n  /**\n   * Reverse a string representation into a Token object\n   */\n  public lookupString(s: string): IResolvable | undefined {\n    const fragments = this.splitString(s);\n    if (fragments.tokens.length > 0 && fragments.length === 1) {\n      return fragments.firstToken;\n    }\n    return undefined;\n  }\n\n  /**\n   * Reverse a string representation into a Token object\n   */\n  public lookupList(xs: string[]): IResolvable | undefined {\n    if (xs.length !== 1) { return undefined; }\n    const str = TokenString.forListToken(xs[0]);\n    const fragments = str.split(this.lookupToken.bind(this));\n    if (fragments.length === 1) {\n      return fragments.firstToken;\n    }\n    return undefined;\n  }\n\n  /**\n   * Split a string into literals and Tokens\n   */\n  public splitString(s: string): TokenizedStringFragments {\n    const str = TokenString.forString(s);\n    return str.split(this.lookupToken.bind(this));\n  }\n\n  /**\n   * Reverse a number encoding into a Token, or undefined if the number wasn't a Token\n   */\n  public lookupNumberToken(x: number): IResolvable | undefined {\n    const tokenIndex = extractTokenDouble(x);\n    if (tokenIndex === undefined) { return undefined; }\n    const t = this.numberTokenMap.get(tokenIndex);\n    if (t === undefined) { throw new Error('Encoded representation of unknown number Token found'); }\n    return t;\n  }\n\n  /**\n   * Find a Token by key.\n   *\n   * This excludes the token markers.\n   */\n  public lookupToken(key: string): IResolvable {\n    const token = this.stringTokenMap.get(key);\n    if (!token) {\n      throw new Error(`Unrecognized token key: ${key}`);\n    }\n    return token;\n  }\n\n  private registerStringKey(token: IResolvable, displayHint?: string): string {\n    const counter = this.tokenCounter++;\n    const representation = (displayHint || 'TOKEN').replace(new RegExp(`[^${VALID_KEY_CHARS}]`, 'g'), '.');\n    const key = `${representation}.${counter}`;\n    this.stringTokenMap.set(key, token);\n    return key;\n  }\n\n  private registerNumberKey(token: IResolvable): number {\n    const counter = this.tokenCounter++;\n    this.numberTokenMap.set(counter, token);\n    return createTokenDouble(counter);\n  }\n}\n\n/**\n * Get a cached value for an object, storing it on the object in a symbol\n */\nfunction cachedValue<A extends object, B>(x: A, sym: symbol, prod: () => B) {\n  let cached = (x as any)[sym as any];\n  if (cached === undefined) {\n    cached = prod();\n    Object.defineProperty(x, sym, { value: cached });\n  }\n  return cached;\n}\n"],
  "mappings": "4FAEA,KAAA,SAAA,QAAA,YACA,WAAA,QAAA,cAKM,KAAO,OAEP,cAAgB,OAAO,IAAI,iCAC3B,YAAc,OAAO,IAAI,+BACzB,cAAgB,OAAO,IAAI,iCAWjC,cAAqB,CAArB,aAAA,CAWmB,KAAA,eAAiB,GAAI,KACrB,KAAA,eAAiB,GAAI,KA4B9B,KAAA,aAAe,KAAK,MAAM,KAAK,SAAW,UApCpC,WAAQ,CACpB,MAAK,MAAK,eACR,MAAK,cAAgB,GAAI,WAEpB,KAAK,cA6CP,eAAe,MAAoB,YAAoB,CAC5D,MAAO,aAAY,MAAO,cAAe,IAAK,CAC5C,KAAM,KAAM,KAAK,kBAAkB,MAAO,aAC1C,MAAO,GAAG,WAAA,4BAA4B,MAAM,WAAA,qBAOzC,aAAa,MAAoB,YAAoB,CAC1D,MAAO,aAAY,MAAO,YAAa,IAAK,CAC1C,KAAM,KAAM,KAAK,kBAAkB,MAAO,aAC1C,MAAO,CAAC,GAAG,WAAA,0BAA0B,MAAM,WAAA,sBAOxC,eAAe,MAAkB,CACtC,MAAO,aAAY,MAAO,cAAe,IAChC,KAAK,kBAAkB,QAO3B,kBAAkB,EAAM,CAC7B,GAAI,QAAA,mBAAmB,GAAM,MAAO,GACpC,GAAI,MAAO,IAAM,SAAY,MAAO,MAAK,aAAa,GACtD,GAAI,MAAM,QAAQ,GAAM,MAAO,MAAK,WAAW,GAC/C,GAAI,QAAA,MAAM,aAAa,GAAM,MAAO,GAO/B,aAAa,EAAS,CAC3B,KAAM,WAAY,KAAK,YAAY,GACnC,GAAI,UAAU,OAAO,OAAS,GAAK,UAAU,SAAW,EACtD,MAAO,WAAU,WAQd,WAAW,GAAY,CAC5B,GAAI,GAAG,SAAW,EAAK,OAEvB,KAAM,WAAY,AADN,WAAA,YAAY,aAAa,GAAG,IAClB,MAAM,KAAK,YAAY,KAAK,OAClD,GAAI,UAAU,SAAW,EACvB,MAAO,WAAU,WAQd,YAAY,EAAS,CAE1B,MAAO,AADK,YAAA,YAAY,UAAU,GACvB,MAAM,KAAK,YAAY,KAAK,OAMlC,kBAAkB,EAAS,CAChC,KAAM,YAAa,WAAA,mBAAmB,GACtC,GAAI,aAAe,OAAa,OAChC,KAAM,GAAI,KAAK,eAAe,IAAI,YAClC,GAAI,IAAM,OAAa,KAAM,IAAI,OAAM,wDACvC,MAAO,GAQF,YAAY,IAAW,CAC5B,KAAM,OAAQ,KAAK,eAAe,IAAI,KACtC,GAAI,CAAC,MACH,KAAM,IAAI,OAAM,2BAA2B,OAE7C,MAAO,OAGD,kBAAkB,MAAoB,YAAoB,CAChE,KAAM,SAAU,KAAK,eAEf,IAAM,GADY,cAAe,SAAS,QAAQ,GAAI,QAAO,KAAK,WAAA,mBAAoB,KAAM,QACjE,UACjC,YAAK,eAAe,IAAI,IAAK,OACtB,IAGD,kBAAkB,MAAkB,CAC1C,KAAM,SAAU,KAAK,eACrB,YAAK,eAAe,IAAI,QAAS,OAC1B,WAAA,kBAAkB,UA7J7B,QAAA,SAAA,SAoKA,qBAA0C,EAAM,IAAa,KAAa,CACxE,GAAI,QAAU,EAAU,KACxB,MAAI,UAAW,QACb,QAAS,OACT,OAAO,eAAe,EAAG,IAAK,CAAE,MAAO,UAElC",
  "names": []
}
