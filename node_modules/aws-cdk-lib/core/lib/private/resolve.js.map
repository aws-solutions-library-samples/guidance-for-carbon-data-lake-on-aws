{
  "version": 3,
  "sources": ["resolve.ts"],
  "sourcesContent": ["import { IConstruct } from 'constructs';\nimport { DefaultTokenResolver, IPostProcessor, IResolvable, IResolveContext, ITokenResolver, ResolveChangeContextOptions, StringConcat } from '../resolvable';\nimport { TokenizedStringFragments } from '../string-fragments';\nimport { containsListTokenElement, TokenString, unresolved } from './encoding';\nimport { TokenMap } from './token-map';\n\n// This file should not be exported to consumers, resolving should happen through Construct.resolve()\nconst tokenMap = TokenMap.instance();\n\n/**\n * Resolved complex values will have a type hint applied.\n *\n * The type hint will be based on the type of the input value that was resolved.\n *\n * If the value was encoded, the type hint will be the type of the encoded value. In case\n * of a plain `IResolvable`, a type hint of 'string' will be assumed.\n */\nconst RESOLUTION_TYPEHINT_SYM = Symbol.for('@aws-cdk/core.resolvedTypeHint');\n\n/**\n * Prefix used for intrinsic keys\n *\n * If a key with this prefix is found in an object, the actual value of the\n * key doesn't matter. The value of this key will be an `[ actualKey, actualValue ]`\n * tuple, and the `actualKey` will be a value which otherwise couldn't be represented\n * in the types of `string | number | symbol`, which are the only possible JavaScript\n * object keys.\n */\nexport const INTRINSIC_KEY_PREFIX = '$IntrinsicKey$';\n\n/**\n * Type hints for resolved values\n */\nexport enum ResolutionTypeHint {\n  STRING = 'string',\n  NUMBER = 'number',\n  LIST = 'list',\n}\n\n/**\n * Options to the resolve() operation\n *\n * NOT the same as the ResolveContext; ResolveContext is exposed to Token\n * implementors and resolution hooks, whereas this struct is just to bundle\n * a number of things that would otherwise be arguments to resolve() in a\n * readable way.\n */\nexport interface IResolveOptions {\n  scope: IConstruct;\n  preparing: boolean;\n  resolver: ITokenResolver;\n  prefix?: string[];\n\n  /**\n   * Whether or not to allow intrinsics in keys of an object\n   *\n   * Because keys of an object must be strings, a (resolved) intrinsic, which\n   * is an object, cannot be stored in that position. By default, we reject these\n   * intrinsics if we encounter them.\n   *\n   * If this is set to `true`, in order to store the complex value in a map,\n   * keys that happen to evaluate to intrinsics will be added with a unique key\n   * identified by an uncomming prefix, mapped to a tuple that represents the\n   * actual key/value-pair. The map will look like this:\n   *\n   * {\n   *    '$IntrinsicKey$0': [ { Ref: ... }, 'value1' ],\n   *    '$IntrinsicKey$1': [ { Ref: ... }, 'value2' ],\n   *    'regularKey': 'value3',\n   *    ...\n   * }\n   *\n   * Callers should only set this option to `true` if they are prepared to deal with\n   * the object in this weird shape, and massage it back into a correct object afterwards.\n   *\n   * (A regular but uncommon string was chosen over something like symbols or\n   * other ways of tagging the extra values in order to simplify the implementation which\n   * maintains the desired behavior `resolve(resolve(x)) == resolve(x)`).\n   *\n   * @default false\n   */\n  allowIntrinsicKeys?: boolean;\n\n  /**\n   * Whether to remove undefined elements from arrays and objects when resolving.\n   *\n   * @default true\n   */\n  removeEmpty?: boolean;\n}\n\n/**\n * Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.\n * Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.\n *\n * @param obj The object to resolve.\n * @param prefix Prefix key path components for diagnostics.\n */\nexport function resolve(obj: any, options: IResolveOptions): any {\n  const prefix = options.prefix || [];\n  const pathName = '/' + prefix.join('/');\n\n  /**\n   * Make a new resolution context\n   */\n  function makeContext(appendPath?: string): [IResolveContext, IPostProcessor] {\n    const newPrefix = appendPath !== undefined ? prefix.concat([appendPath]) : options.prefix;\n\n    let postProcessor: IPostProcessor | undefined;\n\n    const context: IResolveContext = {\n      preparing: options.preparing,\n      scope: options.scope as IConstruct,\n      registerPostProcessor(pp) { postProcessor = pp; },\n      resolve(x: any, changeOptions?: ResolveChangeContextOptions) { return resolve(x, { ...options, ...changeOptions, prefix: newPrefix }); },\n    };\n\n    return [context, { postProcess(x) { return postProcessor ? postProcessor.postProcess(x, context) : x; } }];\n  }\n\n  // protect against cyclic references by limiting depth.\n  if (prefix.length > 200) {\n    throw new Error('Unable to resolve object tree with circular reference. Path: ' + pathName);\n  }\n\n  // whether to leave the empty elements when resolving - false by default\n  const leaveEmpty = options.removeEmpty === false;\n\n  //\n  // undefined\n  //\n\n  if (typeof(obj) === 'undefined') {\n    return undefined;\n  }\n\n  //\n  // null\n  //\n\n  if (obj === null) {\n    return null;\n  }\n\n  //\n  // functions - not supported (only tokens are supported)\n  //\n\n  if (typeof(obj) === 'function') {\n    throw new Error(`Trying to resolve a non-data object. Only token are supported for lazy evaluation. Path: ${pathName}. Object: ${obj}`);\n  }\n\n  //\n  // string - potentially replace all stringified Tokens\n  //\n  if (typeof(obj) === 'string') {\n    // If this is a \"list element\" Token, it should never occur by itself in string context\n    if (TokenString.forListToken(obj).test()) {\n      throw new Error('Found an encoded list token string in a scalar string context. Use \\'Fn.select(0, list)\\' (not \\'list[0]\\') to extract elements from token lists.');\n    }\n\n    // Otherwise look for a stringified Token in this object\n    const str = TokenString.forString(obj);\n    if (str.test()) {\n      const fragments = str.split(tokenMap.lookupToken.bind(tokenMap));\n      return tagResolvedValue(options.resolver.resolveString(fragments, makeContext()[0]), ResolutionTypeHint.STRING);\n    }\n    return obj;\n  }\n\n  //\n  // number - potentially decode Tokenized number\n  //\n  if (typeof(obj) === 'number') {\n    return tagResolvedValue(resolveNumberToken(obj, makeContext()[0]), ResolutionTypeHint.NUMBER);\n  }\n\n  //\n  // primitives - as-is\n  //\n\n  if (typeof(obj) !== 'object' || obj instanceof Date) {\n    return obj;\n  }\n\n  //\n  // arrays - resolve all values, remove undefined and remove empty arrays\n  //\n\n  if (Array.isArray(obj)) {\n    if (containsListTokenElement(obj)) {\n      return tagResolvedValue(options.resolver.resolveList(obj, makeContext()[0]), ResolutionTypeHint.LIST);\n    }\n\n    const arr = obj\n      .map((x, i) => makeContext(`${i}`)[0].resolve(x))\n      .filter(x => leaveEmpty || typeof(x) !== 'undefined');\n\n    return arr;\n  }\n\n  //\n  // tokens - invoke 'resolve' and continue to resolve recursively\n  //\n\n  if (unresolved(obj)) {\n    const [context, postProcessor] = makeContext();\n    const ret = tagResolvedValue(options.resolver.resolveToken(obj, context, postProcessor), ResolutionTypeHint.STRING);\n    return ret;\n  }\n\n  //\n  // objects - deep-resolve all values\n  //\n\n  // Must not be a Construct at this point, otherwise you probably made a typo\n  // mistake somewhere and resolve will get into an infinite loop recursing into\n  // child.parent <---> parent.children\n  if (isConstruct(obj)) {\n    throw new Error('Trying to resolve() a Construct at ' + pathName);\n  }\n\n  const result: any = { };\n  let intrinsicKeyCtr = 0;\n  for (const key of Object.keys(obj)) {\n    const value = makeContext(String(key))[0].resolve(obj[key]);\n\n    // skip undefined\n    if (typeof(value) === 'undefined') {\n      if (leaveEmpty) {\n        result[key] = undefined;\n      }\n      continue;\n    }\n\n    // Simple case -- not an unresolved key\n    if (!unresolved(key)) {\n      result[key] = value;\n      continue;\n    }\n\n    const resolvedKey = makeContext()[0].resolve(key);\n    if (typeof(resolvedKey) === 'string') {\n      result[resolvedKey] = value;\n    } else {\n      if (!options.allowIntrinsicKeys) {\n        // eslint-disable-next-line max-len\n        throw new Error(`\"${String(key)}\" is used as the key in a map so must resolve to a string, but it resolves to: ${JSON.stringify(resolvedKey)}. Consider using \"CfnJson\" to delay resolution to deployment-time`);\n      }\n\n      // Can't represent this object in a JavaScript key position, but we can store it\n      // in value position. Use a unique symbol as the key.\n      result[`${INTRINSIC_KEY_PREFIX}${intrinsicKeyCtr++}`] = [resolvedKey, value];\n    }\n  }\n\n  // Because we may be called to recurse on already resolved values (that already have type hints applied)\n  // and we just copied those values into a fresh object, be sure to retain any type hints.\n  const previousTypeHint = resolvedTypeHint(obj);\n  return previousTypeHint ? tagResolvedValue(result, previousTypeHint) : result;\n}\n\n/**\n * Find all Tokens that are used in the given structure\n */\nexport function findTokens(scope: IConstruct, fn: () => any): IResolvable[] {\n  const resolver = new RememberingTokenResolver(new StringConcat());\n\n  resolve(fn(), { scope, prefix: [], resolver, preparing: true });\n\n  return resolver.tokens;\n}\n\n/**\n * Remember all Tokens encountered while resolving\n */\nexport class RememberingTokenResolver extends DefaultTokenResolver {\n  private readonly tokensSeen = new Set<IResolvable>();\n\n  public resolveToken(t: IResolvable, context: IResolveContext, postProcessor: IPostProcessor) {\n    this.tokensSeen.add(t);\n    return super.resolveToken(t, context, postProcessor);\n  }\n\n  public resolveString(s: TokenizedStringFragments, context: IResolveContext) {\n    const ret = super.resolveString(s, context);\n    return ret;\n  }\n\n  public get tokens(): IResolvable[] {\n    return Array.from(this.tokensSeen);\n  }\n}\n\n/**\n * Determine whether an object is a Construct\n *\n * Not in 'construct.ts' because that would lead to a dependency cycle via 'uniqueid.ts',\n * and this is a best-effort protection against a common programming mistake anyway.\n */\nfunction isConstruct(x: any): boolean {\n  return x._children !== undefined && x._metadata !== undefined;\n}\n\nfunction resolveNumberToken(x: number, context: IResolveContext): any {\n  const token = TokenMap.instance().lookupNumberToken(x);\n  if (token === undefined) { return x; }\n  return context.resolve(token);\n}\n\n/**\n * Apply a type hint to a resolved value\n *\n * The type hint will only be applied to objects.\n *\n * These type hints are used for correct JSON-ification of intrinsic values.\n */\nfunction tagResolvedValue(value: any, typeHint: ResolutionTypeHint): any {\n  if (typeof value !== 'object' || value == null) { return value; }\n  Object.defineProperty(value, RESOLUTION_TYPEHINT_SYM, {\n    value: typeHint,\n    configurable: true,\n  });\n  return value;\n}\n\n/**\n * Return the type hint from the given value\n *\n * If the value is not a resolved value (i.e, the result of resolving a token),\n * `undefined` will be returned.\n *\n * These type hints are used for correct JSON-ification of intrinsic values.\n */\nexport function resolvedTypeHint(value: any): ResolutionTypeHint | undefined {\n  if (typeof value !== 'object' || value == null) { return undefined; }\n  return value[RESOLUTION_TYPEHINT_SYM];\n}\n"],
  "mappings": "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",
  "names": []
}
