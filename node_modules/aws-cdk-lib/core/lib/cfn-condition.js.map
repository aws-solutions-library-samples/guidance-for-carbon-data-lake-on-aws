{
  "version": 3,
  "sources": ["cfn-condition.ts"],
  "sourcesContent": ["import { Construct } from 'constructs';\nimport { CfnElement } from './cfn-element';\nimport { IResolvable, IResolveContext } from './resolvable';\n\nexport interface CfnConditionProps {\n  /**\n   * The expression that the condition will evaluate.\n   *\n   * @default - None.\n   */\n  readonly expression?: ICfnConditionExpression;\n}\n\n/**\n * Represents a CloudFormation condition, for resources which must be conditionally created and\n * the determination must be made at deploy time.\n */\nexport class CfnCondition extends CfnElement implements ICfnConditionExpression, IResolvable {\n  /**\n   * The condition statement.\n   */\n  public expression?: ICfnConditionExpression;\n\n  /**\n   * Build a new condition. The condition must be constructed with a condition token,\n   * that the condition is based on.\n   */\n  constructor(scope: Construct, id: string, props?: CfnConditionProps) {\n    super(scope, id);\n    this.expression = props && props.expression;\n  }\n\n  /**\n   * @internal\n   */\n  public _toCloudFormation(): object {\n    if (!this.expression) {\n      return { };\n    }\n\n    return {\n      Conditions: {\n        [this.logicalId]: this.expression,\n      },\n    };\n  }\n\n  /**\n   * Synthesizes the condition.\n   */\n  public resolve(_context: IResolveContext): any {\n    return { Condition: this.logicalId };\n  }\n}\n\n/**\n * Represents a CloudFormation element that can be used within a Condition.\n *\n * You can use intrinsic functions, such as ``Fn.conditionIf``,\n * ``Fn.conditionEquals``, and ``Fn.conditionNot``, to conditionally create\n * stack resources. These conditions are evaluated based on input parameters\n * that you declare when you create or update a stack. After you define all your\n * conditions, you can associate them with resources or resource properties in\n * the Resources and Outputs sections of a template.\n *\n * You define all conditions in the Conditions section of a template except for\n * ``Fn.conditionIf`` conditions. You can use the ``Fn.conditionIf`` condition\n * in the metadata attribute, update policy attribute, and property values in\n * the Resources section and Outputs sections of a template.\n *\n * You might use conditions when you want to reuse a template that can create\n * resources in different contexts, such as a test environment versus a\n * production environment. In your template, you can add an EnvironmentType\n * input parameter, which accepts either prod or test as inputs. For the\n * production environment, you might include Amazon EC2 instances with certain\n * capabilities; however, for the test environment, you want to use less\n * capabilities to save costs. With conditions, you can define which resources\n * are created and how they're configured for each environment type.\n *\n * You can use `toString` when you wish to embed a condition expression\n * in a property value that accepts a `string`. For example:\n *\n * ```ts\n * new sqs.Queue(this, 'MyQueue', {\n *   queueName: Fn.conditionIf('Condition', 'Hello', 'World').toString()\n * });\n * ```\n */\nexport interface ICfnConditionExpression extends IResolvable {}\n\n/**\n * Interface to specify certain functions as Service Catalog rule-specifc.\n * These functions can only be used in ``Rules`` section of template.\n */\nexport interface ICfnRuleConditionExpression extends ICfnConditionExpression {\n  /**\n   * This field is only needed to defeat TypeScript's structural typing.\n   * It is never used.\n   */\n  readonly disambiguator: boolean;\n}\n"],
  "mappings": "mNACA,cAAA,QAAA,iBAgBA,0BAAkC,eAAA,UAAU,CAU1C,YAAY,MAAkB,GAAY,MAAyB,CACjE,MAAM,MAAO,iEACb,KAAK,WAAa,OAAS,MAAM,WAM5B,mBAAiB,CACtB,MAAK,MAAK,WAIH,CACL,WAAY,EACT,KAAK,WAAY,KAAK,aALlB,GAaJ,QAAQ,SAAyB,sEAC/B,CAAE,UAAW,KAAK,YAlC7B,QAAA,aAAA",
  "names": []
}
