{
  "version": 3,
  "sources": ["vault.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as sns from '../../aws-sns';\nimport { ArnFormat, IResource, Lazy, Names, RemovalPolicy, Resource, Stack } from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnBackupVault } from './backup.generated';\n\n/**\n * A backup vault\n */\nexport interface IBackupVault extends IResource {\n  /**\n   * The name of a logical container where backups are stored.\n   *\n   * @attribute\n   */\n  readonly backupVaultName: string;\n\n  /**\n   * The ARN of the backup vault.\n   *\n   * @attribute\n   */\n  readonly backupVaultArn: string;\n\n  /**\n   * Grant the actions defined in actions to the given grantee\n   * on this backup vault.\n   */\n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n}\n\n/**\n * Properties for a BackupVault\n */\nexport interface BackupVaultProps {\n  /**\n   * The name of a logical container where backups are stored. Backup vaults\n   * are identified by names that are unique to the account used to create\n   * them and the AWS Region where they are created.\n   *\n   * @default - A CDK generated name\n   */\n  readonly backupVaultName?: string;\n\n  /**\n   * A resource-based policy that is used to manage access permissions on the\n   * backup vault.\n   *\n   * @default - access is not restricted\n   */\n  readonly accessPolicy?: iam.PolicyDocument;\n\n  /**\n   * The server-side encryption key to use to protect your backups.\n   *\n   * @default - an Amazon managed KMS key\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * A SNS topic to send vault events to.\n   *\n   * @see https://docs.aws.amazon.com/aws-backup/latest/devguide/sns-notifications.html\n   *\n   * @default - no notifications\n   */\n  readonly notificationTopic?: sns.ITopic\n\n  /**\n   * The vault events to send.\n   *\n   * @see https://docs.aws.amazon.com/aws-backup/latest/devguide/sns-notifications.html\n   *\n   * @default - all vault events if `notificationTopic` is defined\n   */\n  readonly notificationEvents?: BackupVaultEvents[];\n\n  /**\n   * The removal policy to apply to the vault. Note that removing a vault\n   * that contains recovery points will fail.\n   *\n   * @default RemovalPolicy.RETAIN\n   */\n  readonly removalPolicy?: RemovalPolicy;\n\n  /**\n   * Whether to add statements to the vault access policy that prevents anyone\n   * from deleting a recovery point.\n   *\n   * @default false\n   */\n  readonly blockRecoveryPointDeletion?: boolean;\n}\n\n/**\n * Backup vault events\n */\nexport enum BackupVaultEvents {\n  /** BACKUP_JOB_STARTED */\n  BACKUP_JOB_STARTED = 'BACKUP_JOB_STARTED',\n  /** BACKUP_JOB_COMPLETED */\n  BACKUP_JOB_COMPLETED = 'BACKUP_JOB_COMPLETED',\n  /** BACKUP_JOB_SUCCESSFUL */\n  BACKUP_JOB_SUCCESSFUL = 'BACKUP_JOB_SUCCESSFUL',\n  /** BACKUP_JOB_FAILED */\n  BACKUP_JOB_FAILED = 'BACKUP_JOB_FAILED',\n  /** BACKUP_JOB_EXPIRED */\n  BACKUP_JOB_EXPIRED = 'BACKUP_JOB_EXPIRED',\n  /** RESTORE_JOB_STARTED */\n  RESTORE_JOB_STARTED = 'RESTORE_JOB_STARTED',\n  /** RESTORE_JOB_COMPLETED */\n  RESTORE_JOB_COMPLETED = 'RESTORE_JOB_COMPLETED',\n  /** RESTORE_JOB_SUCCESSFUL */\n  RESTORE_JOB_SUCCESSFUL = 'RESTORE_JOB_SUCCESSFUL',\n  /** RESTORE_JOB_FAILED */\n  RESTORE_JOB_FAILED = 'RESTORE_JOB_FAILED',\n  /** COPY_JOB_STARTED */\n  COPY_JOB_STARTED = 'COPY_JOB_STARTED',\n  /** COPY_JOB_SUCCESSFUL */\n  COPY_JOB_SUCCESSFUL = 'COPY_JOB_SUCCESSFUL',\n  /** COPY_JOB_FAILED */\n  COPY_JOB_FAILED = 'COPY_JOB_FAILED',\n  /** RECOVERY_POINT_MODIFIED */\n  RECOVERY_POINT_MODIFIED = 'RECOVERY_POINT_MODIFIED',\n  /** BACKUP_PLAN_CREATED */\n  BACKUP_PLAN_CREATED = 'BACKUP_PLAN_CREATED',\n  /** BACKUP_PLAN_MODIFIED */\n  BACKUP_PLAN_MODIFIED = 'BACKUP_PLAN_MODIFIED',\n}\n\nabstract class BackupVaultBase extends Resource implements IBackupVault {\n  public abstract readonly backupVaultName: string;\n  public abstract readonly backupVaultArn: string;\n\n  /**\n   * Grant the actions defined in actions to the given grantee\n   * on this Backup Vault resource.\n   *\n   * @param grantee Principal to grant right to\n   * @param actions The actions to grant\n   */\n  public grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant {\n    for (const action of actions) {\n      if (action.indexOf('*') >= 0) {\n        throw new Error(\"AWS Backup access policies don't support a wildcard in the Action key.\");\n      }\n    }\n\n    return iam.Grant.addToPrincipal({\n      grantee: grantee,\n      actions: actions,\n      resourceArns: [this.backupVaultArn],\n    });\n  }\n}\n\n\n/**\n * A backup vault\n */\nexport class BackupVault extends BackupVaultBase {\n  /**\n   * Import an existing backup vault by name\n   */\n  public static fromBackupVaultName(scope: Construct, id: string, backupVaultName: string): IBackupVault {\n    const backupVaultArn = Stack.of(scope).formatArn({\n      service: 'backup',\n      resource: 'backup-vault',\n      resourceName: backupVaultName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n\n    return BackupVault.fromBackupVaultArn(scope, id, backupVaultArn);\n  }\n\n  /**\n   * Import an existing backup vault by arn\n   */\n  public static fromBackupVaultArn(scope: Construct, id: string, backupVaultArn: string): IBackupVault {\n    const parsedArn = Stack.of(scope).splitArn(backupVaultArn, ArnFormat.SLASH_RESOURCE_NAME);\n\n    if (!parsedArn.resourceName) {\n      throw new Error(`Backup Vault Arn ${backupVaultArn} does not have a resource name.`);\n    }\n\n    class Import extends BackupVaultBase {\n      public readonly backupVaultName = parsedArn.resourceName!;\n      public readonly backupVaultArn = backupVaultArn;\n    }\n\n    return new Import(scope, id, {\n      account: parsedArn.account,\n      region: parsedArn.region,\n    });\n  }\n\n  public readonly backupVaultName: string;\n  public readonly backupVaultArn: string;\n\n  private readonly accessPolicy: iam.PolicyDocument;\n\n  constructor(scope: Construct, id: string, props: BackupVaultProps = {}) {\n    super(scope, id);\n\n    if (props.backupVaultName && !/^[a-zA-Z0-9\\-_]{2,50}$/.test(props.backupVaultName)) {\n      throw new Error('Expected vault name to match pattern `^[a-zA-Z0-9\\-_]{2,50}$`');\n    }\n\n    let notifications: CfnBackupVault.NotificationObjectTypeProperty | undefined;\n    if (props.notificationTopic) {\n      notifications = {\n        backupVaultEvents: props.notificationEvents || Object.values(BackupVaultEvents),\n        snsTopicArn: props.notificationTopic.topicArn,\n      };\n      props.notificationTopic.grantPublish(new iam.ServicePrincipal('backup.amazonaws.com'));\n    }\n\n    this.accessPolicy = props.accessPolicy ?? new iam.PolicyDocument();\n    if (props.blockRecoveryPointDeletion) {\n      this.blockRecoveryPointDeletion();\n    }\n\n    const vault = new CfnBackupVault(this, 'Resource', {\n      backupVaultName: props.backupVaultName || this.uniqueVaultName(),\n      accessPolicy: Lazy.any({ produce: () => this.accessPolicy.toJSON() }),\n      encryptionKeyArn: props.encryptionKey && props.encryptionKey.keyArn,\n      notifications,\n    });\n    vault.applyRemovalPolicy(props.removalPolicy);\n\n    this.backupVaultName = vault.attrBackupVaultName;\n    this.backupVaultArn = vault.attrBackupVaultArn;\n  }\n\n  /**\n   * Adds a statement to the vault access policy\n   */\n  public addToAccessPolicy(statement: iam.PolicyStatement) {\n    this.accessPolicy.addStatements(statement);\n  }\n\n  /**\n   * Adds a statement to the vault access policy that prevents anyone\n   * from deleting a recovery point.\n   */\n  public blockRecoveryPointDeletion() {\n    this.addToAccessPolicy(new iam.PolicyStatement({\n      effect: iam.Effect.DENY,\n      actions: [\n        'backup:DeleteRecoveryPoint',\n        'backup:UpdateRecoveryPointLifecycle',\n      ],\n      principals: [new iam.AnyPrincipal()],\n      resources: ['*'],\n    }));\n  }\n\n  private uniqueVaultName() {\n    // Max length of 50 chars, get the last 50 chars\n    const id = Names.uniqueId(this);\n    return id.substring(Math.max(id.length - 50, 0), id.length);\n  }\n}\n"],
  "mappings": "4OAAA,IAAA,QAAA,iBAGA,OAAA,QAAA,cAEA,mBAAA,QAAA,sBA6FA,GAAY,mBAAZ,AAAA,UAAY,mBAAiB,CAE3B,mBAAA,mBAAA,qBAEA,mBAAA,qBAAA,uBAEA,mBAAA,sBAAA,wBAEA,mBAAA,kBAAA,oBAEA,mBAAA,mBAAA,qBAEA,mBAAA,oBAAA,sBAEA,mBAAA,sBAAA,wBAEA,mBAAA,uBAAA,yBAEA,mBAAA,mBAAA,qBAEA,mBAAA,iBAAA,mBAEA,mBAAA,oBAAA,sBAEA,mBAAA,gBAAA,kBAEA,mBAAA,wBAAA,0BAEA,mBAAA,oBAAA,sBAEA,mBAAA,qBAAA,yBA9BU,kBAAA,QAAA,mBAAA,SAAA,kBAAiB,KAiC7B,6BAAuC,QAAA,QAAQ,CAWtC,MAAM,WAA4B,QAAiB,CACxD,SAAW,UAAU,SACnB,GAAI,OAAO,QAAQ,MAAQ,EACzB,KAAM,IAAI,OAAM,0EAIpB,MAAO,KAAI,MAAM,eAAe,CAC9B,QACA,QACA,aAAc,CAAC,KAAK,mBAS1B,yBAAiC,gBAAe,CAyC9C,YAAY,MAAkB,GAAY,MAA0B,GAAE,QACpE,MAAM,MAAO,IAEb,0EAAI,MAAM,iBAAmB,CAAC,yBAAyB,KAAK,MAAM,iBAChE,KAAM,IAAI,OAAM,gEAGlB,GAAI,eACJ,AAAI,MAAM,mBACR,eAAgB,CACd,kBAAmB,MAAM,oBAAsB,OAAO,OAAO,mBAC7D,YAAa,MAAM,kBAAkB,UAEvC,MAAM,kBAAkB,aAAa,GAAI,KAAI,iBAAiB,0BAGhE,KAAK,aAAY,IAAG,MAAM,gBAAY,MAAA,KAAA,OAAA,GAAI,GAAI,KAAI,eAC9C,MAAM,4BACR,KAAK,6BAGP,KAAM,OAAQ,GAAI,oBAAA,eAAe,KAAM,WAAY,CACjD,gBAAiB,MAAM,iBAAmB,KAAK,kBAC/C,aAAc,OAAA,KAAK,IAAI,CAAE,QAAS,IAAM,KAAK,aAAa,WAC1D,iBAAkB,MAAM,eAAiB,MAAM,cAAc,OAC7D,gBAEF,MAAM,mBAAmB,MAAM,eAE/B,KAAK,gBAAkB,MAAM,oBAC7B,KAAK,eAAiB,MAAM,yBAnEhB,qBAAoB,MAAkB,GAAY,gBAAuB,CACrF,KAAM,gBAAiB,OAAA,MAAM,GAAG,OAAO,UAAU,CAC/C,QAAS,SACT,SAAU,eACV,aAAc,gBACd,UAAW,OAAA,UAAU,sBAGvB,MAAO,aAAY,mBAAmB,MAAO,GAAI,sBAMrC,oBAAmB,MAAkB,GAAY,eAAsB,CACnF,KAAM,WAAY,OAAA,MAAM,GAAG,OAAO,SAAS,eAAgB,OAAA,UAAU,qBAErE,GAAI,CAAC,UAAU,aACb,KAAM,IAAI,OAAM,oBAAoB,iDAGtC,oBAAqB,gBAAe,CAApC,aAAA,qBACkB,KAAA,gBAAkB,UAAU,aAC5B,KAAA,eAAiB,gBAGnC,MAAO,IAAI,QAAO,MAAO,GAAI,CAC3B,QAAS,UAAU,QACnB,OAAQ,UAAU,SA6Cf,kBAAkB,UAA8B,wEACrD,KAAK,aAAa,cAAc,WAO3B,4BAA0B,CAC/B,KAAK,kBAAkB,GAAI,KAAI,gBAAgB,CAC7C,OAAQ,IAAI,OAAO,KACnB,QAAS,CACP,6BACA,uCAEF,WAAY,CAAC,GAAI,KAAI,cACrB,UAAW,CAAC,QAIR,iBAAe,CAErB,KAAM,IAAK,OAAA,MAAM,SAAS,MAC1B,MAAO,IAAG,UAAU,KAAK,IAAI,GAAG,OAAS,GAAI,GAAI,GAAG,SApGxD,QAAA,YAAA",
  "names": []
}
