{
  "version": 3,
  "sources": ["interval-utils.ts"],
  "sourcesContent": ["import { ScalingInterval } from './types';\n\nexport interface CompleteScalingInterval {\n  readonly lower: number;\n  readonly upper: number;\n  readonly change?: number;\n}\n\n/**\n * Normalize the given interval set to cover the complete number line and make sure it has at most one gap\n */\nexport function normalizeIntervals(intervals: ScalingInterval[], changesAreAbsolute: boolean): CompleteScalingInterval[] {\n  // Make intervals a complete numberline\n  const full = orderAndCompleteIntervals(intervals);\n  // Add 'undefined's in uncovered areas of the number line\n  makeGapsUndefined(full);\n\n  // In case of relative changes, treat 0-change also as 'undefined' (= no change action)\n  if (!changesAreAbsolute) { makeZerosUndefined(full); }\n\n  // Combine adjacent undefines and make sure there's at most one of them\n  combineUndefineds(full);\n  validateAtMostOneUndefined(full);\n\n  return full;\n}\n\n/**\n * Completely order scaling intervals, making their lower and upper bounds concrete.\n */\nfunction orderAndCompleteIntervals(intervals: ScalingInterval[]): CompleteScalingInterval[] {\n  if (intervals.length < 2) {\n    throw new Error('Require at least 2 intervals');\n  }\n\n  for (const interval of intervals) {\n    if (interval.lower === undefined && interval.upper === undefined) {\n      throw new Error(`Must supply at least one of 'upper' or 'lower', got: ${JSON.stringify(interval)}`);\n    }\n  }\n\n  // Make a copy\n  intervals = intervals.map(x => ({ ...x }));\n\n  // Sort by whatever number we have for each interval\n  intervals.sort(comparatorFromKey((x: ScalingInterval) => x.lower ?? x.upper));\n\n  // Propagate boundaries until no more change\n  while (propagateBounds(intervals)) { /* Repeat */ }\n\n  const lastIndex = intervals.length - 1;\n\n  // Validate that no intervals have undefined bounds now, which must mean they're complete.\n  if (intervals[0].lower === undefined) { intervals[0] = { ...intervals[0], lower: 0 }; }\n  if (intervals[lastIndex].upper === undefined) { intervals[lastIndex] = { ...intervals[lastIndex], upper: Infinity }; }\n  for (const interval of intervals) {\n    if (interval.lower === undefined || interval.upper === undefined) {\n      throw new Error(`Could not determine the lower and upper bounds for ${JSON.stringify(interval)}`);\n    }\n  }\n\n  const completeIntervals = intervals as CompleteScalingInterval[];\n\n  // Validate that we have nonoverlapping intervals now.\n  for (let i = 0; i < completeIntervals.length - 1; i++) {\n    if (overlap(completeIntervals[i], completeIntervals[i + 1])) {\n      throw new Error(`Two intervals overlap: ${JSON.stringify(completeIntervals[i])} and ${JSON.stringify(completeIntervals[i + 1])}`);\n    }\n  }\n\n  // Fill up the gaps\n\n  return completeIntervals;\n}\n\n/**\n * Make the intervals cover the complete number line\n *\n * This entails adding intervals with an 'undefined' change to fill up the gaps.\n *\n * Since metrics have a halfopen interval, the first one will get a lower bound\n * of 0, the last one will get an upper bound of +Infinity.\n *\n * In case of absolute adjustments, the lower number of the adjacent bound will\n * be used, which means conservative change. In case of relative adjustments,\n * we'll use relative adjusment 0 (which means no change).\n */\nfunction makeGapsUndefined(intervals: CompleteScalingInterval[]) {\n  // Add edge intervals if necessary, but only for relative adjustments. Since we're\n  // going to make scaling intervals extend all the way out to infinity on either side,\n  // the result is the same for absolute adjustments anyway.\n  if (intervals[0].lower !== 0) {\n    intervals.splice(0, 0, {\n      lower: 0,\n      upper: intervals[0].lower,\n      change: undefined,\n    });\n  }\n  if (last(intervals).upper !== Infinity) {\n    intervals.push({\n      lower: last(intervals).upper,\n      upper: Infinity,\n      change: undefined,\n    });\n  }\n\n  let i = 1;\n  while (i < intervals.length) {\n    if (intervals[i - 1].upper < intervals[i].lower) {\n      intervals.splice(i, 0, {\n        lower: intervals[i - 1].upper,\n        upper: intervals[i].lower,\n        change: undefined,\n      });\n    } else {\n      i++;\n    }\n  }\n}\n\n/**\n * Turn zero changes into undefined, in-place\n */\nfunction makeZerosUndefined(intervals: CompleteScalingInterval[]) {\n  for (let i = 0; i < intervals.length; ++i) {\n    const interval = intervals[i];\n    if (interval.change === 0) {\n      intervals[i] = { ...interval, change: undefined };\n    }\n  }\n}\n\n/**\n * If there are adjacent \"undefined\" intervals, combine them\n */\nfunction combineUndefineds(intervals: CompleteScalingInterval[]) {\n  let i = 0;\n  while (i < intervals.length - 1) {\n    if (intervals[i].change === undefined && intervals[i + 1].change === undefined) {\n      intervals[i] = { ...intervals[i], upper: intervals[i + 1].upper };\n      intervals.splice(i + 1, 1);\n    } else {\n      i++;\n    }\n  }\n}\n\nfunction validateAtMostOneUndefined(intervals: CompleteScalingInterval[]) {\n  const undef = intervals.filter(x => x.change === undefined);\n  if (undef.length > 1) {\n    throw new Error(`Can have at most one no-change interval, got ${JSON.stringify(undef)}`);\n  }\n}\n\nfunction comparatorFromKey<T, U>(keyFn: (x: T) => U) {\n  return (a: T, b: T) => {\n    const keyA = keyFn(a);\n    const keyB = keyFn(b);\n\n    if (keyA < keyB) { return -1; }\n    if (keyA === keyB) { return 0; }\n    return 1;\n  };\n}\n\nfunction propagateBounds(intervals: ScalingInterval[]) {\n  let ret = false;\n\n  // Propagate upper bounds upwards\n  for (let i = 0; i < intervals.length - 1; i++) {\n    if (intervals[i].upper !== undefined && intervals[i + 1].lower === undefined) {\n      intervals[i + 1] = { ...intervals[i + 1], lower: intervals[i].upper };\n      ret = true;\n    }\n  }\n\n  // Propagate lower bounds downwards\n  for (let i = intervals.length - 1; i >= 1; i--) {\n    if (intervals[i].lower !== undefined && intervals[i - 1].upper === undefined) {\n      intervals[i - 1] = { ...intervals[i - 1], upper: intervals[i].lower };\n      ret = true;\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Whether two intervals overlap\n */\nfunction overlap(a: CompleteScalingInterval, b: CompleteScalingInterval) {\n  return a.lower < b.upper && a.upper > b.lower;\n}\n\nfunction last<T>(xs: T[]) {\n  return xs[xs.length - 1];\n}\n\nexport interface Alarms {\n  readonly lowerAlarmIntervalIndex?: number;\n  readonly upperAlarmIntervalIndex?: number;\n}\n\n/**\n * Locate the intervals that should have the alarm thresholds, by index.\n *\n * Pick the intervals on either side of the singleton \"undefined\" interval, or\n * pick the middle interval if there's no such interval.\n */\nexport function findAlarmThresholds(intervals: CompleteScalingInterval[]): Alarms {\n  const gapIndex = intervals.findIndex(x => x.change === undefined);\n\n  if (gapIndex !== -1) {\n    return {\n      lowerAlarmIntervalIndex: gapIndex > 0 ? gapIndex - 1 : undefined,\n      upperAlarmIntervalIndex: gapIndex < intervals.length - 1 ? gapIndex + 1 : undefined,\n    };\n  }\n\n  if (intervals.length === 1) {\n    return { upperAlarmIntervalIndex: 0 };\n  }\n\n  const middleIndex = Math.floor(intervals.length / 2);\n\n  return {\n    lowerAlarmIntervalIndex: middleIndex - 1,\n    upperAlarmIntervalIndex: middleIndex,\n  };\n}"],
  "mappings": "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",
  "names": []
}
