{
  "version": 3,
  "sources": ["test-utils.ts"],
  "sourcesContent": ["import * as appscaling from '../lib';\n\n/**\n * Arbitrary (valid) array of intervals\n *\n * There are many invalid combinations of interval arrays, so we have\n * to be very specific about generating arrays that are valid. We do this\n * by taking a full, valid interval schedule and progressively stripping parts\n * away from it.\n *\n * Some of the changes may change its meaning, but we take care to never leave\n * a schedule with insufficient information so that the parser will error out.\n */\nexport function generateArbitraryIntervals(mrng: IRandomGenerator): ArbitraryIntervals {\n  const ret = new Array<appscaling.ScalingInterval>();\n\n  const absolute = mrng.nextBoolean();\n\n  // Ascending or descending scaling\n  const factor = (mrng.nextBoolean() ? 1 : -1) * (absolute ? 10 : 1);\n  const bias = absolute ? 50 : 0;\n\n  // Begin with a full schedule\n  ret.push({ lower: 0, upper: 10, change: -2 * factor + bias });\n  ret.push({ lower: 10, upper: 20, change: -1 * factor + bias });\n  ret.push({ lower: 20, upper: 60, change: 0 + bias });\n  ret.push({ lower: 60, upper: 80, change: 0 + bias });\n  ret.push({ lower: 80, upper: 90, change: 1 * factor + bias });\n  ret.push({ lower: 90, upper: Infinity, change: 2 * factor + bias });\n\n  // Take away parts from this. First we see if we do something to the 0-change alarms.\n  // The actions can be: remove it OR turn it into a regular change value.\n  const noChanges = ret.filter(x => x.change === bias);\n\n  if (!absolute) {\n    if (mrng.nextBoolean()) {\n      if (mrng.nextBoolean()) {\n        ret.splice(ret.indexOf(noChanges[0]), 1);\n      } else {\n        noChanges[0] = { ...noChanges[0], change: -1 * factor + bias };\n      }\n    }\n    if (mrng.nextBoolean()) {\n      if (mrng.nextBoolean()) {\n        ret.splice(ret.indexOf(noChanges[1]), 1);\n      } else {\n        noChanges[1] = { ...noChanges[1], change: 1 * factor + bias };\n      }\n    }\n  } else {\n    // In absolute mode both have to get the same treatment at the same time\n    // otherwise we'll end up with a timeline with two gaps\n    if (mrng.nextBoolean()) {\n      ret.splice(ret.indexOf(noChanges[0]), 1);\n      ret.splice(ret.indexOf(noChanges[1]), 1);\n    } else {\n      noChanges[0] = { ...noChanges[0], change: -1 * factor + bias };\n      noChanges[1] = { ...noChanges[1], change: 1 * factor + bias };\n    }\n  }\n\n  // We might also take away either the bottom or the upper half\n  if (mrng.nextInt(0, 2) === 0) {\n    const signToStrip = mrng.nextBoolean() ? -1 : 1;\n    let ix = ret.findIndex(x => Math.sign(x.change - bias) === signToStrip);\n    while (ix >= 0) {\n      ret.splice(ix, 1);\n      ix = ret.findIndex(x => Math.sign(x.change - bias) === signToStrip);\n    }\n  }\n\n  // Then we're going to arbitrarily get rid of bounds in the most naive way possible\n  const iterations = mrng.nextInt(0, 10);\n  for (let iter = 0; iter < iterations; iter++) {\n    const i = mrng.nextInt(0, ret.length - 1);\n    if (mrng.nextBoolean()) {\n      // scrap lower bound\n      // okay if current interval has an upper bound AND the preceding interval has an upper bound\n      if (ret[i].upper !== undefined && (i === 0 || ret[i - 1].upper !== undefined)) {\n        ret[i] = { ...ret[i], lower: undefined };\n      }\n    } else {\n      // scrap upper bound\n      // okay if current interval has a lower bound AND the succeeding interval has a lower bound\n      if (ret[i].lower !== undefined && (i === ret.length - 1 || ret[i + 1].lower !== undefined)) {\n        ret[i] = { ...ret[i], upper: undefined };\n      }\n    }\n  }\n\n  return { absolute, intervals: ret };\n}\n\nexport interface IRandomGenerator {\n  nextBoolean(): boolean;\n  nextInt(min: number, max: number): number;\n}\n\nexport interface ArbitraryIntervals {\n  readonly absolute: boolean;\n  readonly intervals: appscaling.ScalingInterval[];\n}\n"],
  "mappings": "8GAaA,oCAA2C,KAAsB,CAC/D,KAAM,KAAM,GAAI,OAEV,SAAW,KAAK,cAGhB,OAAU,MAAK,cAAgB,EAAI,IAAO,UAAW,GAAK,GAC1D,KAAO,SAAW,GAAK,EAG7B,IAAI,KAAK,CAAE,MAAO,EAAG,MAAO,GAAI,OAAQ,GAAK,OAAS,OACtD,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,GAAK,OAAS,OACvD,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,EAAI,OAC7C,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,EAAI,OAC7C,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,GAAI,OAAQ,EAAI,OAAS,OACtD,IAAI,KAAK,CAAE,MAAO,GAAI,MAAO,IAAU,OAAQ,EAAI,OAAS,OAI5D,KAAM,WAAY,IAAI,OAAO,GAAK,EAAE,SAAW,MA8B/C,GA5BA,AAAK,SAkBH,AAAI,KAAK,cACP,KAAI,OAAO,IAAI,QAAQ,UAAU,IAAK,GACtC,IAAI,OAAO,IAAI,QAAQ,UAAU,IAAK,IAEtC,WAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,GAAK,OAAS,MACxD,UAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,EAAI,OAAS,OAtBrD,MAAK,eACP,CAAI,KAAK,cACP,IAAI,OAAO,IAAI,QAAQ,UAAU,IAAK,GAEtC,UAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,GAAK,OAAS,OAGxD,KAAK,eACP,CAAI,KAAK,cACP,IAAI,OAAO,IAAI,QAAQ,UAAU,IAAK,GAEtC,UAAU,GAAK,IAAK,UAAU,GAAI,OAAQ,EAAI,OAAS,QAgBzD,KAAK,QAAQ,EAAG,KAAO,EAAG,CAC5B,KAAM,aAAc,KAAK,cAAgB,GAAK,EAC9C,GAAI,IAAK,IAAI,UAAU,GAAK,KAAK,KAAK,EAAE,OAAS,QAAU,aAC3D,KAAO,IAAM,GACX,IAAI,OAAO,GAAI,GACf,GAAK,IAAI,UAAU,GAAK,KAAK,KAAK,EAAE,OAAS,QAAU,aAK3D,KAAM,YAAa,KAAK,QAAQ,EAAG,IACnC,OAAS,MAAO,EAAG,KAAO,WAAY,OAAQ,CAC5C,KAAM,GAAI,KAAK,QAAQ,EAAG,IAAI,OAAS,GACvC,AAAI,KAAK,cAGH,IAAI,GAAG,QAAU,QAAc,KAAM,GAAK,IAAI,EAAI,GAAG,QAAU,SACjE,KAAI,GAAK,IAAK,IAAI,GAAI,MAAO,SAK3B,IAAI,GAAG,QAAU,QAAc,KAAM,IAAI,OAAS,GAAK,IAAI,EAAI,GAAG,QAAU,SAC9E,KAAI,GAAK,IAAK,IAAI,GAAI,MAAO,SAKnC,MAAO,CAAE,SAAU,UAAW,KA7EhC,QAAA,2BAAA",
  "names": []
}
