{
  "version": 3,
  "sources": ["stage.ts"],
  "sourcesContent": ["import * as codebuild from '../../../aws-codebuild';\nimport * as codepipeline from '../../../aws-codepipeline';\nimport * as cpactions from '../../../aws-codepipeline-actions';\nimport { CodeBuildAction } from '../../../aws-codepipeline-actions';\nimport * as sns from '../../../aws-sns';\nimport { Stage, Aspects } from '../../../core';\nimport * as cxapi from '../../../cx-api';\nimport { Construct, Node } from 'constructs';\nimport { AssetType } from '../blueprint/asset-type';\nimport { ApplicationSecurityCheck } from '../private/application-security-check';\nimport { AssetManifestReader, DockerImageManifestEntry, FileManifestEntry } from '../private/asset-manifest';\nimport { pipelineSynth } from '../private/construct-internals';\nimport { topologicalSort } from '../private/toposort';\nimport { DeployCdkStackAction } from './actions';\nimport { CdkPipeline } from './pipeline';\n\n/**\n * Construction properties for a CdkStage\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface CdkStageProps {\n  /**\n   * Name of the stage that should be created\n   */\n  readonly stageName: string;\n\n  /**\n   * The underlying Pipeline Stage associated with thisCdkStage\n   */\n  readonly pipelineStage: codepipeline.IStage;\n\n  /**\n   * The CodePipeline Artifact with the Cloud Assembly\n   */\n  readonly cloudAssemblyArtifact: codepipeline.Artifact;\n\n  /**\n   * Features the Stage needs from its environment\n   */\n  readonly host: IStageHost;\n\n  /**\n   * Run a security check before every application prepare/deploy actions.\n   *\n   * Note: Stage level security check can be overriden per application as follows:\n   *   `stage.addApplication(app, { confirmBroadeningPermissions: false })`\n   *\n   * @default false\n   */\n  readonly confirmBroadeningPermissions?: boolean;\n\n  /**\n   * Optional SNS topic to send notifications to when any security check registers\n   * changes within a application.\n   *\n   * Note: The Stage Notification Topic can be overriden per application as follows:\n   *   `stage.addApplication(app, { securityNotificationTopic: newTopic })`\n   *\n   * @default undefined no stage level notification topic\n   */\n  readonly securityNotificationTopic?: sns.ITopic;\n}\n\n\n/**\n * Stage in a CdkPipeline\n *\n * You don't need to instantiate this class directly. Use\n * `cdkPipeline.addStage()` instead.\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport class CdkStage extends Construct {\n  private _nextSequentialRunOrder = 1; // Must start at 1 eh\n  private _manualApprovalCounter = 1;\n  private readonly pipelineStage: codepipeline.IStage;\n  private readonly cloudAssemblyArtifact: codepipeline.Artifact;\n  private readonly stacksToDeploy = new Array<DeployStackCommand>();\n  private readonly stageName: string;\n  private readonly host: IStageHost;\n  private readonly confirmBroadeningPermissions: boolean;\n  private readonly pipeline?: CdkPipeline;\n  private readonly securityNotificationTopic?: sns.ITopic;\n  private _applicationSecurityCheck?: ApplicationSecurityCheck;\n  private _prepared = false;\n\n  constructor(scope: Construct, id: string, props: CdkStageProps) {\n    super(scope, id);\n\n    if (scope instanceof CdkPipeline) {\n      this.pipeline = scope;\n    }\n\n    this.stageName = props.stageName;\n    this.pipelineStage = props.pipelineStage;\n    this.cloudAssemblyArtifact = props.cloudAssemblyArtifact;\n    this.host = props.host;\n    this.confirmBroadeningPermissions = props.confirmBroadeningPermissions ?? false;\n    this.securityNotificationTopic = props.securityNotificationTopic;\n\n    Aspects.of(this).add({ visit: () => this.prepareStage() });\n  }\n\n  /**\n   * Add all stacks in the application Stage to this stage\n   *\n   * The application construct should subclass `Stage` and can contain any\n   * number of `Stacks` inside it that may have dependency relationships\n   * on one another.\n   *\n   * All stacks in the application will be deployed in the appropriate order,\n   * and all assets found in the application will be added to the asset\n   * publishing stage.\n   */\n  public addApplication(appStage: Stage, options: AddStageOptions = {}) {\n    const asm = pipelineSynth(appStage);\n    const extraRunOrderSpace = options.extraRunOrderSpace ?? 0;\n\n    if (options.confirmBroadeningPermissions ?? this.confirmBroadeningPermissions) {\n      this.addSecurityCheck(appStage, options);\n    }\n\n    if (asm.stacks.length === 0) {\n      // If we don't check here, a more puzzling \"stage contains no actions\"\n      // error will be thrown come deployment time.\n      throw new Error(`The given Stage construct ('${appStage.node.path}') should contain at least one Stack`);\n    }\n\n    const sortedTranches = topologicalSort(asm.stacks,\n      stack => stack.id,\n      stack => stack.dependencies.map(d => d.id));\n\n    for (const stacks of sortedTranches) {\n      const runOrder = this.nextSequentialRunOrder(extraRunOrderSpace + 2); // 2 actions for Prepare/Execute ChangeSet\n      let executeRunOrder = runOrder + extraRunOrderSpace + 1;\n\n      // If we need to insert a manual approval action, then what's the executeRunOrder\n      // now is where we add a manual approval step, and we allocate 1 more runOrder\n      // for the execute.\n      if (options.manualApprovals) {\n        this.addManualApprovalAction({ runOrder: runOrder + 1 });\n        executeRunOrder = this.nextSequentialRunOrder();\n      }\n\n      // These don't have a dependency on each other, so can all be added in parallel\n      for (const stack of stacks) {\n        this.addStackArtifactDeployment(stack, { runOrder, executeRunOrder });\n      }\n    }\n  }\n\n  /**\n   * Get a cached version of an ApplicationSecurityCheck, which consists of:\n   *  - CodeBuild Project to check for security changes in a stage\n   *  - Lambda Function that approves the manual approval if no security changes are detected\n   *\n   * The ApplicationSecurityCheck is cached from the pipeline **if** this stage is scoped\n   * to a CDK Pipeline. If this stage **is not** scoped to a pipeline, create an ApplicationSecurityCheck\n   * scoped to the stage itself.\n   *\n   * @internal\n   */\n  private getApplicationSecurityCheck(): ApplicationSecurityCheck {\n    if (this._applicationSecurityCheck) {\n      return this._applicationSecurityCheck;\n    }\n\n    this._applicationSecurityCheck = this.pipeline\n      ? this.pipeline._getApplicationSecurityCheck()\n      : new ApplicationSecurityCheck(this, 'StageApplicationSecurityCheck', {\n        codePipeline: this.pipelineStage.pipeline as codepipeline.Pipeline,\n      });\n    return this._applicationSecurityCheck;\n  }\n\n  /**\n   * Add a deployment action based on a stack artifact\n   */\n  public addStackArtifactDeployment(stackArtifact: cxapi.CloudFormationStackArtifact, options: AddStackOptions = {}) {\n    // Get all assets manifests and add the assets in 'em to the asset publishing stage.\n    this.publishAssetDependencies(stackArtifact);\n\n    // Remember for later, see 'prepare()'\n    // We know that deploying a stack is going to take up 2 runorder slots later on.\n    const runOrder = options.runOrder ?? this.nextSequentialRunOrder(2);\n    const executeRunOrder = options.executeRunOrder ?? runOrder + 1;\n    this.stacksToDeploy.push({\n      prepareRunOrder: runOrder,\n      executeRunOrder,\n      stackArtifact,\n    });\n\n    this.advanceRunOrderPast(runOrder);\n    this.advanceRunOrderPast(executeRunOrder);\n  }\n\n  /**\n   * Add a manual approval action\n   *\n   * If you need more flexibility than what this method offers,\n   * use `addAction` with a `ManualApprovalAction`.\n   */\n  public addManualApprovalAction(options: AddManualApprovalOptions = {}) {\n    let actionName = options.actionName;\n    if (!actionName) {\n      actionName = `ManualApproval${this._manualApprovalCounter > 1 ? this._manualApprovalCounter : ''}`;\n      this._manualApprovalCounter += 1;\n    }\n\n    this.addActions(new cpactions.ManualApprovalAction({\n      actionName,\n      runOrder: options.runOrder ?? this.nextSequentialRunOrder(),\n    }));\n  }\n\n  /**\n   * Add one or more CodePipeline Actions\n   *\n   * You need to make sure it is created with the right runOrder. Call `nextSequentialRunOrder()`\n   * for every action to get actions to execute in sequence.\n   */\n  public addActions(...actions: codepipeline.IAction[]) {\n    for (const action of actions) {\n      this.pipelineStage.addAction(action);\n    }\n  }\n\n  /**\n   * Return the runOrder number necessary to run the next Action in sequence with the rest\n   *\n   * FIXME: This is here because Actions are immutable and can't be reordered\n   * after creation, nor is there a way to specify relative priorities, which\n   * is a limitation that we should take away in the base library.\n   */\n  public nextSequentialRunOrder(count: number = 1): number {\n    const ret = this._nextSequentialRunOrder;\n    this._nextSequentialRunOrder += count;\n    return ret;\n  }\n\n  /**\n   * Whether this Stage contains an action to deploy the given stack, identified by its artifact ID\n   */\n  public deploysStack(artifactId: string) {\n    return this.stacksToDeploy.map(s => s.stackArtifact.id).includes(artifactId);\n  }\n\n  /**\n   * Actually add all the DeployStack actions to the stage.\n   *\n   * We do this late because before we can render the actual DeployActions,\n   * we need to know whether or not we need to capture the stack outputs.\n   *\n   * FIXME: This is here because Actions are immutable and can't be reordered\n   * after creation, nor is there a way to specify relative priorities, which\n   * is a limitation that we should take away in the base library.\n   */\n  private prepareStage() {\n    // FIXME: Make sure this only gets run once. There seems to be an issue in the reconciliation\n    // loop that may trigger this more than once if it throws an error somewhere, and the exception\n    // that gets thrown here will then override the actual failure.\n    if (this._prepared) { return; }\n    this._prepared = true;\n\n    for (const { prepareRunOrder, stackArtifact, executeRunOrder } of this.stacksToDeploy) {\n      const artifact = this.host.stackOutputArtifact(stackArtifact.id);\n\n      this.pipelineStage.addAction(DeployCdkStackAction.fromStackArtifact(this, stackArtifact, {\n        baseActionName: this.simplifyStackName(stackArtifact.stackName),\n        cloudAssemblyInput: this.cloudAssemblyArtifact,\n        output: artifact,\n        outputFileName: artifact ? 'outputs.json' : undefined,\n        prepareRunOrder,\n        executeRunOrder,\n      }));\n    }\n  }\n\n  /**\n   * Advance the runorder counter so that the next sequential number is higher than the given one\n   */\n  private advanceRunOrderPast(lastUsed: number) {\n    this._nextSequentialRunOrder = Math.max(lastUsed + 1, this._nextSequentialRunOrder);\n  }\n\n  /**\n   * Simplify the stack name by removing the `Stage-` prefix if it exists.\n   */\n  private simplifyStackName(s: string) {\n    return stripPrefix(s, `${this.stageName}-`);\n  }\n\n  /**\n   * Add a security check before the prepare/deploy actions of an CDK stage.\n   * The security check consists of two actions:\n   *  - CodeBuild Action to check for security changes in a stage\n   *  - Manual Approval Action that is auto approved via a Lambda if no security changes detected\n   */\n  private addSecurityCheck(appStage: Stage, options?: BaseStageOptions) {\n    const { cdkDiffProject } = this.getApplicationSecurityCheck();\n    const notificationTopic: sns.ITopic | undefined = options?.securityNotificationTopic ?? this.securityNotificationTopic;\n    notificationTopic?.grantPublish(cdkDiffProject);\n\n    const appStageName = appStage.stageName;\n    const approveActionName = `${appStageName}ManualApproval`;\n    const diffAction = new CodeBuildAction({\n      runOrder: this.nextSequentialRunOrder(),\n      actionName: `${appStageName}SecurityCheck`,\n      input: this.cloudAssemblyArtifact,\n      project: cdkDiffProject,\n      variablesNamespace: `${appStageName}SecurityCheck`,\n      environmentVariables: {\n        STAGE_PATH: {\n          value: Node.of(appStage).path,\n          type: codebuild.BuildEnvironmentVariableType.PLAINTEXT,\n        },\n        STAGE_NAME: {\n          value: this.stageName,\n          type: codebuild.BuildEnvironmentVariableType.PLAINTEXT,\n        },\n        ACTION_NAME: {\n          value: approveActionName,\n          type: codebuild.BuildEnvironmentVariableType.PLAINTEXT,\n        },\n        ...notificationTopic ? {\n          NOTIFICATION_ARN: {\n            value: notificationTopic.topicArn,\n            type: codebuild.BuildEnvironmentVariableType.PLAINTEXT,\n          },\n          NOTIFICATION_SUBJECT: {\n            value: `Confirm permission broadening in ${appStageName}`,\n            type: codebuild.BuildEnvironmentVariableType.PLAINTEXT,\n          },\n        } : {},\n      },\n    });\n\n    const approve = new cpactions.ManualApprovalAction({\n      actionName: approveActionName,\n      runOrder: this.nextSequentialRunOrder(),\n      additionalInformation: `#{${appStageName}SecurityCheck.MESSAGE}`,\n      externalEntityLink: `#{${appStageName}SecurityCheck.LINK}`,\n    });\n\n    this.addActions(diffAction, approve);\n  }\n\n  /**\n   * Make sure all assets depended on by this stack are published in this pipeline\n   *\n   * Taking care to exclude the stack template itself -- it is being published\n   * as an asset because the CLI needs to know the asset publishing role when\n   * pushing the template to S3, but in the case of CodePipeline we always\n   * reference the template from the artifact bucket.\n   *\n   * (NOTE: this is only true for top-level stacks, not nested stacks. Nested\n   * Stack templates are always published as assets).\n   */\n  private publishAssetDependencies(stackArtifact: cxapi.CloudFormationStackArtifact) {\n    const assetManifests = stackArtifact.dependencies.filter(isAssetManifest);\n\n    for (const manifestArtifact of assetManifests) {\n      const manifest = AssetManifestReader.fromFile(manifestArtifact.file);\n\n      for (const entry of manifest.entries) {\n        let assetType: AssetType;\n        if (entry instanceof DockerImageManifestEntry) {\n          assetType = AssetType.DOCKER_IMAGE;\n        } else if (entry instanceof FileManifestEntry) {\n          // Don't publish the template for this stack\n          if (entry.source.packaging === 'file' && entry.source.path === stackArtifact.templateFile) {\n            continue;\n          }\n\n          assetType = AssetType.FILE;\n        } else {\n          throw new Error(`Unrecognized asset type: ${entry.type}`);\n        }\n\n        if (!entry.destination.assumeRoleArn) {\n          throw new Error('assumeRoleArn is missing on asset and required');\n        }\n\n        this.host.publishAsset({\n          assetManifestPath: manifestArtifact.file,\n          assetId: entry.id.assetId,\n          assetSelector: entry.id.toString(),\n          assetType,\n          assetPublishingRoleArn: entry.destination.assumeRoleArn,\n        });\n      }\n    }\n  }\n}\n\n/**\n * Additional options for adding a stack deployment\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface AddStackOptions {\n  /**\n   * Base runorder\n   *\n   * @default - Next sequential runorder\n   */\n  readonly runOrder?: number;\n\n  /**\n   * Base runorder\n   *\n   * @default - runOrder + 1\n   */\n  readonly executeRunOrder?: number;\n}\n\n/**\n * A single output of a Stack\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport class StackOutput {\n  /**\n   * The artifact and file the output is stored in\n   */\n  public readonly artifactFile: codepipeline.ArtifactPath;\n\n  /**\n   * The name of the output in the JSON object in the file\n   */\n  public readonly outputName: string;\n\n  /**\n   * Build a StackOutput from a known artifact and an output name\n   */\n  constructor(artifactFile: codepipeline.ArtifactPath, outputName: string) {\n    this.artifactFile = artifactFile;\n    this.outputName = outputName;\n  }\n}\n\nfunction stripPrefix(s: string, prefix: string) {\n  return s.startsWith(prefix) ? s.substr(prefix.length) : s;\n}\n\nfunction isAssetManifest(s: cxapi.CloudArtifact): s is cxapi.AssetManifestArtifact {\n  // instanceof is too risky, and we're at a too late stage to properly fix.\n  // return s instanceof cxapi.AssetManifestArtifact;\n  return s.constructor.name === 'AssetManifestArtifact';\n}\n\n/**\n * Features that the Stage needs from its environment\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface IStageHost {\n  /**\n   * Make sure all the assets from the given manifest are published\n   */\n  publishAsset(command: AssetPublishingCommand): void;\n\n  /**\n   * Return the Artifact the given stack has to emit its outputs into, if any\n   */\n  stackOutputArtifact(stackArtifactId: string): codepipeline.Artifact | undefined;\n}\n\n/**\n * Instructions to publish certain assets\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface AssetPublishingCommand {\n  /**\n   * Asset manifest path\n   */\n  readonly assetManifestPath: string;\n\n  /**\n   * Asset identifier\n   */\n  readonly assetId: string;\n\n  /**\n   * Asset selector to pass to `cdk-assets`.\n   */\n  readonly assetSelector: string;\n\n  /**\n   * Type of asset to publish\n   */\n  readonly assetType: AssetType;\n\n  /**\n   * ARN of the IAM Role used to publish this asset.\n   */\n  readonly assetPublishingRoleArn: string;\n}\n\n/**\n * Base options for a pipelines stage\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface BaseStageOptions {\n  /**\n   * Runs a `cdk diff --security-only --fail` to pause the pipeline if there\n   * are any security changes.\n   *\n   * If the stage is configured with `confirmBroadeningPermissions` enabled, you can use this\n   * property to override the stage configuration. For example, Pipeline Stage\n   * \"Prod\" has confirmBroadeningPermissions enabled, with applications \"A\", \"B\", \"C\". All three\n   * applications will run a security check, but if we want to disable the one for \"C\",\n   * we run `stage.addApplication(C, { confirmBroadeningPermissions: false })` to override the pipeline\n   * stage behavior.\n   *\n   * Adds 1 to the run order space.\n   *\n   * @default false\n   */\n  readonly confirmBroadeningPermissions?: boolean;\n  /**\n   * Optional SNS topic to send notifications to when the security check registers\n   * changes within the application.\n   *\n   * @default undefined no notification topic for security check manual approval action\n   */\n  readonly securityNotificationTopic?: sns.ITopic;\n}\n\n/**\n * Options for adding an application stage to a pipeline\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface AddStageOptions extends BaseStageOptions {\n  /**\n   * Add manual approvals before executing change sets\n   *\n   * This gives humans the opportunity to confirm the change set looks alright\n   * before deploying it.\n   *\n   * @default false\n   */\n  readonly manualApprovals?: boolean;\n  /**\n   * Add room for extra actions\n   *\n   * You can use this to make extra room in the runOrder sequence between the\n   * changeset 'prepare' and 'execute' actions and insert your own actions there.\n   *\n   * @default 0\n   */\n  readonly extraRunOrderSpace?: number;\n}\n\n/**\n * Options for addManualApproval\n *\n * @deprecated This class is part of the old API. Use the API based on the `CodePipeline` class instead\n */\nexport interface AddManualApprovalOptions {\n  /**\n   * The name of the manual approval action\n   *\n   * @default 'ManualApproval' with a rolling counter\n   */\n  readonly actionName?: string;\n\n  /**\n   * The runOrder for this action\n   *\n   * @default - The next sequential runOrder\n   */\n  readonly runOrder?: number;\n}\n\n/**\n * Queued \"deploy stack\" command that is reified during prepare()\n */\ninterface DeployStackCommand {\n  prepareRunOrder: number;\n  executeRunOrder: number;\n  stackArtifact: cxapi.CloudFormationStackArtifact;\n}\n"],
  "mappings": "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",
  "names": []
}
