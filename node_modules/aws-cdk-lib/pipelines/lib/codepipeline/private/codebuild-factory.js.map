{
  "version": 3,
  "sources": ["codebuild-factory.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport * as codebuild from '../../../../aws-codebuild';\nimport * as codepipeline from '../../../../aws-codepipeline';\nimport * as codepipeline_actions from '../../../../aws-codepipeline-actions';\nimport * as ec2 from '../../../../aws-ec2';\nimport * as iam from '../../../../aws-iam';\nimport { Stack, Token } from '../../../../core';\nimport { Construct, IDependable, Node } from 'constructs';\nimport { FileSetLocation, ShellStep, StackOutputReference } from '../../blueprint';\nimport { PipelineQueries } from '../../helpers-internal/pipeline-queries';\nimport { StepOutput } from '../../helpers-internal/step-output';\nimport { cloudAssemblyBuildSpecDir, obtainScope } from '../../private/construct-internals';\nimport { hash, stackVariableNamespace } from '../../private/identifiers';\nimport { mapValues, mkdict, noEmptyObject, noUndefined, partition } from '../../private/javascript';\nimport { ArtifactMap } from '../artifact-map';\nimport { CodeBuildStep } from '../codebuild-step';\nimport { CodeBuildOptions } from '../codepipeline';\nimport { ICodePipelineActionFactory, ProduceActionOptions, CodePipelineActionFactoryResult } from '../codepipeline-action-factory';\nimport { mergeBuildSpecs } from './buildspecs';\n\nexport interface CodeBuildFactoryProps {\n  /**\n   * Name for the generated CodeBuild project\n   *\n   * @default - Automatically generated\n   */\n  readonly projectName?: string;\n\n  /**\n   * Customization options for the project\n   *\n   * Will at CodeBuild production time be combined with the option\n   * defaults configured on the pipeline.\n   *\n   * @default - No special values\n   */\n  readonly projectOptions?: CodeBuildOptions;\n\n  /**\n   * Custom execution role to be used for the CodeBuild project\n   *\n   * @default - A role is automatically created\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * If true, the build spec will be passed via the Cloud Assembly instead of rendered onto the Project\n   *\n   * Doing this has two advantages:\n   *\n   * - Bypass size restrictions: the buildspec on the project is restricted\n   *   in size, while buildspecs coming from an input artifact are not restricted\n   *   in such a way.\n   * - Bypass pipeline update: if the SelfUpdate step has to change the buildspec,\n   *   that just takes time. On the other hand, if the buildspec comes from the\n   *   pipeline artifact, no such update has to take place.\n   *\n   * @default false\n   */\n  readonly passBuildSpecViaCloudAssembly?: boolean;\n\n  /**\n   * Override the construct tree where the CodeBuild project is created.\n   *\n   * Normally, the construct tree will look like this:\n   *\n   *  \u2500\u2500 Pipeline\n   *      \u2514\u2500\u2500 'MyStage'         <- options.scope\n   *           \u2514\u2500\u2500 'MyAction'   <- this is the CodeBuild project\n   *\n   * If this flag is set, the construct tree will look like this:\n   *\n   *  \u2500\u2500 Pipeline\n   *      \u2514\u2500\u2500 'MyStage'                         <- options.scope\n   *           \u2514\u2500\u2500 'MyAction'                   <- just a scope\n   *                  \u2514\u2500\u2500 'BackwardsCompatName' <- CodeBuild project\n   *\n   * This is to maintain logicalID compatibility with the previous iteration\n   * of pipelines (where the Action was a construct that would create the Project).\n   *\n   * @default true\n   */\n  readonly additionalConstructLevel?: boolean;\n\n  /**\n   * Additional dependency that the CodeBuild project should take\n   *\n   * @default -\n   */\n  readonly additionalDependable?: IDependable;\n\n  readonly inputs?: FileSetLocation[];\n  readonly outputs?: FileSetLocation[];\n\n  readonly stepId?: string;\n\n  readonly commands: string[];\n  readonly installCommands?: string[];\n\n  readonly env?: Record<string, string>;\n  readonly envFromCfnOutputs?: Record<string, StackOutputReference>;\n\n  /**\n   * If given, override the scope from the produce call with this scope.\n   */\n  readonly scope?: Construct;\n\n  /**\n   * Whether or not the given CodeBuild project is going to be the synth step\n   *\n   * @default false\n   */\n  readonly isSynth?: boolean;\n\n  /**\n   * StepOutputs produced by this CodeBuild step\n   */\n  readonly producedStepOutputs?: StepOutput[];\n}\n\n/**\n * Produce a CodeBuild project from a ShellStep and some CodeBuild-specific customizations\n *\n * The functionality here is shared between the `CodePipeline` translating a `ShellStep` into\n * a CodeBuild project, as well as the `CodeBuildStep` straight up.\n */\nexport class CodeBuildFactory implements ICodePipelineActionFactory {\n  // eslint-disable-next-line max-len\n  public static fromShellStep(constructId: string, shellStep: ShellStep, additional?: Partial<CodeBuildFactoryProps>): ICodePipelineActionFactory {\n    return new CodeBuildFactory(constructId, {\n      commands: shellStep.commands,\n      env: shellStep.env,\n      envFromCfnOutputs: shellStep.envFromCfnOutputs,\n      inputs: shellStep.inputs,\n      outputs: shellStep.outputs,\n      stepId: shellStep.id,\n      installCommands: shellStep.installCommands,\n      producedStepOutputs: StepOutput.producedStepOutputs(shellStep),\n      ...additional,\n    });\n  }\n\n  public static fromCodeBuildStep(constructId: string, step: CodeBuildStep, additional?: Partial<CodeBuildFactoryProps>): ICodePipelineActionFactory {\n    const factory = CodeBuildFactory.fromShellStep(constructId, step, {\n      projectName: step.projectName,\n      role: step.role,\n      ...additional,\n      projectOptions: mergeCodeBuildOptions(additional?.projectOptions, {\n        buildEnvironment: step.buildEnvironment,\n        rolePolicy: step.rolePolicyStatements,\n        securityGroups: step.securityGroups,\n        partialBuildSpec: step.partialBuildSpec,\n        vpc: step.vpc,\n        subnetSelection: step.subnetSelection,\n        timeout: step.timeout,\n      }),\n    });\n\n    return {\n      produceAction: (stage, options) => {\n        const result = factory.produceAction(stage, options);\n        if (result.project) {\n          step._setProject(result.project);\n        }\n        return result;\n      },\n    };\n  }\n\n  private _project?: codebuild.IProject;\n  private stepId: string;\n\n  private constructor(\n    private readonly constructId: string,\n    private readonly props: CodeBuildFactoryProps) {\n\n    this.stepId = props.stepId ?? constructId;\n  }\n\n  public get project(): codebuild.IProject {\n    if (!this._project) {\n      throw new Error('Project becomes available after produce() has been called');\n    }\n    return this._project;\n  }\n\n  public produceAction(stage: codepipeline.IStage, options: ProduceActionOptions): CodePipelineActionFactoryResult {\n    const projectOptions = mergeCodeBuildOptions(options.codeBuildDefaults, this.props.projectOptions);\n\n    const inputs = this.props.inputs ?? [];\n    const outputs = this.props.outputs ?? [];\n\n    const mainInput = inputs.find(x => x.directory === '.');\n    const extraInputs = inputs.filter(x => x.directory !== '.');\n\n    const inputArtifact = mainInput\n      ? options.artifacts.toCodePipeline(mainInput.fileSet)\n      : options.fallbackArtifact;\n    const extraInputArtifacts = extraInputs.map(x => options.artifacts.toCodePipeline(x.fileSet));\n    const outputArtifacts = outputs.map(x => options.artifacts.toCodePipeline(x.fileSet));\n\n    if (!inputArtifact) {\n      // This should actually never happen because CodeBuild projects shouldn't be added before the\n      // Source, which always produces at least an artifact.\n      throw new Error(`CodeBuild action '${this.stepId}' requires an input (and the pipeline doesn't have a Source to fall back to). Add an input or a pipeline source.`);\n    }\n\n    const installCommands = [\n      ...generateInputArtifactLinkCommands(options.artifacts, extraInputs),\n      ...this.props.installCommands ?? [],\n    ];\n\n    const buildSpecHere = codebuild.BuildSpec.fromObject({\n      version: '0.2',\n      phases: {\n        install: (installCommands.length ?? 0) > 0 ? { commands: installCommands } : undefined,\n        build: this.props.commands.length > 0 ? { commands: this.props.commands } : undefined,\n      },\n      artifacts: noEmptyObject<any>(renderArtifactsBuildSpec(options.artifacts, this.props.outputs ?? [])),\n    });\n\n    // Partition environment variables into environment variables that can go on the project\n    // and environment variables that MUST go in the pipeline (those that reference CodePipeline variables)\n    const env = noUndefined(this.props.env ?? {});\n\n    const [actionEnvs, projectEnvs] = partition(Object.entries(env ?? {}), ([, v]) => containsPipelineVariable(v));\n\n    const environment = mergeBuildEnvironments(\n      projectOptions?.buildEnvironment ?? {},\n      {\n        environmentVariables: noEmptyObject(mapValues(mkdict(projectEnvs), value => ({ value }))),\n      });\n\n    const fullBuildSpec = projectOptions?.partialBuildSpec\n      ? codebuild.mergeBuildSpecs(projectOptions.partialBuildSpec, buildSpecHere)\n      : buildSpecHere;\n\n    const osFromEnvironment = environment.buildImage && environment.buildImage instanceof codebuild.WindowsBuildImage\n      ? ec2.OperatingSystemType.WINDOWS\n      : ec2.OperatingSystemType.LINUX;\n\n    const actualBuildSpec = filterBuildSpecCommands(fullBuildSpec, osFromEnvironment);\n\n    const scope = this.props.scope ?? options.scope;\n\n    let projectBuildSpec;\n    if (this.props.passBuildSpecViaCloudAssembly) {\n      // Write to disk and replace with a reference\n      const relativeSpecFile = `buildspec-${Node.of(scope).addr}-${this.constructId}.yaml`;\n      const absSpecFile = path.join(cloudAssemblyBuildSpecDir(scope), relativeSpecFile);\n\n      // This should resolve to a pure JSON string. If it resolves to an object, it's a CFN\n      // expression, and we can't support that yet. Maybe someday if we think really hard about it.\n      const fileContents = Stack.of(scope).resolve(actualBuildSpec.toBuildSpec());\n\n      if (typeof fileContents !== 'string') {\n        throw new Error(`This BuildSpec contains CloudFormation references and is supported by publishInParallel=false: ${JSON.stringify(fileContents, undefined, 2)}`);\n      }\n      fs.writeFileSync(absSpecFile, fileContents, { encoding: 'utf-8' });\n      projectBuildSpec = codebuild.BuildSpec.fromSourceFilename(relativeSpecFile);\n    } else {\n      projectBuildSpec = actualBuildSpec;\n    }\n\n    // A hash over the values that make the CodeBuild Project unique (and necessary\n    // to restart the pipeline if one of them changes). projectName is not necessary to include\n    // here because the pipeline will definitely restart if projectName changes.\n    // (Resolve tokens)\n    const projectConfigHash = hash(Stack.of(scope).resolve({\n      environment: serializeBuildEnvironment(environment),\n      buildSpecString: actualBuildSpec.toBuildSpec(),\n    }));\n\n    const actionName = options.actionName ?? this.stepId;\n\n    let projectScope = scope;\n    if (this.props.additionalConstructLevel ?? true) {\n      projectScope = obtainScope(scope, actionName);\n    }\n\n    const safePipelineName = Token.isUnresolved(options.pipeline.pipeline.pipelineName)\n      ? `${Stack.of(options.pipeline).stackName}/${Node.of(options.pipeline.pipeline).id}`\n      : options.pipeline.pipeline.pipelineName;\n\n    const project = new codebuild.PipelineProject(projectScope, this.constructId, {\n      projectName: this.props.projectName,\n      description: `Pipeline step ${safePipelineName}/${stage.stageName}/${actionName}`.substring(0, 255),\n      environment,\n      vpc: projectOptions.vpc,\n      subnetSelection: projectOptions.subnetSelection,\n      securityGroups: projectOptions.securityGroups,\n      buildSpec: projectBuildSpec,\n      role: this.props.role,\n      timeout: projectOptions.timeout,\n    });\n\n    if (this.props.additionalDependable) {\n      project.node.addDependency(this.props.additionalDependable);\n    }\n\n    if (projectOptions.rolePolicy !== undefined) {\n      projectOptions.rolePolicy.forEach(policyStatement => {\n        project.addToRolePolicy(policyStatement);\n      });\n    }\n\n    const queries = new PipelineQueries(options.pipeline);\n\n    const stackOutputEnv = mapValues(this.props.envFromCfnOutputs ?? {}, outputRef =>\n      `#{${stackVariableNamespace(queries.producingStack(outputRef))}.${outputRef.outputName}}`,\n    );\n\n    const configHashEnv = options.beforeSelfMutation\n      ? { _PROJECT_CONFIG_HASH: projectConfigHash }\n      : {};\n\n    stage.addAction(new codepipeline_actions.CodeBuildAction({\n      actionName: actionName,\n      input: inputArtifact,\n      extraInputs: extraInputArtifacts,\n      outputs: outputArtifacts,\n      project,\n      runOrder: options.runOrder,\n      variablesNamespace: options.variablesNamespace,\n\n      // Inclusion of the hash here will lead to the pipeline structure for any changes\n      // made the config of the underlying CodeBuild Project.\n      // Hence, the pipeline will be restarted. This is necessary if the users\n      // adds (for example) build or test commands to the buildspec.\n      environmentVariables: noEmptyObject(cbEnv({\n        ...mkdict(actionEnvs),\n        ...configHashEnv,\n        ...stackOutputEnv,\n      })),\n    }));\n\n    this._project = project;\n\n    return { runOrdersConsumed: 1, project };\n  }\n}\n\n/**\n * Generate commands to move additional input artifacts into the right place\n */\nfunction generateInputArtifactLinkCommands(artifacts: ArtifactMap, inputs: FileSetLocation[]): string[] {\n  return inputs.map(input => {\n    const fragments = [];\n\n    fragments.push(`[ ! -d \"${input.directory}\" ] || { echo 'additionalInputs: \"${input.directory}\" must not exist yet. If you want to merge multiple artifacts, use a \"cp\" command.'; exit 1; }`);\n\n    const parentDirectory = path.dirname(input.directory);\n    if (!['.', '..'].includes(parentDirectory)) {\n      fragments.push(`mkdir -p -- \"${parentDirectory}\"`);\n    }\n\n    const artifact = artifacts.toCodePipeline(input.fileSet);\n\n    fragments.push(`ln -s -- \"$CODEBUILD_SRC_DIR_${artifact.artifactName}\" \"${input.directory}\"`);\n\n    return fragments.join(' && ');\n  });\n}\n\nfunction renderArtifactsBuildSpec(artifactMap: ArtifactMap, outputs: FileSetLocation[]) {\n  // save the generated files in the output artifact\n  // This part of the buildspec has to look completely different depending on whether we're\n  // using secondary artifacts or not.\n  if (outputs.length === 0) { return {}; }\n\n  if (outputs.length === 1) {\n    return {\n      'base-directory': outputs[0].directory,\n      'files': '**/*',\n    };\n  }\n\n  const secondary: Record<string, any> = {};\n  for (const output of outputs) {\n    const art = artifactMap.toCodePipeline(output.fileSet);\n\n    if (!art.artifactName) {\n      throw new Error('You must give the output artifact a name');\n    }\n    secondary[art.artifactName] = {\n      'base-directory': output.directory,\n      'files': '**/*',\n    };\n  }\n\n  return { 'secondary-artifacts': secondary };\n}\n\nexport function mergeCodeBuildOptions(...opts: Array<CodeBuildOptions | undefined>) {\n  const xs = [{}, ...opts.filter(isDefined)];\n  while (xs.length > 1) {\n    const [a, b] = xs.splice(xs.length - 2, 2);\n    xs.push(merge2(a, b));\n  }\n  return xs[0];\n\n  function merge2(a: CodeBuildOptions, b: CodeBuildOptions): CodeBuildOptions {\n    return {\n      buildEnvironment: mergeBuildEnvironments(a.buildEnvironment, b.buildEnvironment),\n      rolePolicy: definedArray([...a.rolePolicy ?? [], ...b.rolePolicy ?? []]),\n      securityGroups: definedArray([...a.securityGroups ?? [], ...b.securityGroups ?? []]),\n      partialBuildSpec: mergeBuildSpecs(a.partialBuildSpec, b.partialBuildSpec),\n      vpc: b.vpc ?? a.vpc,\n      subnetSelection: b.subnetSelection ?? a.subnetSelection,\n      timeout: b.timeout ?? a.timeout,\n    };\n  }\n}\n\nfunction mergeBuildEnvironments(a: codebuild.BuildEnvironment, b?: codebuild.BuildEnvironment): codebuild.BuildEnvironment;\nfunction mergeBuildEnvironments(a: codebuild.BuildEnvironment | undefined, b: codebuild.BuildEnvironment): codebuild.BuildEnvironment;\nfunction mergeBuildEnvironments(a?: codebuild.BuildEnvironment, b?: codebuild.BuildEnvironment): codebuild.BuildEnvironment | undefined;\nfunction mergeBuildEnvironments(a?: codebuild.BuildEnvironment, b?: codebuild.BuildEnvironment) {\n  if (!a || !b) { return a ?? b; }\n\n  return {\n    buildImage: b.buildImage ?? a.buildImage,\n    computeType: b.computeType ?? a.computeType,\n    environmentVariables: {\n      ...a.environmentVariables,\n      ...b.environmentVariables,\n    },\n    privileged: b.privileged ?? a.privileged,\n  };\n}\n\nfunction isDefined<A>(x: A | undefined): x is NonNullable<A> {\n  return x !== undefined;\n}\n\n/**\n * Serialize a build environment to data (get rid of constructs & objects), so we can JSON.stringify it\n */\nfunction serializeBuildEnvironment(env: codebuild.BuildEnvironment) {\n  return {\n    privileged: env.privileged,\n    environmentVariables: env.environmentVariables,\n    type: env.buildImage?.type,\n    imageId: env.buildImage?.imageId,\n    computeType: env.computeType,\n    imagePullPrincipalType: env.buildImage?.imagePullPrincipalType,\n    secretsManagerArn: env.buildImage?.secretsManagerCredentials?.secretArn,\n  };\n}\n\n/**\n * Whether the given string contains a reference to a CodePipeline variable\n */\nfunction containsPipelineVariable(s: string) {\n  return !!s.match(/#\\{[^}]+\\}/) || StepOutput.findAll(s).length > 0;\n}\n\n/**\n * Turn a collection into a collection of CodePipeline environment variables\n */\nfunction cbEnv(xs: Record<string, string | undefined>): Record<string, codebuild.BuildEnvironmentVariable> {\n  return mkdict(Object.entries(xs)\n    .filter(([, v]) => v !== undefined)\n    .map(([k, v]) => [k, { value: v }] as const));\n}\n\nfunction definedArray<A>(xs: A[]): A[] | undefined {\n  return xs.length > 0 ? xs : undefined;\n}\n\n/**\n * If lines in the buildspec start with '!WINDOWS!' or '!LINUX!', only render them on that platform.\n *\n * Very private protocol for now, but may come in handy in other libraries as well.\n */\nfunction filterBuildSpecCommands(buildSpec: codebuild.BuildSpec, osType: ec2.OperatingSystemType) {\n  if (!buildSpec.isImmediate) { return buildSpec; }\n  const spec = (buildSpec as any).spec;\n\n  const winTag = '!WINDOWS!';\n  const linuxTag = '!LINUX!';\n  const expectedTag = osType === ec2.OperatingSystemType.WINDOWS ? winTag : linuxTag;\n\n  return codebuild.BuildSpec.fromObject(recurse(spec));\n\n  function recurse(x: any): any {\n    if (Array.isArray(x)) {\n      const ret: any[] = [];\n      for (const el of x) {\n        const [tag, payload] = extractTag(el);\n        if (tag === undefined || tag === expectedTag) {\n          ret.push(payload);\n        }\n      }\n      return ret;\n    }\n    if (x && typeof x === 'object') {\n      return mapValues(x, recurse);\n    }\n    return x;\n  }\n\n  function extractTag(x: any): [string | undefined, any] {\n    if (typeof x !== 'string') { return [undefined, x]; }\n    for (const tag of [winTag, linuxTag]) {\n      if (x.startsWith(tag)) { return [tag, x.substr(tag.length)]; }\n    }\n    return [undefined, x];\n  }\n}\n"],
  "mappings": "kIAAA,KAAA,IAAA,QAAA,MACA,KAAA,QAAA,QACA,UAAA,QAAA,6BAEA,qBAAA,QAAA,wCACA,IAAA,QAAA,uBAEA,OAAA,QAAA,oBACA,aAAA,QAAA,cAEA,mBAAA,QAAA,2CACA,cAAA,QAAA,sCACA,sBAAA,QAAA,qCACA,cAAA,QAAA,6BACA,aAAA,QAAA,4BAKA,aAAA,QAAA,gBA4GA,sBAA6B,CA8C3B,YACmB,YACA,MAA4B,QAD5B,KAAA,YAAA,YACA,KAAA,MAAA,MAEjB,KAAK,OAAM,IAAG,MAAM,UAAM,MAAA,KAAA,OAAA,GAAI,kBAhDlB,eAAc,YAAqB,UAAsB,WAA2C,CAChH,MAAO,IAAI,kBAAiB,YAAa,CACvC,SAAU,UAAU,SACpB,IAAK,UAAU,IACf,kBAAmB,UAAU,kBAC7B,OAAQ,UAAU,OAClB,QAAS,UAAU,QACnB,OAAQ,UAAU,GAClB,gBAAiB,UAAU,gBAC3B,oBAAqB,cAAA,WAAW,oBAAoB,cACjD,mBAIO,mBAAkB,YAAqB,KAAqB,WAA2C,CACnH,KAAM,SAAU,iBAAiB,cAAc,YAAa,KAAM,CAChE,YAAa,KAAK,YAClB,KAAM,KAAK,QACR,WACH,eAAgB,sBAAsB,YAAU,KAAA,OAAV,WAAY,eAAgB,CAChE,iBAAkB,KAAK,iBACvB,WAAY,KAAK,qBACjB,eAAgB,KAAK,eACrB,iBAAkB,KAAK,iBACvB,IAAK,KAAK,IACV,gBAAiB,KAAK,gBACtB,QAAS,KAAK,YAIlB,MAAO,CACL,cAAe,CAAC,MAAO,UAAW,CAChC,KAAM,QAAS,QAAQ,cAAc,MAAO,SAC5C,MAAI,QAAO,SACT,KAAK,YAAY,OAAO,SAEnB,YAeF,UAAO,CAChB,GAAI,CAAC,KAAK,SACR,KAAM,IAAI,OAAM,6DAElB,MAAO,MAAK,SAGP,cAAc,MAA4B,QAA6B,sCAC5E,KAAM,gBAAiB,sBAAsB,QAAQ,kBAAmB,KAAK,MAAM,gBAE7E,OAAM,IAAG,KAAK,MAAM,UAAM,MAAA,KAAA,OAAA,GAAI,GAC9B,QAAO,IAAG,KAAK,MAAM,WAAO,MAAA,KAAA,OAAA,GAAI,GAEhC,UAAY,OAAO,KAAK,GAAK,EAAE,YAAc,KAC7C,YAAc,OAAO,OAAO,GAAK,EAAE,YAAc,KAEjD,cAAgB,UAClB,QAAQ,UAAU,eAAe,UAAU,SAC3C,QAAQ,iBACN,oBAAsB,YAAY,IAAI,GAAK,QAAQ,UAAU,eAAe,EAAE,UAC9E,gBAAkB,QAAQ,IAAI,GAAK,QAAQ,UAAU,eAAe,EAAE,UAE5E,GAAI,CAAC,cAGH,KAAM,IAAI,OAAM,qBAAqB,KAAK,0HAG5C,KAAM,iBAAkB,CACtB,GAAG,kCAAkC,QAAQ,UAAW,aACxD,GAAA,IAAG,KAAK,MAAM,mBAAe,MAAA,KAAA,OAAA,GAAI,IAG7B,cAAgB,UAAU,UAAU,WAAW,CACnD,QAAS,MACT,OAAQ,CACN,QAAS,KAAC,gBAAgB,UAAM,MAAA,KAAA,OAAA,GAAI,GAAK,EAAI,CAAE,SAAU,iBAAoB,OAC7E,MAAO,KAAK,MAAM,SAAS,OAAS,EAAI,CAAE,SAAU,KAAK,MAAM,UAAa,QAE9E,UAAW,aAAA,cAAmB,yBAAyB,QAAQ,UAAS,IAAE,KAAK,MAAM,WAAO,MAAA,KAAA,OAAA,GAAI,OAK5F,IAAM,aAAA,YAAW,IAAC,KAAK,MAAM,OAAG,MAAA,KAAA,OAAA,GAAI,IAEpC,CAAC,WAAY,aAAe,aAAA,UAAU,OAAO,QAAQ,KAAG,KAAH,IAAO,IAAK,CAAC,CAAC,CAAE,KAAO,yBAAyB,IAErG,YAAc,uBAAsB,IACxC,gBAAc,KAAA,OAAd,eAAgB,oBAAgB,MAAA,KAAA,OAAA,GAAI,GACpC,CACE,qBAAsB,aAAA,cAAc,aAAA,UAAU,aAAA,OAAO,aAAc,OAAU,EAAE,YAG7E,cAAgB,iBAAc,KAAA,OAAd,eAAgB,kBAClC,UAAU,gBAAgB,eAAe,iBAAkB,eAC3D,cAEE,kBAAoB,YAAY,YAAc,YAAY,qBAAsB,WAAU,kBAC5F,IAAI,oBAAoB,QACxB,IAAI,oBAAoB,MAEtB,gBAAkB,wBAAwB,cAAe,mBAEzD,MAAK,IAAG,KAAK,MAAM,SAAK,MAAA,KAAA,OAAA,GAAI,QAAQ,MAE1C,GAAI,kBACJ,GAAI,KAAK,MAAM,8BAA+B,CAE5C,KAAM,kBAAmB,aAAa,aAAA,KAAK,GAAG,OAAO,QAAQ,KAAK,mBAC5D,YAAc,KAAK,KAAK,sBAAA,0BAA0B,OAAQ,kBAI1D,aAAe,OAAA,MAAM,GAAG,OAAO,QAAQ,gBAAgB,eAE7D,GAAI,MAAO,eAAiB,SAC1B,KAAM,IAAI,OAAM,kGAAkG,KAAK,UAAU,aAAc,OAAW,MAE5J,GAAG,cAAc,YAAa,aAAc,CAAE,SAAU,UACxD,iBAAmB,UAAU,UAAU,mBAAmB,sBAE1D,kBAAmB,gBAOrB,KAAM,mBAAoB,cAAA,KAAK,OAAA,MAAM,GAAG,OAAO,QAAQ,CACrD,YAAa,0BAA0B,aACvC,gBAAiB,gBAAgB,iBAG7B,WAAU,IAAG,QAAQ,cAAU,MAAA,KAAA,OAAA,GAAI,KAAK,OAE9C,GAAI,cAAe,MACnB,AAAA,KAAI,KAAK,MAAM,4BAAwB,MAAA,KAAA,OAAA,GAAI,KACzC,cAAe,sBAAA,YAAY,MAAO,aAGpC,KAAM,kBAAmB,OAAA,MAAM,aAAa,QAAQ,SAAS,SAAS,cAClE,GAAG,OAAA,MAAM,GAAG,QAAQ,UAAU,aAAa,aAAA,KAAK,GAAG,QAAQ,SAAS,UAAU,KAC9E,QAAQ,SAAS,SAAS,aAExB,QAAU,GAAI,WAAU,gBAAgB,aAAc,KAAK,YAAa,CAC5E,YAAa,KAAK,MAAM,YACxB,YAAa,iBAAiB,oBAAoB,MAAM,aAAa,aAAa,UAAU,EAAG,KAC/F,YACA,IAAK,eAAe,IACpB,gBAAiB,eAAe,gBAChC,eAAgB,eAAe,eAC/B,UAAW,iBACX,KAAM,KAAK,MAAM,KACjB,QAAS,eAAe,UAG1B,AAAI,KAAK,MAAM,sBACb,QAAQ,KAAK,cAAc,KAAK,MAAM,sBAGpC,eAAe,aAAe,QAChC,eAAe,WAAW,QAAQ,iBAAkB,CAClD,QAAQ,gBAAgB,mBAI5B,KAAM,SAAU,GAAI,oBAAA,gBAAgB,QAAQ,UAEtC,eAAiB,aAAA,UAAS,IAAC,KAAK,MAAM,qBAAiB,MAAA,KAAA,OAAA,GAAI,GAAI,WACnE,KAAK,cAAA,uBAAuB,QAAQ,eAAe,eAAe,UAAU,eAGxE,cAAgB,QAAQ,mBAC1B,CAAE,qBAAsB,mBACxB,GAEJ,aAAM,UAAU,GAAI,sBAAqB,gBAAgB,CACvD,WACA,MAAO,cACP,YAAa,oBACb,QAAS,gBACT,QACA,SAAU,QAAQ,SAClB,mBAAoB,QAAQ,mBAM5B,qBAAsB,aAAA,cAAc,MAAM,IACrC,aAAA,OAAO,eACP,iBACA,qBAIP,KAAK,SAAW,QAET,CAAE,kBAAmB,EAAG,UApNnC,QAAA,iBAAA,iBA2NA,2CAA2C,UAAwB,OAAyB,CAC1F,MAAO,QAAO,IAAI,OAAQ,CACxB,KAAM,WAAY,GAElB,UAAU,KAAK,WAAW,MAAM,8CAA8C,MAAM,2GAEpF,KAAM,iBAAkB,KAAK,QAAQ,MAAM,WAC3C,AAAK,CAAC,IAAK,MAAM,SAAS,kBACxB,UAAU,KAAK,gBAAgB,oBAGjC,KAAM,UAAW,UAAU,eAAe,MAAM,SAEhD,iBAAU,KAAK,gCAAgC,SAAS,kBAAkB,MAAM,cAEzE,UAAU,KAAK,UAI1B,kCAAkC,YAA0B,QAA0B,CAIpF,GAAI,QAAQ,SAAW,EAAK,MAAO,GAEnC,GAAI,QAAQ,SAAW,EACrB,MAAO,CACL,iBAAkB,QAAQ,GAAG,UAC7B,MAAS,QAIb,KAAM,WAAiC,GACvC,SAAW,UAAU,SAAS,CAC5B,KAAM,KAAM,YAAY,eAAe,OAAO,SAE9C,GAAI,CAAC,IAAI,aACP,KAAM,IAAI,OAAM,4CAElB,UAAU,IAAI,cAAgB,CAC5B,iBAAkB,OAAO,UACzB,MAAS,QAIb,MAAO,CAAE,sBAAuB,WAGlC,kCAAyC,KAAyC,CAChF,KAAM,IAAK,CAAC,GAAI,GAAG,KAAK,OAAO,YAC/B,KAAO,GAAG,OAAS,GAAG,CACpB,KAAM,CAAC,EAAG,GAAK,GAAG,OAAO,GAAG,OAAS,EAAG,GACxC,GAAG,KAAK,OAAO,EAAG,IAEpB,MAAO,IAAG,GAEV,gBAAgB,EAAqB,EAAmB,0BACtD,MAAO,CACL,iBAAkB,uBAAuB,EAAE,iBAAkB,EAAE,kBAC/D,WAAY,aAAa,CAAC,GAAA,IAAG,EAAE,cAAU,MAAA,KAAA,OAAA,GAAI,GAAI,GAAA,IAAG,EAAE,cAAU,MAAA,KAAA,OAAA,GAAI,KACpE,eAAgB,aAAa,CAAC,GAAA,IAAG,EAAE,kBAAc,MAAA,KAAA,OAAA,GAAI,GAAI,GAAA,IAAG,EAAE,kBAAc,MAAA,KAAA,OAAA,GAAI,KAChF,iBAAkB,aAAA,gBAAgB,EAAE,iBAAkB,EAAE,kBACxD,IAAG,IAAE,EAAE,OAAG,MAAA,KAAA,OAAA,GAAI,EAAE,IAChB,gBAAe,IAAE,EAAE,mBAAe,MAAA,KAAA,OAAA,GAAI,EAAE,gBACxC,QAAO,IAAE,EAAE,WAAO,MAAA,KAAA,OAAA,GAAI,EAAE,UAhB9B,QAAA,sBAAA,sBAwBA,gCAAgC,EAAgC,EAA8B,cAC5F,MAAI,CAAC,GAAK,CAAC,EAAY,GAAC,KAAD,EAAK,EAErB,CACL,WAAU,IAAE,EAAE,cAAU,MAAA,KAAA,OAAA,GAAI,EAAE,WAC9B,YAAW,IAAE,EAAE,eAAW,MAAA,KAAA,OAAA,GAAI,EAAE,YAChC,qBAAsB,IACjB,EAAE,wBACF,EAAE,sBAEP,WAAU,IAAE,EAAE,cAAU,MAAA,KAAA,OAAA,GAAI,EAAE,YAIlC,mBAAsB,EAAgB,CACpC,MAAO,KAAM,OAMf,mCAAmC,IAA+B,oBAChE,MAAO,CACL,WAAY,IAAI,WAChB,qBAAsB,IAAI,qBAC1B,KAAI,IAAE,IAAI,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,KACtB,QAAO,IAAE,IAAI,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,QACzB,YAAa,IAAI,YACjB,uBAAsB,IAAE,IAAI,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,uBACxC,kBAAiB,IAAA,IAAE,IAAI,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,6BAAyB,MAAA,KAAA,OAAA,OAAA,GAAE,WAOlE,kCAAkC,EAAS,CACzC,MAAO,CAAC,CAAC,EAAE,MAAM,eAAiB,cAAA,WAAW,QAAQ,GAAG,OAAS,EAMnE,eAAe,GAAsC,CACnD,MAAO,cAAA,OAAO,OAAO,QAAQ,IAC1B,OAAO,CAAC,CAAC,CAAE,KAAO,IAAM,QACxB,IAAI,CAAC,CAAC,EAAG,KAAO,CAAC,EAAG,CAAE,MAAO,MAGlC,sBAAyB,GAAO,CAC9B,MAAO,IAAG,OAAS,EAAI,GAAK,OAQ9B,iCAAiC,UAAgC,OAA+B,CAC9F,GAAI,CAAC,UAAU,YAAe,MAAO,WACrC,KAAM,MAAQ,UAAkB,KAE1B,OAAS,YACT,SAAW,UACX,YAAc,SAAW,IAAI,oBAAoB,QAAU,OAAS,SAE1E,MAAO,WAAU,UAAU,WAAW,QAAQ,OAE9C,iBAAiB,EAAM,CACrB,GAAI,MAAM,QAAQ,GAAI,CACpB,KAAM,KAAa,GACnB,SAAW,MAAM,GAAG,CAClB,KAAM,CAAC,IAAK,SAAW,WAAW,IAClC,AAAI,OAAQ,QAAa,MAAQ,cAC/B,IAAI,KAAK,SAGb,MAAO,KAET,MAAI,IAAK,MAAO,IAAM,SACb,aAAA,UAAU,EAAG,SAEf,EAGT,oBAAoB,EAAM,CACxB,GAAI,MAAO,IAAM,SAAY,MAAO,CAAC,OAAW,GAChD,SAAW,OAAO,CAAC,OAAQ,UACzB,GAAI,EAAE,WAAW,KAAQ,MAAO,CAAC,IAAK,EAAE,OAAO,IAAI,SAErD,MAAO,CAAC,OAAW",
  "names": []
}
