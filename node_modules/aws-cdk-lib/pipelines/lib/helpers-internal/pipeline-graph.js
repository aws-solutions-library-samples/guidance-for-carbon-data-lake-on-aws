"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PipelineGraph=void 0;const blueprint_1=require("../blueprint"),graph_1=require("./graph"),pipeline_queries_1=require("./pipeline-queries");class PipelineGraph{constructor(pipeline,props={}){var _a,_b,_c,_d,_e,_f;this.pipeline=pipeline,this.graph=graph_1.Graph.of("",{type:"group"}),this.added=new Map,this.assetNodes=new Map,this.assetNodesByType=new Map,this.stackOutputDependencies=new graph_1.DependencyBuilders,this._fileAssetCtr=0,this._dockerAssetCtr=0,this.publishTemplate=(_a=props.publishTemplate)!==null&&_a!==void 0?_a:!1,this.prepareStep=(_b=props.prepareStep)!==null&&_b!==void 0?_b:!0,this.singlePublisher=(_c=props.singlePublisherPerAssetType)!==null&&_c!==void 0?_c:!1,this.queries=new pipeline_queries_1.PipelineQueries(pipeline),pipeline.synth instanceof blueprint_1.Step&&(this.synthNode=this.addBuildStep(pipeline.synth),((_e=(_d=this.synthNode)===null||_d===void 0?void 0:_d.data)===null||_e===void 0?void 0:_e.type)==="step"&&(this.synthNode.data.isBuildStep=!0)),this.lastPreparationNode=this.synthNode;const cloudAssembly=(_f=pipeline.synth.primaryOutput)===null||_f===void 0?void 0:_f.primaryOutput;if(!cloudAssembly)throw new Error(`The synth step must produce the cloud assembly artifact, but doesn't: ${pipeline.synth}`);if(this.cloudAssemblyFileSet=cloudAssembly,props.selfMutation){const stage=graph_1.Graph.of("UpdatePipeline",{type:"group"});this.graph.add(stage),this.selfMutateNode=graph_1.GraphNode.of("SelfMutate",{type:"self-update"}),stage.add(this.selfMutateNode),this.selfMutateNode.dependOn(this.synthNode),this.lastPreparationNode=this.selfMutateNode}const waves=pipeline.waves.map(w=>this.addWave(w));for(let i=1;i<waves.length;i++)waves[i].dependOn(waves[i-1])}isSynthNode(node){return this.synthNode===node}addBuildStep(step){return this.addAndRecurse(step,this.topLevelGraph("Build"))}addWave(wave){const retGraph=wave.stages.length===1?this.addStage(wave.stages[0]):graph_1.Graph.of(wave.id,{type:"group"},wave.stages.map(s=>this.addStage(s)));return this.addPrePost(wave.pre,wave.post,retGraph),retGraph.dependOn(this.lastPreparationNode),this.graph.add(retGraph),retGraph}addStage(stage){const retGraph=graph_1.Graph.of(stage.stageName,{type:"group"}),stackGraphs=new Map;for(const stack of stage.stacks){const stackGraph=graph_1.Graph.of(this.simpleStackName(stack.stackName,stage.stageName),{type:"stack-group",stack}),prepareNode=this.prepareStep?graph_1.GraphNode.of("Prepare",{type:"prepare",stack}):void 0,deployNode=graph_1.GraphNode.of("Deploy",{type:"execute",stack,captureOutputs:this.queries.stackOutputsReferenced(stack).length>0});retGraph.add(stackGraph),stackGraph.add(deployNode);let firstDeployNode;if(prepareNode?(stackGraph.add(prepareNode),deployNode.dependOn(prepareNode),firstDeployNode=prepareNode):firstDeployNode=deployNode,stack.changeSet.length>0)if(prepareNode)this.addChangeSet(stack.changeSet,prepareNode,deployNode,stackGraph);else throw new Error("Your pipeline engine does not support changeSet steps");const preNodes=this.addPrePost(stack.pre,stack.post,stackGraph);preNodes.nodes.length>0&&(firstDeployNode=preNodes),stackGraphs.set(stack,stackGraph);const cloudAssembly=this.cloudAssemblyFileSet;if(firstDeployNode.dependOn(this.addAndRecurse(cloudAssembly.producer,retGraph)),this.publishTemplate){if(!stack.templateAsset)throw new Error(`"publishTemplate" is enabled, but stack ${stack.stackArtifactId} does not have a template asset`);firstDeployNode.dependOn(this.publishAsset(stack.templateAsset))}for(const asset of stack.assets){const assetNode=this.publishAsset(asset);firstDeployNode.dependOn(assetNode)}this.queries.stackOutputsReferenced(stack).length>0&&this.stackOutputDependencies.get(stack).dependOn(deployNode)}for(const stack of stage.stacks)for(const dep of stack.stackDependencies){const stackNode=stackGraphs.get(stack),depNode=stackGraphs.get(dep);if(!stackNode)throw new Error(`cannot find node for ${stack.stackName}`);if(!depNode)throw new Error(`cannot find node for ${dep.stackName}`);stackNode.dependOn(depNode)}return this.addPrePost(stage.pre,stage.post,retGraph),retGraph}addChangeSet(changeSet,prepareNode,deployNode,graph){for(const c of changeSet){const changeSetNode=this.addAndRecurse(c,graph);changeSetNode==null||changeSetNode.dependOn(prepareNode),deployNode.dependOn(changeSetNode)}}addPrePost(pre,post,parent){const currentNodes=new graph_1.GraphNodeCollection(parent.nodes),preNodes=new graph_1.GraphNodeCollection(new Array);for(const p of pre){const preNode=this.addAndRecurse(p,parent);currentNodes.dependOn(preNode),preNodes.nodes.push(preNode)}for(const p of post){const postNode=this.addAndRecurse(p,parent);postNode==null||postNode.dependOn(...currentNodes.nodes)}return preNodes}topLevelGraph(name){let ret=this.graph.tryGetChild(name);return ret||(ret=new graph_1.Graph(name),this.graph.add(ret)),ret}addAndRecurse(step,parent){if(step===PipelineGraph.NO_STEP)return;const previous=this.added.get(step);if(previous)return previous;const node=graph_1.GraphNode.of(step.id,{type:"step",step});step.isSource&&(parent=this.topLevelGraph("Source")),parent.add(node),this.added.set(step,node);for(const dep of step.dependencies){const producerNode=this.addAndRecurse(dep,parent);node.dependOn(producerNode)}if(step instanceof blueprint_1.ShellStep)for(const output of Object.values(step.envFromCfnOutputs)){const stack=this.queries.producingStack(output);this.stackOutputDependencies.get(stack).dependBy(node)}return node}publishAsset(stackAsset){const assetsGraph=this.topLevelGraph("Assets");let assetNode=this.assetNodes.get(stackAsset.assetId);if(!assetNode)if(this.singlePublisher&&this.assetNodesByType.has(stackAsset.assetType))assetNode=this.assetNodesByType.get(stackAsset.assetType);else{const id=stackAsset.assetType===blueprint_1.AssetType.FILE?this.singlePublisher?"FileAsset":`FileAsset${++this._fileAssetCtr}`:this.singlePublisher?"DockerAsset":`DockerAsset${++this._dockerAssetCtr}`;assetNode=graph_1.GraphNode.of(id,{type:"publish-assets",assets:[]}),assetsGraph.add(assetNode),assetNode.dependOn(this.lastPreparationNode),this.assetNodesByType.set(stackAsset.assetType,assetNode),this.assetNodes.set(stackAsset.assetId,assetNode)}const data=assetNode.data;if((data==null?void 0:data.type)!=="publish-assets")throw new Error(`${assetNode} has the wrong data.type: ${data==null?void 0:data.type}`);return data.assets.some(a=>a.assetSelector===stackAsset.assetSelector)||data.assets.push(stackAsset),assetNode}simpleStackName(stackName,stageName){return stripPrefix(stackName,`${stageName}-`)}}exports.PipelineGraph=PipelineGraph,PipelineGraph.NO_STEP=new class extends blueprint_1.Step{}("NO_STEP");function stripPrefix(s,prefix){return s.startsWith(prefix)?s.substr(prefix.length):s}
//# sourceMappingURL=pipeline-graph.js.map
