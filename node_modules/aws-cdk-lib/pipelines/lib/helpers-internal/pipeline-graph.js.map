{
  "version": 3,
  "sources": ["pipeline-graph.ts"],
  "sourcesContent": ["import { AssetType, FileSet, ShellStep, StackAsset, StackDeployment, StageDeployment, Step, Wave } from '../blueprint';\nimport { PipelineBase } from '../main/pipeline-base';\nimport { DependencyBuilders, Graph, GraphNode, GraphNodeCollection } from './graph';\nimport { PipelineQueries } from './pipeline-queries';\n\nexport interface PipelineGraphProps {\n  /**\n   * Add a self-mutation step.\n   *\n   * @default false\n   */\n  readonly selfMutation?: boolean;\n\n  /**\n   * Publishes the template asset to S3.\n   *\n   * @default false\n   */\n  readonly publishTemplate?: boolean;\n\n  /**\n   * Whether to combine asset publishers for the same type into one step\n   *\n   * @default false\n   */\n  readonly singlePublisherPerAssetType?: boolean;\n\n  /**\n   * Add a \"prepare\" step for each stack which can be used to create the change\n   * set. If this is disabled, only the \"execute\" step will be included.\n   *\n   * @default true\n   */\n  readonly prepareStep?: boolean;\n}\n\n/**\n * Logic to turn the deployment blueprint into a graph\n *\n * This code makes all the decisions on how to lay out the CodePipeline\n */\nexport class PipelineGraph {\n  /**\n   * A Step object that may be used as the producer of FileSets that should not be represented in the graph\n   */\n  public static readonly NO_STEP: Step = new class extends Step { }('NO_STEP');\n\n  public readonly graph: AGraph = Graph.of('', { type: 'group' });\n  public readonly cloudAssemblyFileSet: FileSet;\n  public readonly queries: PipelineQueries;\n\n  private readonly added = new Map<Step, AGraphNode>();\n  private readonly assetNodes = new Map<string, AGraphNode>();\n  private readonly assetNodesByType = new Map<AssetType, AGraphNode>();\n  private readonly synthNode?: AGraphNode;\n  private readonly selfMutateNode?: AGraphNode;\n  private readonly stackOutputDependencies = new DependencyBuilders<StackDeployment, any>();\n  private readonly publishTemplate: boolean;\n  private readonly prepareStep: boolean;\n  private readonly singlePublisher: boolean;\n\n  private lastPreparationNode?: AGraphNode;\n  private _fileAssetCtr = 0;\n  private _dockerAssetCtr = 0;\n\n  constructor(public readonly pipeline: PipelineBase, props: PipelineGraphProps = {}) {\n    this.publishTemplate = props.publishTemplate ?? false;\n    this.prepareStep = props.prepareStep ?? true;\n    this.singlePublisher = props.singlePublisherPerAssetType ?? false;\n\n    this.queries = new PipelineQueries(pipeline);\n\n    if (pipeline.synth instanceof Step) {\n      this.synthNode = this.addBuildStep(pipeline.synth);\n      if (this.synthNode?.data?.type === 'step') {\n        this.synthNode.data.isBuildStep = true;\n      }\n    }\n    this.lastPreparationNode = this.synthNode;\n\n    const cloudAssembly = pipeline.synth.primaryOutput?.primaryOutput;\n    if (!cloudAssembly) {\n      throw new Error(`The synth step must produce the cloud assembly artifact, but doesn't: ${pipeline.synth}`);\n    }\n\n    this.cloudAssemblyFileSet = cloudAssembly;\n\n    if (props.selfMutation) {\n      const stage: AGraph = Graph.of('UpdatePipeline', { type: 'group' });\n      this.graph.add(stage);\n      this.selfMutateNode = GraphNode.of('SelfMutate', { type: 'self-update' });\n      stage.add(this.selfMutateNode);\n\n      this.selfMutateNode.dependOn(this.synthNode);\n      this.lastPreparationNode = this.selfMutateNode;\n    }\n\n    const waves = pipeline.waves.map(w => this.addWave(w));\n\n    // Make sure the waves deploy sequentially\n    for (let i = 1; i < waves.length; i++) {\n      waves[i].dependOn(waves[i - 1]);\n    }\n\n    // Add additional dependencies between steps that depend on stack outputs and the stacks\n    // that produce them.\n  }\n\n  public isSynthNode(node: AGraphNode) {\n    return this.synthNode === node;\n  }\n\n  private addBuildStep(step: Step) {\n    return this.addAndRecurse(step, this.topLevelGraph('Build'));\n  }\n\n  private addWave(wave: Wave): AGraph {\n    // If the wave only has one Stage in it, don't add an additional Graph around it\n    const retGraph: AGraph = wave.stages.length === 1\n      ? this.addStage(wave.stages[0])\n      : Graph.of(wave.id, { type: 'group' }, wave.stages.map(s => this.addStage(s)));\n\n    this.addPrePost(wave.pre, wave.post, retGraph);\n    retGraph.dependOn(this.lastPreparationNode);\n    this.graph.add(retGraph);\n\n    return retGraph;\n  }\n\n  private addStage(stage: StageDeployment): AGraph {\n    const retGraph: AGraph = Graph.of(stage.stageName, { type: 'group' });\n\n    const stackGraphs = new Map<StackDeployment, AGraph>();\n\n    for (const stack of stage.stacks) {\n      const stackGraph: AGraph = Graph.of(this.simpleStackName(stack.stackName, stage.stageName), { type: 'stack-group', stack });\n      const prepareNode: AGraphNode | undefined = this.prepareStep ? GraphNode.of('Prepare', { type: 'prepare', stack }) : undefined;\n      const deployNode: AGraphNode = GraphNode.of('Deploy', {\n        type: 'execute',\n        stack,\n        captureOutputs: this.queries.stackOutputsReferenced(stack).length > 0,\n      });\n\n      retGraph.add(stackGraph);\n      stackGraph.add(deployNode);\n\n      // node or node collection that represents first point of contact in each stack\n      let firstDeployNode;\n      if (prepareNode) {\n        stackGraph.add(prepareNode);\n        deployNode.dependOn(prepareNode);\n        firstDeployNode = prepareNode;\n      } else {\n        firstDeployNode = deployNode;\n      }\n\n      // add changeset steps at the stack level\n      if (stack.changeSet.length > 0) {\n        if (prepareNode) {\n          this.addChangeSet(stack.changeSet, prepareNode, deployNode, stackGraph);\n        } else {\n          throw new Error('Your pipeline engine does not support changeSet steps');\n        }\n      }\n\n      // add pre and post steps at the stack level\n      const preNodes = this.addPrePost(stack.pre, stack.post, stackGraph);\n      if (preNodes.nodes.length > 0) {\n        firstDeployNode = preNodes;\n      }\n\n      stackGraphs.set(stack, stackGraph);\n\n      const cloudAssembly = this.cloudAssemblyFileSet;\n\n      firstDeployNode.dependOn(this.addAndRecurse(cloudAssembly.producer, retGraph));\n\n      // add the template asset\n      if (this.publishTemplate) {\n        if (!stack.templateAsset) {\n          throw new Error(`\"publishTemplate\" is enabled, but stack ${stack.stackArtifactId} does not have a template asset`);\n        }\n\n        firstDeployNode.dependOn(this.publishAsset(stack.templateAsset));\n      }\n\n      // Depend on Assets\n      // FIXME: Custom Cloud Assembly currently doesn't actually help separating\n      // out templates from assets!!!\n      for (const asset of stack.assets) {\n        const assetNode = this.publishAsset(asset);\n        firstDeployNode.dependOn(assetNode);\n      }\n\n      // Add stack output synchronization point\n      if (this.queries.stackOutputsReferenced(stack).length > 0) {\n        this.stackOutputDependencies.get(stack).dependOn(deployNode);\n      }\n    }\n\n    for (const stack of stage.stacks) {\n      for (const dep of stack.stackDependencies) {\n        const stackNode = stackGraphs.get(stack);\n        const depNode = stackGraphs.get(dep);\n        if (!stackNode) {\n          throw new Error(`cannot find node for ${stack.stackName}`);\n        }\n        if (!depNode) {\n          throw new Error(`cannot find node for ${dep.stackName}`);\n        }\n        stackNode.dependOn(depNode);\n      }\n    }\n\n    this.addPrePost(stage.pre, stage.post, retGraph);\n\n    return retGraph;\n  }\n\n  private addChangeSet(changeSet: Step[], prepareNode: AGraphNode, deployNode: AGraphNode, graph: AGraph) {\n    for (const c of changeSet) {\n      const changeSetNode = this.addAndRecurse(c, graph);\n      changeSetNode?.dependOn(prepareNode);\n      deployNode.dependOn(changeSetNode);\n    }\n  }\n\n  private addPrePost(pre: Step[], post: Step[], parent: AGraph) {\n    const currentNodes = new GraphNodeCollection(parent.nodes);\n    const preNodes = new GraphNodeCollection(new Array<AGraphNode>());\n    for (const p of pre) {\n      const preNode = this.addAndRecurse(p, parent);\n      currentNodes.dependOn(preNode);\n      preNodes.nodes.push(preNode!);\n    }\n    for (const p of post) {\n      const postNode = this.addAndRecurse(p, parent);\n      postNode?.dependOn(...currentNodes.nodes);\n    }\n    return preNodes;\n  }\n\n  private topLevelGraph(name: string): AGraph {\n    let ret = this.graph.tryGetChild(name);\n    if (!ret) {\n      ret = new Graph<GraphAnnotation>(name);\n      this.graph.add(ret);\n    }\n    return ret as AGraph;\n  }\n\n  private addAndRecurse(step: Step, parent: AGraph) {\n    if (step === PipelineGraph.NO_STEP) { return undefined; }\n\n    const previous = this.added.get(step);\n    if (previous) { return previous; }\n\n    const node: AGraphNode = GraphNode.of(step.id, { type: 'step', step });\n\n    // If the step is a source step, change the parent to a special \"Source\" stage\n    // (CodePipeline wants it that way)\n    if (step.isSource) {\n      parent = this.topLevelGraph('Source');\n    }\n\n    parent.add(node);\n    this.added.set(step, node);\n\n    for (const dep of step.dependencies) {\n      const producerNode = this.addAndRecurse(dep, parent);\n      node.dependOn(producerNode);\n    }\n\n    // Add stack dependencies (by use of the dependency builder this also works\n    // if we encounter the Step before the Stack has been properly added yet)\n    if (step instanceof ShellStep) {\n      for (const output of Object.values(step.envFromCfnOutputs)) {\n        const stack = this.queries.producingStack(output);\n        this.stackOutputDependencies.get(stack).dependBy(node);\n      }\n    }\n\n    return node;\n  }\n\n  private publishAsset(stackAsset: StackAsset): AGraphNode {\n    const assetsGraph = this.topLevelGraph('Assets');\n\n    let assetNode = this.assetNodes.get(stackAsset.assetId);\n    if (assetNode) {\n      // If there's already a node publishing this asset, add as a new publishing\n      // destination to the same node.\n    } else if (this.singlePublisher && this.assetNodesByType.has(stackAsset.assetType)) {\n      // If we're doing a single node per type, lookup by that\n      assetNode = this.assetNodesByType.get(stackAsset.assetType)!;\n    } else {\n      // Otherwise add a new one\n      const id = stackAsset.assetType === AssetType.FILE\n        ? (this.singlePublisher ? 'FileAsset' : `FileAsset${++this._fileAssetCtr}`)\n        : (this.singlePublisher ? 'DockerAsset' : `DockerAsset${++this._dockerAssetCtr}`);\n\n      assetNode = GraphNode.of(id, { type: 'publish-assets', assets: [] });\n      assetsGraph.add(assetNode);\n      assetNode.dependOn(this.lastPreparationNode);\n\n      this.assetNodesByType.set(stackAsset.assetType, assetNode);\n      this.assetNodes.set(stackAsset.assetId, assetNode);\n    }\n\n    const data = assetNode.data;\n    if (data?.type !== 'publish-assets') {\n      throw new Error(`${assetNode} has the wrong data.type: ${data?.type}`);\n    }\n    if (!data.assets.some(a => a.assetSelector === stackAsset.assetSelector)) {\n      data.assets.push(stackAsset);\n    }\n\n    return assetNode;\n  }\n\n  /**\n   * Simplify the stack name by removing the `Stage-` prefix if it exists.\n   */\n  private simpleStackName(stackName: string, stageName: string) {\n    return stripPrefix(stackName, `${stageName}-`);\n  }\n}\n\ntype GraphAnnotation =\n  { readonly type: 'group' }\n  | { readonly type: 'stack-group'; readonly stack: StackDeployment }\n  | { readonly type: 'publish-assets'; readonly assets: StackAsset[] }\n  | { readonly type: 'step'; readonly step: Step; isBuildStep?: boolean }\n  | { readonly type: 'self-update' }\n  | { readonly type: 'prepare'; readonly stack: StackDeployment }\n  | { readonly type: 'execute'; readonly stack: StackDeployment; readonly captureOutputs: boolean }\n  ;\n\n// Type aliases for the graph nodes tagged with our specific annotation type\n// (to save on generics in the code above).\nexport type AGraphNode = GraphNode<GraphAnnotation>;\nexport type AGraph = Graph<GraphAnnotation>;\n\nfunction stripPrefix(s: string, prefix: string) {\n  return s.startsWith(prefix) ? s.substr(prefix.length) : s;\n}"],
  "mappings": "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",
  "names": []
}
