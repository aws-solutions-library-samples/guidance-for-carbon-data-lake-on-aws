{
  "version": 3,
  "sources": ["step-output.ts"],
  "sourcesContent": ["import { IResolvable, IResolveContext, Token, Tokenization } from '../../../core';\nimport { Step } from '../blueprint/step';\n\n\nconst STEP_OUTPUT_SYM = Symbol.for('@aws-cdk/pipelines.StepOutput');\n\nconst PRODUCED_OUTPUTS_SYM = Symbol.for('@aws-cdk/pipelines.outputs');\n\n\n/**\n * A symbolic reference to a value produced by another step\n *\n * Generating and consuming outputs is engine-specific. Many engines will be\n * able to support a feature like \"outputs\", but it's not guaranteed that\n * all of them will.\n *\n * Outputs can only be generated by engine-specific steps (CodeBuildStep instead\n * of ShellStep, etc), but can (currently) be consumed anywhere(*). When\n * an engine-specific step generates an Output, it should put a well-known\n * string and arbitrary data that is useful to the engine into the engine-specific\n * fields on the StepOutput.\n *\n * The graph blueprint will take care of dependencies and ordering, the engine\n * is responsible interpreting and rendering StepOutputs. The engine should call\n * `defineResolution()` on all outputs.\n *\n * StepOutputs currently purposely aren't part of the public API because users\n * shouldn't see the innards poking out. So, instead of keeping state on `Step`,\n * we keep side-state here in a WeakMap which can be accessed via static members\n * on `StepOutput`.\n *\n * (*) If we need to restrict this, we add the checking and erroring in the engine.\n */\nexport class StepOutput implements IResolvable {\n  /**\n   * Return true if the given IResolvable is a StepOutput\n   */\n  public static isStepOutput(resolvable: IResolvable): resolvable is StepOutput {\n    return !!(resolvable as any)[STEP_OUTPUT_SYM];\n  }\n\n  /**\n   * Find all StepOutputs referenced in the given structure\n   */\n  public static findAll(structure: any): StepOutput[] {\n    return findAllStepOutputs(structure);\n  }\n\n  /**\n   * Return the produced outputs for the given step\n   */\n  public static producedStepOutputs(step: Step): StepOutput[] {\n    return (step as any)[PRODUCED_OUTPUTS_SYM] ?? [];\n  }\n\n  /**\n   * Add produced outputs for the given step\n   */\n  public static recordProducer(...outputs: StepOutput[]) {\n    for (const output of outputs) {\n      const step = output.step;\n      let list = (step as any)[PRODUCED_OUTPUTS_SYM];\n      if (!list) {\n        list = [];\n        (step as any)[PRODUCED_OUTPUTS_SYM] = list;\n      }\n      list.push(...outputs);\n    }\n  }\n\n  /**\n   * The step that produces this output\n   */\n  public readonly step: Step;\n\n  /**\n   * Name of the engine for which this output is intended\n   */\n  public readonly engineName: string;\n\n  /**\n   * Additional data on the output, to be interpreted by the engine\n   */\n  public readonly engineSpecificInformation: any;\n\n  public readonly creationStack: string[] = [];\n  private resolution: any = undefined;\n\n  constructor(step: Step, engineName: string, engineSpecificInformation: any) {\n    this.step = step;\n    this.engineName = engineName;\n    this.engineSpecificInformation = engineSpecificInformation;\n    Object.defineProperty(this, STEP_OUTPUT_SYM, { value: true });\n  }\n\n  /**\n   * Define the resolved value for this StepOutput.\n   *\n   * Should be called by the engine.\n   */\n  public defineResolution(value: any) {\n    this.resolution = value;\n  }\n\n  public resolve(_context: IResolveContext) {\n    if (this.resolution === undefined) {\n      throw new Error(`Output for step ${this.step} not configured. Either the step is not in the pipeline, or this engine does not support Outputs for this step.`);\n    }\n    return this.resolution;\n  }\n\n  public toString(): string {\n    return Token.asString(this);\n  }\n}\n\nfunction findAllStepOutputs(structure: any): StepOutput[] {\n  const ret = new Set<StepOutput>();\n  recurse(structure);\n  return Array.from(ret);\n\n  function checkToken(x?: IResolvable) {\n    if (x && StepOutput.isStepOutput(x)) {\n      ret.add(x);\n      return true;\n    }\n\n    // Return false if it wasn't a Token in the first place (in which case we recurse)\n    return x !== undefined;\n  }\n\n  function recurse(x: any): void {\n    if (!x) { return; }\n\n    if (Tokenization.isResolvable(x)) {\n      checkToken(x);\n      return;\n    }\n    if (Array.isArray(x)) {\n      if (!checkToken(Tokenization.reverseList(x))) {\n        x.forEach(recurse);\n      }\n      return;\n    }\n    if (typeof x === 'number') {\n      checkToken(Tokenization.reverseNumber(x));\n      return;\n    }\n    if (typeof x === 'string') {\n      Tokenization.reverseString(x).tokens.forEach(checkToken);\n      return;\n    }\n    if (typeof x === 'object') {\n      for (const [k, v] of Object.entries(x)) {\n        recurse(k);\n        recurse(v);\n      }\n    }\n  }\n}"],
  "mappings": "8FAAA,KAAA,QAAA,QAAA,iBAIM,gBAAkB,OAAO,IAAI,iCAE7B,qBAAuB,OAAO,IAAI,8BA2BxC,gBAAuB,CAuDrB,YAAY,KAAY,WAAoB,0BAA8B,CAH1D,KAAA,cAA0B,GAClC,KAAA,WAAkB,OAGxB,KAAK,KAAO,KACZ,KAAK,WAAa,WAClB,KAAK,0BAA4B,0BACjC,OAAO,eAAe,KAAM,gBAAiB,CAAE,MAAO,WAvD1C,cAAa,WAAuB,CAChD,MAAO,CAAC,CAAE,WAAmB,uBAMjB,SAAQ,UAAc,CAClC,MAAO,oBAAmB,iBAMd,qBAAoB,KAAU,QAC1C,MAAA,IAAQ,KAAa,yBAAqB,MAAA,KAAA,OAAA,GAAI,SAMlC,mBAAkB,QAAqB,CACnD,SAAW,UAAU,SAAS,CAC5B,KAAM,MAAO,OAAO,KACpB,GAAI,MAAQ,KAAa,sBACzB,AAAK,MACH,MAAO,GACN,KAAa,sBAAwB,MAExC,KAAK,KAAK,GAAG,UAkCV,iBAAiB,MAAU,CAChC,KAAK,WAAa,MAGb,QAAQ,SAAyB,CACtC,GAAI,KAAK,aAAe,OACtB,KAAM,IAAI,OAAM,mBAAmB,KAAK,uHAE1C,MAAO,MAAK,WAGP,UAAQ,CACb,MAAO,QAAA,MAAM,SAAS,OA/E1B,QAAA,WAAA,WAmFA,4BAA4B,UAAc,CACxC,KAAM,KAAM,GAAI,KAChB,eAAQ,WACD,MAAM,KAAK,KAElB,oBAAoB,EAAe,CACjC,MAAI,IAAK,WAAW,aAAa,GAC/B,KAAI,IAAI,GACD,IAIF,IAAM,OAGf,iBAAiB,EAAM,CACrB,GAAI,EAAC,EAEL,IAAI,OAAA,aAAa,aAAa,GAAI,CAChC,WAAW,GACX,OAEF,GAAI,MAAM,QAAQ,GAAI,CACpB,AAAK,WAAW,OAAA,aAAa,YAAY,KACvC,EAAE,QAAQ,SAEZ,OAEF,GAAI,MAAO,IAAM,SAAU,CACzB,WAAW,OAAA,aAAa,cAAc,IACtC,OAEF,GAAI,MAAO,IAAM,SAAU,CACzB,OAAA,aAAa,cAAc,GAAG,OAAO,QAAQ,YAC7C,OAEF,GAAI,MAAO,IAAM,SACf,SAAW,CAAC,EAAG,IAAM,QAAO,QAAQ,GAClC,QAAQ,GACR,QAAQ",
  "names": []
}
