{
  "version": 3,
  "sources": ["javascript.ts"],
  "sourcesContent": ["export function addAll<A>(into: Set<A>, from: Iterable<A>) {\n  for (const x of from) {\n    into.add(x);\n  }\n}\n\nexport function extract<A, B>(from: Map<A, B>, key: A): B | undefined {\n  const ret = from.get(key);\n  from.delete(key);\n  return ret;\n}\n\nexport function* flatMap<A, B>(xs: Iterable<A>, fn: (x: A) => Iterable<B>): IterableIterator<B> {\n  for (const x of xs) {\n    for (const y of fn(x)) {\n      yield y;\n    }\n  }\n}\n\nexport function* enumerate<A>(xs: Iterable<A>): IterableIterator<[number, A]> {\n  let i = 0;\n  for (const x of xs) {\n    yield [i++, x];\n  }\n}\n\n\nexport function expectProp<A extends object, B extends keyof A>(obj: A, key: B): NonNullable<A[B]> {\n  if (!obj[key]) { throw new Error(`Expecting '${key}' to be set!`); }\n  return obj[key] as any;\n}\n\nexport function* flatten<A>(xs: Iterable<A[]>): IterableIterator<A> {\n  for (const x of xs) {\n    for (const y of x) {\n      yield y;\n    }\n  }\n}\n\nexport function filterEmpty(xs: Array<string | undefined>): string[] {\n  return xs.filter(x => x) as any;\n}\n\nexport function mapValues<A, B>(xs: Record<string, A>, fn: (x: A) => B): Record<string, B> {\n  const ret: Record<string, B> = {};\n  for (const [k, v] of Object.entries(xs)) {\n    ret[k] = fn(v);\n  }\n  return ret;\n}\n\nexport function mkdict<A>(xs: Array<readonly [string, A]>): Record<string, A> {\n  const ret: Record<string, A> = {};\n  for (const [k, v] of xs) {\n    ret[k] = v;\n  }\n  return ret;\n}\n\nexport function noEmptyObject<A>(xs: Record<string, A>): Record<string, A> | undefined {\n  if (Object.keys(xs).length === 0) { return undefined; }\n  return xs;\n}\n\nexport function noUndefined<A>(xs: Record<string, A>): Record<string, NonNullable<A>> {\n  return mkdict(Object.entries(xs).filter(([_, v]) => isDefined(v))) as any;\n}\n\nexport function maybeSuffix(x: string | undefined, suffix: string): string | undefined {\n  if (x === undefined) { return undefined; }\n  return `${x}${suffix}`;\n}\n\n/**\n * Partition a collection by dividing it into two collections, one that matches the predicate and one that don't\n */\nexport function partition<T>(xs: T[], pred: (x: T) => boolean): [T[], T[]] {\n  const yes: T[] = [];\n  const no: T[] = [];\n  for (const x of xs) {\n    (pred(x) ? yes : no).push(x);\n  }\n  return [yes, no];\n}\n\nexport function isDefined<A>(x: A): x is NonNullable<A> {\n  return x !== undefined;\n}"],
  "mappings": "sUAAA,gBAA0B,KAAc,KAAiB,CACvD,SAAW,KAAK,MACd,KAAK,IAAI,GAFb,QAAA,OAAA,OAMA,iBAA8B,KAAiB,IAAM,CACnD,KAAM,KAAM,KAAK,IAAI,KACrB,YAAK,OAAO,KACL,IAHT,QAAA,QAAA,QAMA,iBAA+B,GAAiB,GAAyB,CACvE,SAAW,KAAK,IACd,SAAW,KAAK,IAAG,GACjB,KAAM,GAHZ,QAAA,QAAA,QAQA,mBAA8B,GAAe,CAC3C,GAAI,GAAI,EACR,SAAW,KAAK,IACd,KAAM,CAAC,IAAK,GAHhB,QAAA,UAAA,UAQA,oBAAgE,IAAQ,IAAM,CAC5E,GAAI,CAAC,IAAI,KAAQ,KAAM,IAAI,OAAM,cAAc,mBAC/C,MAAO,KAAI,KAFb,QAAA,WAAA,WAKA,iBAA4B,GAAiB,CAC3C,SAAW,KAAK,IACd,SAAW,KAAK,GACd,KAAM,GAHZ,QAAA,QAAA,QAQA,qBAA4B,GAA6B,CACvD,MAAO,IAAG,OAAO,GAAK,GADxB,QAAA,YAAA,YAIA,mBAAgC,GAAuB,GAAe,CACpE,KAAM,KAAyB,GAC/B,SAAW,CAAC,EAAG,IAAM,QAAO,QAAQ,IAClC,IAAI,GAAK,GAAG,GAEd,MAAO,KALT,QAAA,UAAA,UAQA,gBAA0B,GAA+B,CACvD,KAAM,KAAyB,GAC/B,SAAW,CAAC,EAAG,IAAM,IACnB,IAAI,GAAK,EAEX,MAAO,KALT,QAAA,OAAA,OAQA,uBAAiC,GAAqB,CACpD,GAAI,OAAO,KAAK,IAAI,SAAW,EAC/B,MAAO,IAFT,QAAA,cAAA,cAKA,qBAA+B,GAAqB,CAClD,MAAO,QAAO,OAAO,QAAQ,IAAI,OAAO,CAAC,CAAC,EAAG,KAAO,UAAU,KADhE,QAAA,YAAA,YAIA,qBAA4B,EAAuB,OAAc,CAC/D,GAAI,IAAM,OACV,MAAO,GAAG,IAAI,SAFhB,QAAA,YAAA,YAQA,mBAA6B,GAAS,KAAuB,CAC3D,KAAM,KAAW,GACX,GAAU,GAChB,SAAW,KAAK,IACd,AAAC,MAAK,GAAK,IAAM,IAAI,KAAK,GAE5B,MAAO,CAAC,IAAK,IANf,QAAA,UAAA,UASA,mBAA6B,EAAI,CAC/B,MAAO,KAAM,OADf,QAAA,UAAA",
  "names": []
}
