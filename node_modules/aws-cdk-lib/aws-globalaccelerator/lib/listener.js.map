{
  "version": 3,
  "sources": ["listener.ts"],
  "sourcesContent": ["import * as cdk from '../../core';\nimport { Construct } from 'constructs';\nimport { IAccelerator } from './accelerator';\nimport { EndpointGroup, EndpointGroupOptions } from './endpoint-group';\nimport * as ga from './globalaccelerator.generated';\n\n/**\n * Interface of the Listener\n */\nexport interface IListener extends cdk.IResource {\n  /**\n   * The ARN of the listener\n   *\n   * @attribute\n   */\n  readonly listenerArn: string;\n}\n\n/**\n * Construct options for Listener\n */\nexport interface ListenerOptions {\n  /**\n   * Name of the listener\n   *\n   * @default - logical ID of the resource\n   */\n  readonly listenerName?: string;\n\n  /**\n   * The list of port ranges for the connections from clients to the accelerator\n   */\n  readonly portRanges: PortRange[];\n\n  /**\n   * The protocol for the connections from clients to the accelerator\n   *\n   * @default ConnectionProtocol.TCP\n   */\n  readonly protocol?: ConnectionProtocol;\n\n  /**\n   * Client affinity to direct all requests from a user to the same endpoint\n   *\n   * If you have stateful applications, client affinity lets you direct all\n   * requests from a user to the same endpoint.\n   *\n   * By default, each connection from each client is routed to seperate\n   * endpoints. Set client affinity to SOURCE_IP to route all connections from\n   * a single client to the same endpoint.\n   *\n   * @default ClientAffinity.NONE\n   */\n  readonly clientAffinity?: ClientAffinity;\n}\n\n/**\n * Construct properties for Listener\n */\nexport interface ListenerProps extends ListenerOptions {\n  /**\n   * The accelerator for this listener\n   */\n  readonly accelerator: IAccelerator;\n}\n\n/**\n * The list of port ranges for the connections from clients to the accelerator.\n */\nexport interface PortRange {\n  /**\n   * The first port in the range of ports, inclusive.\n   */\n  readonly fromPort: number;\n\n  /**\n   * The last port in the range of ports, inclusive.\n   *\n   * @default - same as `fromPort`\n   */\n  readonly toPort?: number;\n}\n\n/**\n * The protocol for the connections from clients to the accelerator.\n */\nexport enum ConnectionProtocol {\n  /**\n   * TCP\n   */\n  TCP = 'TCP',\n  /**\n   * UDP\n   */\n  UDP = 'UDP',\n}\n\n/**\n * Client affinity gives you control over whether to always route each client to the same specific endpoint.\n *\n * @see https://docs.aws.amazon.com/global-accelerator/latest/dg/about-listeners.html#about-listeners-client-affinity\n */\nexport enum ClientAffinity {\n  /**\n   * Route traffic based on the 5-tuple `(source IP, source port, destination IP, destination port, protocol)`\n   */\n  NONE = 'NONE',\n\n  /**\n   * Route traffic based on the 2-tuple `(source IP, destination IP)`\n   *\n   * The result is that multiple connections from the same client will be routed the same.\n   */\n  SOURCE_IP = 'SOURCE_IP',\n}\n\n/**\n * The construct for the Listener\n */\nexport class Listener extends cdk.Resource implements IListener {\n  /**\n   * import from ARN\n   */\n  public static fromListenerArn(scope: Construct, id: string, listenerArn: string): IListener {\n    class Import extends cdk.Resource implements IListener {\n      public readonly listenerArn = listenerArn;\n    }\n    return new Import(scope, id);\n  }\n\n  public readonly listenerArn: string;\n  /**\n   * The name of the listener\n   *\n   * @attribute\n   */\n  public readonly listenerName: string;\n\n  constructor(scope: Construct, id: string, props: ListenerProps) {\n    super(scope, id);\n\n    const resource = new ga.CfnListener(this, 'Resource', {\n      acceleratorArn: props.accelerator.acceleratorArn,\n      portRanges: props.portRanges.map(m => ({\n        fromPort: m.fromPort,\n        toPort: m.toPort ?? m.fromPort,\n      })),\n      protocol: props.protocol ?? ConnectionProtocol.TCP,\n      clientAffinity: props.clientAffinity ?? ClientAffinity.NONE,\n    });\n\n    this.listenerArn = resource.attrListenerArn;\n    this.listenerName = props.listenerName ?? resource.logicalId;\n  }\n\n  /**\n   * Add a new endpoint group to this listener\n   */\n  public addEndpointGroup(id: string, options: EndpointGroupOptions = {}) {\n    return new EndpointGroup(this, id, {\n      listener: this,\n      ...options,\n    });\n  }\n}\n"],
  "mappings": "iQAAA,IAAA,QAAA,cAGA,iBAAA,QAAA,oBACA,GAAA,QAAA,iCAkFA,GAAY,oBAAZ,AAAA,UAAY,oBAAkB,CAI5B,oBAAA,IAAA,MAIA,oBAAA,IAAA,QARU,mBAAA,QAAA,oBAAA,SAAA,mBAAkB,KAgB9B,GAAY,gBAAZ,AAAA,UAAY,gBAAc,CAIxB,gBAAA,KAAA,OAOA,gBAAA,UAAA,cAXU,eAAA,QAAA,gBAAA,SAAA,eAAc,KAiB1B,sBAA8B,KAAI,QAAQ,CAmBxC,YAAY,MAAkB,GAAY,MAAoB,cAC5D,MAAM,MAAO,mFAEb,KAAM,UAAW,GAAI,IAAG,YAAY,KAAM,WAAY,CACpD,eAAgB,MAAM,YAAY,eAClC,WAAY,MAAM,WAAW,IAAI,GAAI,SAAC,MAAC,CACrC,SAAU,EAAE,SACZ,OAAM,KAAE,EAAE,UAAM,MAAA,MAAA,OAAA,IAAI,EAAE,YAExB,SAAQ,IAAE,MAAM,YAAQ,MAAA,KAAA,OAAA,GAAI,mBAAmB,IAC/C,eAAc,IAAE,MAAM,kBAAc,MAAA,KAAA,OAAA,GAAI,eAAe,OAGzD,KAAK,YAAc,SAAS,gBAC5B,KAAK,aAAY,IAAG,MAAM,gBAAY,MAAA,KAAA,OAAA,GAAI,SAAS,gBA7BvC,iBAAgB,MAAkB,GAAY,YAAmB,CAC7E,oBAAqB,KAAI,QAAQ,CAAjC,aAAA,qBACkB,KAAA,YAAc,aAEhC,MAAO,IAAI,QAAO,MAAO,IA+BpB,iBAAiB,GAAY,QAAgC,GAAE,gGAC7D,GAAI,kBAAA,cAAc,KAAM,GAAI,CACjC,SAAU,QACP,WA1CT,QAAA,SAAA",
  "names": []
}
