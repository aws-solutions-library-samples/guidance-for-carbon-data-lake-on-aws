{
  "version": 3,
  "sources": ["deployment.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport { Lazy, RemovalPolicy, Resource, CfnResource } from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnDeployment } from './apigateway.generated';\nimport { Method } from './method';\nimport { IRestApi, RestApi, SpecRestApi, RestApiBase } from './restapi';\n\nexport interface DeploymentProps {\n  /**\n   * The Rest API to deploy.\n   */\n  readonly api: IRestApi;\n\n  /**\n   * A description of the purpose of the API Gateway deployment.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n\n  /**\n   * When an API Gateway model is updated, a new deployment will automatically be created.\n   * If this is true, the old API Gateway Deployment resource will not be deleted.\n   * This will allow manually reverting back to a previous deployment in case for example\n   *\n   * @default false\n   */\n  readonly retainDeployments?: boolean;\n}\n\n/**\n * A Deployment of a REST API.\n *\n * An immutable representation of a RestApi resource that can be called by users\n * using Stages. A deployment must be associated with a Stage for it to be\n * callable over the Internet.\n *\n * Normally, you don't need to define deployments manually. The RestApi\n * construct manages a Deployment resource that represents the latest model. It\n * can be accessed through `restApi.latestDeployment` (unless `deploy: false` is\n * set when defining the `RestApi`).\n *\n * If you manually define this resource, you will need to know that since\n * deployments are immutable, as long as the resource's logical ID doesn't\n * change, the deployment will represent the snapshot in time in which the\n * resource was created. This means that if you modify the RestApi model (i.e.\n * add methods or resources), these changes will not be reflected unless a new\n * deployment resource is created.\n *\n * To achieve this behavior, the method `addToLogicalId(data)` can be used to\n * augment the logical ID generated for the deployment resource such that it\n * will include arbitrary data. This is done automatically for the\n * `restApi.latestDeployment` deployment.\n *\n * Furthermore, since a deployment does not reference any of the REST API\n * resources and methods, CloudFormation will likely provision it before these\n * resources are created, which means that it will represent a \"half-baked\"\n * model. Use the `node.addDependency(dep)` method to circumvent that. This is done\n * automatically for the `restApi.latestDeployment` deployment.\n */\nexport class Deployment extends Resource {\n  /** @attribute */\n  public readonly deploymentId: string;\n  public readonly api: IRestApi;\n\n  private readonly resource: LatestDeploymentResource;\n\n  constructor(scope: Construct, id: string, props: DeploymentProps) {\n    super(scope, id);\n\n    this.resource = new LatestDeploymentResource(this, 'Resource', {\n      description: props.description,\n      restApi: props.api,\n    });\n\n    if (props.retainDeployments) {\n      this.resource.applyRemovalPolicy(RemovalPolicy.RETAIN);\n    }\n\n    this.api = props.api;\n    this.deploymentId = Lazy.string({ produce: () => this.resource.ref });\n\n    if (props.api instanceof RestApiBase) {\n      props.api._attachDeployment(this);\n    }\n  }\n\n  /**\n   * Adds a component to the hash that determines this Deployment resource's\n   * logical ID.\n   *\n   * This should be called by constructs of the API Gateway model that want to\n   * invalidate the deployment when their settings change. The component will\n   * be resolve()ed during synthesis so tokens are welcome.\n   */\n  public addToLogicalId(data: any) {\n    this.resource.addToLogicalId(data);\n  }\n\n  /**\n   * Quoting from CloudFormation's docs:\n   *\n   *   If you create an AWS::ApiGateway::RestApi resource and its methods (using\n   *   AWS::ApiGateway::Method) in the same template as your deployment, the\n   *   deployment must depend on the RestApi's methods. To create a dependency,\n   *   add a DependsOn attribute to the deployment. If you don't, AWS\n   *   CloudFormation creates the deployment right after it creates the RestApi\n   *   resource that doesn't contain any methods, and AWS CloudFormation\n   *   encounters the following error: The REST API doesn't contain any methods.\n   *\n   * @param method The method to add as a dependency of the deployment\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-deployment.html\n   * @see https://github.com/aws/aws-cdk/pull/6165\n   * @internal\n   */\n  public _addMethodDependency(method: Method) {\n    // adding a dependency between the constructs using `node.addDependency()`\n    // will create additional dependencies between `AWS::ApiGateway::Deployment`\n    // and the `AWS::Lambda::Permission` resources (children under Method),\n    // causing cyclic dependency errors. Hence, falling back to declaring\n    // dependencies between the underlying CfnResources.\n    this.node.addDependency(method.node.defaultChild as CfnResource);\n  }\n}\n\ninterface LatestDeploymentResourceProps {\n  readonly description?: string;\n  readonly restApi: IRestApi;\n}\n\nclass LatestDeploymentResource extends CfnDeployment {\n  private readonly hashComponents = new Array<any>();\n  private readonly originalLogicalId: string;\n  private readonly api: IRestApi;\n\n  constructor(scope: Construct, id: string, props: LatestDeploymentResourceProps) {\n    super(scope, id, {\n      description: props.description,\n      restApiId: props.restApi.restApiId,\n    });\n\n    this.api = props.restApi;\n    this.originalLogicalId = this.stack.getLogicalId(this);\n    this.overrideLogicalId(Lazy.uncachedString({ produce: () => this.calculateLogicalId() }));\n  }\n\n  /**\n   * Allows adding arbitrary data to the hashed logical ID of this deployment.\n   * This can be used to couple the deployment to the API Gateway model.\n   */\n  public addToLogicalId(data: unknown) {\n    // if the construct is locked, it means we are already synthesizing and then\n    // we can't modify the hash because we might have already calculated it.\n    if (this.node.locked) {\n      throw new Error('Cannot modify the logical ID when the construct is locked');\n    }\n\n    this.hashComponents.push(data);\n  }\n\n  private calculateLogicalId() {\n    const hash = [...this.hashComponents];\n\n    if (this.api instanceof RestApi || this.api instanceof SpecRestApi) { // Ignore IRestApi that are imported\n\n      // Add CfnRestApi to the logical id so a new deployment is triggered when any of its properties change.\n      const cfnRestApiCF = (this.api.node.defaultChild as any)._toCloudFormation();\n      hash.push(this.stack.resolve(cfnRestApiCF));\n    }\n\n    let lid = this.originalLogicalId;\n\n    // if hash components were added to the deployment, we use them to calculate\n    // a logical ID for the deployment resource.\n    if (hash.length > 0) {\n      const md5 = crypto.createHash('md5');\n      hash.map(x => this.stack.resolve(x)).forEach(c => md5.update(JSON.stringify(c)));\n      lid += md5.digest('hex');\n    }\n\n    return lid;\n  }\n}\n"],
  "mappings": "iNAAA,OAAA,QAAA,UACA,OAAA,QAAA,cAEA,uBAAA,QAAA,0BAEA,UAAA,QAAA,aAuDA,wBAAgC,QAAA,QAAQ,CAOtC,YAAY,MAAkB,GAAY,MAAsB,CAC9D,MAAM,MAAO,8EAEb,KAAK,SAAW,GAAI,0BAAyB,KAAM,WAAY,CAC7D,YAAa,MAAM,YACnB,QAAS,MAAM,MAGb,MAAM,mBACR,KAAK,SAAS,mBAAmB,OAAA,cAAc,QAGjD,KAAK,IAAM,MAAM,IACjB,KAAK,aAAe,OAAA,KAAK,OAAO,CAAE,QAAS,IAAM,KAAK,SAAS,MAE3D,MAAM,cAAe,WAAA,aACvB,MAAM,IAAI,kBAAkB,MAYzB,eAAe,KAAS,CAC7B,KAAK,SAAS,eAAe,MAmBxB,qBAAqB,OAAc,CAMxC,KAAK,KAAK,cAAc,OAAO,KAAK,eA7DxC,QAAA,WAAA,+GAsEA,sCAAuC,wBAAA,aAAa,CAKlD,YAAY,MAAkB,GAAY,MAAoC,CAC5E,MAAM,MAAO,GAAI,CACf,YAAa,MAAM,YACnB,UAAW,MAAM,QAAQ,YAPZ,KAAA,eAAiB,GAAI,OAUpC,KAAK,IAAM,MAAM,QACjB,KAAK,kBAAoB,KAAK,MAAM,aAAa,MACjD,KAAK,kBAAkB,OAAA,KAAK,eAAe,CAAE,QAAS,IAAM,KAAK,wBAO5D,eAAe,KAAa,CAGjC,GAAI,KAAK,KAAK,OACZ,KAAM,IAAI,OAAM,6DAGlB,KAAK,eAAe,KAAK,MAGnB,oBAAkB,CACxB,KAAM,MAAO,CAAC,GAAG,KAAK,gBAEtB,GAAI,KAAK,cAAe,WAAA,SAAW,KAAK,cAAe,WAAA,YAAa,CAGlE,KAAM,cAAgB,KAAK,IAAI,KAAK,aAAqB,oBACzD,KAAK,KAAK,KAAK,MAAM,QAAQ,eAG/B,GAAI,KAAM,KAAK,kBAIf,GAAI,KAAK,OAAS,EAAG,CACnB,KAAM,KAAM,OAAO,WAAW,OAC9B,KAAK,IAAI,GAAK,KAAK,MAAM,QAAQ,IAAI,QAAQ,GAAK,IAAI,OAAO,KAAK,UAAU,KAC5E,KAAO,IAAI,OAAO,OAGpB,MAAO",
  "names": []
}
