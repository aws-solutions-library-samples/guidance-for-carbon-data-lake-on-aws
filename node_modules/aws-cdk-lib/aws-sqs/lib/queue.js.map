{
  "version": 3,
  "sources": ["queue.ts"],
  "sourcesContent": ["import * as kms from '../../aws-kms';\nimport { Duration, RemovalPolicy, Stack, Token, ArnFormat } from '../../core';\nimport { Construct } from 'constructs';\nimport { IQueue, QueueAttributes, QueueBase } from './queue-base';\nimport { CfnQueue } from './sqs.generated';\nimport { validateProps } from './validate-props';\n\n/**\n * Properties for creating a new Queue\n */\nexport interface QueueProps {\n  /**\n   * A name for the queue.\n   *\n   * If specified and this is a FIFO queue, must end in the string '.fifo'.\n   *\n   * @default CloudFormation-generated name\n   */\n  readonly queueName?: string;\n\n  /**\n   * The number of seconds that Amazon SQS retains a message.\n   *\n   * You can specify an integer value from 60 seconds (1 minute) to 1209600\n   * seconds (14 days). The default value is 345600 seconds (4 days).\n   *\n   * @default Duration.days(4)\n   */\n  readonly retentionPeriod?: Duration;\n\n  /**\n   * The time in seconds that the delivery of all messages in the queue is delayed.\n   *\n   * You can specify an integer value of 0 to 900 (15 minutes). The default\n   * value is 0.\n   *\n   * @default 0\n   */\n  readonly deliveryDelay?: Duration;\n\n  /**\n   * The limit of how many bytes that a message can contain before Amazon SQS rejects it.\n   *\n   * You can specify an integer value from 1024 bytes (1 KiB) to 262144 bytes\n   * (256 KiB). The default value is 262144 (256 KiB).\n   *\n   * @default 256KiB\n   */\n  readonly maxMessageSizeBytes?: number;\n\n  /**\n   * Default wait time for ReceiveMessage calls.\n   *\n   * Does not wait if set to 0, otherwise waits this amount of seconds\n   * by default for messages to arrive.\n   *\n   * For more information, see Amazon SQS Long Poll.\n   *\n   *  @default 0\n   */\n  readonly receiveMessageWaitTime?: Duration;\n\n  /**\n   * Timeout of processing a single message.\n   *\n   * After dequeuing, the processor has this much time to handle the message\n   * and delete it from the queue before it becomes visible again for dequeueing\n   * by another processor.\n   *\n   * Values must be from 0 to 43200 seconds (12 hours). If you don't specify\n   * a value, AWS CloudFormation uses the default value of 30 seconds.\n   *\n   * @default Duration.seconds(30)\n   */\n  readonly visibilityTimeout?: Duration;\n\n  /**\n   * Send messages to this queue if they were unsuccessfully dequeued a number of times.\n   *\n   * @default no dead-letter queue\n   */\n  readonly deadLetterQueue?: DeadLetterQueue;\n\n  /**\n   * Whether the contents of the queue are encrypted, and by what type of key.\n   *\n   * Be aware that encryption is not available in all regions, please see the docs\n   * for current availability details.\n   *\n   * @default Unencrypted\n   */\n  readonly encryption?: QueueEncryption;\n\n  /**\n   * External KMS master key to use for queue encryption.\n   *\n   * Individual messages will be encrypted using data keys. The data keys in\n   * turn will be encrypted using this key, and reused for a maximum of\n   * `dataKeyReuseSecs` seconds.\n   *\n   * If the 'encryptionMasterKey' property is set, 'encryption' type will be\n   * implicitly set to \"KMS\".\n   *\n   * @default If encryption is set to KMS and not specified, a key will be created.\n   */\n  readonly encryptionMasterKey?: kms.IKey;\n\n  /**\n   * The length of time that Amazon SQS reuses a data key before calling KMS again.\n   *\n   * The value must be an integer between 60 (1 minute) and 86,400 (24\n   * hours). The default is 300 (5 minutes).\n   *\n   * @default Duration.minutes(5)\n   */\n  readonly dataKeyReuse?: Duration;\n\n  /**\n   * Whether this a first-in-first-out (FIFO) queue.\n   *\n   * @default false, unless queueName ends in '.fifo' or 'contentBasedDeduplication' is true.\n   */\n  readonly fifo?: boolean;\n\n  /**\n   * Specifies whether to enable content-based deduplication.\n   *\n   * During the deduplication interval (5 minutes), Amazon SQS treats\n   * messages that are sent with identical content (excluding attributes) as\n   * duplicates and delivers only one copy of the message.\n   *\n   * If you don't enable content-based deduplication and you want to deduplicate\n   * messages, provide an explicit deduplication ID in your SendMessage() call.\n   *\n   * (Only applies to FIFO queues.)\n   *\n   * @default false\n   */\n  readonly contentBasedDeduplication?: boolean;\n\n  /**\n   * For high throughput for FIFO queues, specifies whether message deduplication\n   * occurs at the message group or queue level.\n   *\n   * (Only applies to FIFO queues.)\n   *\n   * @default DeduplicationScope.QUEUE\n   */\n  readonly deduplicationScope?: DeduplicationScope;\n\n  /**\n   * For high throughput for FIFO queues, specifies whether the FIFO queue\n   * throughput quota applies to the entire queue or per message group.\n   *\n   * (Only applies to FIFO queues.)\n   *\n   * @default FifoThroughputLimit.PER_QUEUE\n   */\n  readonly fifoThroughputLimit?: FifoThroughputLimit;\n\n  /**\n   * Policy to apply when the user pool is removed from the stack\n   *\n   * Even though queues are technically stateful, their contents are transient and it\n   * is common to add and remove Queues while rearchitecting your application. The\n   * default is therefore `DESTROY`. Change it to `RETAIN` if the messages are so\n   * valuable that accidentally losing them would be unacceptable.\n   *\n   * @default RemovalPolicy.DESTROY\n   */\n  readonly removalPolicy?: RemovalPolicy;\n}\n\n/**\n * Dead letter queue settings\n */\nexport interface DeadLetterQueue {\n  /**\n   * The dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.\n   */\n  readonly queue: IQueue;\n\n  /**\n   * The number of times a message can be unsuccesfully dequeued before being moved to the dead-letter queue.\n   */\n  readonly maxReceiveCount: number;\n}\n\n/**\n * What kind of encryption to apply to this queue\n */\nexport enum QueueEncryption {\n  /**\n   * Messages in the queue are not encrypted\n   */\n  UNENCRYPTED = 'NONE',\n\n  /**\n   * Server-side KMS encryption with a master key managed by SQS.\n   */\n  KMS_MANAGED = 'MANAGED',\n\n  /**\n   * Server-side encryption with a KMS key managed by the user.\n   *\n   * If `encryptionKey` is specified, this key will be used, otherwise, one will be defined.\n   */\n  KMS = 'KMS',\n}\n\n/**\n * What kind of deduplication scope to apply\n */\nexport enum DeduplicationScope {\n  /**\n   * Deduplication occurs at the message group level\n   */\n  MESSAGE_GROUP = 'messageGroup',\n  /**\n   * Deduplication occurs at the message queue level\n   */\n  QUEUE = 'queue',\n}\n\n/**\n * Whether the FIFO queue throughput quota applies to the entire queue or per message group\n */\nexport enum FifoThroughputLimit {\n  /**\n   * Throughput quota applies per queue\n   */\n  PER_QUEUE = 'perQueue',\n  /**\n   * Throughput quota applies per message group id\n   */\n  PER_MESSAGE_GROUP_ID = 'perMessageGroupId',\n}\n\n/**\n * A new Amazon SQS queue\n */\nexport class Queue extends QueueBase {\n\n  /**\n   * Import an existing SQS queue provided an ARN\n   *\n   * @param scope The parent creating construct\n   * @param id The construct's name\n   * @param queueArn queue ARN (i.e. arn:aws:sqs:us-east-2:444455556666:queue1)\n   */\n  public static fromQueueArn(scope: Construct, id: string, queueArn: string): IQueue {\n    return Queue.fromQueueAttributes(scope, id, { queueArn });\n  }\n\n  /**\n   * Import an existing queue\n   */\n  public static fromQueueAttributes(scope: Construct, id: string, attrs: QueueAttributes): IQueue {\n    const stack = Stack.of(scope);\n    const parsedArn = stack.splitArn(attrs.queueArn, ArnFormat.NO_RESOURCE_NAME);\n    const queueName = attrs.queueName || parsedArn.resource;\n    const queueUrl = attrs.queueUrl || `https://sqs.${parsedArn.region}.${stack.urlSuffix}/${parsedArn.account}/${queueName}`;\n\n    class Import extends QueueBase {\n      public readonly queueArn = attrs.queueArn; // arn:aws:sqs:us-east-1:123456789012:queue1\n      public readonly queueUrl = queueUrl;\n      public readonly queueName = queueName;\n      public readonly encryptionMasterKey = attrs.keyArn\n        ? kms.Key.fromKeyArn(this, 'Key', attrs.keyArn)\n        : undefined;\n      public readonly fifo: boolean = this.determineFifo();\n\n      protected readonly autoCreatePolicy = false;\n\n      /**\n       * Determine fifo flag based on queueName and fifo attribute\n       */\n      private determineFifo(): boolean {\n        if (Token.isUnresolved(this.queueArn)) {\n          return attrs.fifo || false;\n        } else {\n          if (typeof attrs.fifo !== 'undefined') {\n            if (attrs.fifo && !queueName.endsWith('.fifo')) {\n              throw new Error(\"FIFO queue names must end in '.fifo'\");\n            }\n            if (!attrs.fifo && queueName.endsWith('.fifo')) {\n              throw new Error(\"Non-FIFO queue name may not end in '.fifo'\");\n            }\n          }\n          return queueName.endsWith('.fifo') ? true : false;\n        }\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * The ARN of this queue\n   */\n  public readonly queueArn: string;\n\n  /**\n   * The name of this queue\n   */\n  public readonly queueName: string;\n\n  /**\n   * The URL of this queue\n   */\n  public readonly queueUrl: string;\n\n  /**\n   * If this queue is encrypted, this is the KMS key.\n   */\n  public readonly encryptionMasterKey?: kms.IKey;\n\n  /**\n   * Whether this queue is an Amazon SQS FIFO queue. If false, this is a standard queue.\n   */\n  public readonly fifo: boolean;\n\n  /**\n   * If this queue is configured with a dead-letter queue, this is the dead-letter queue settings.\n   */\n  public readonly deadLetterQueue?: DeadLetterQueue;\n\n  protected readonly autoCreatePolicy = true;\n\n  constructor(scope: Construct, id: string, props: QueueProps = {}) {\n    super(scope, id, {\n      physicalName: props.queueName,\n    });\n\n    validateProps(props);\n\n    const redrivePolicy = props.deadLetterQueue\n      ? {\n        deadLetterTargetArn: props.deadLetterQueue.queue.queueArn,\n        maxReceiveCount: props.deadLetterQueue.maxReceiveCount,\n      }\n      : undefined;\n\n    const { encryptionMasterKey, encryptionProps } = _determineEncryptionProps.call(this);\n\n    const fifoProps = this.determineFifoProps(props);\n    this.fifo = fifoProps.fifoQueue || false;\n\n    const queue = new CfnQueue(this, 'Resource', {\n      queueName: this.physicalName,\n      ...fifoProps,\n      ...encryptionProps,\n      redrivePolicy,\n      delaySeconds: props.deliveryDelay && props.deliveryDelay.toSeconds(),\n      maximumMessageSize: props.maxMessageSizeBytes,\n      messageRetentionPeriod: props.retentionPeriod && props.retentionPeriod.toSeconds(),\n      receiveMessageWaitTimeSeconds: props.receiveMessageWaitTime && props.receiveMessageWaitTime.toSeconds(),\n      visibilityTimeout: props.visibilityTimeout && props.visibilityTimeout.toSeconds(),\n    });\n    queue.applyRemovalPolicy(props.removalPolicy ?? RemovalPolicy.DESTROY);\n\n    this.queueArn = this.getResourceArnAttribute(queue.attrArn, {\n      service: 'sqs',\n      resource: this.physicalName,\n    });\n    this.queueName = this.getResourceNameAttribute(queue.attrQueueName);\n    this.encryptionMasterKey = encryptionMasterKey;\n    this.queueUrl = queue.ref;\n    this.deadLetterQueue = props.deadLetterQueue;\n\n    function _determineEncryptionProps(this: Queue): { encryptionProps: EncryptionProps, encryptionMasterKey?: kms.IKey } {\n      let encryption = props.encryption || QueueEncryption.UNENCRYPTED;\n\n      if (encryption !== QueueEncryption.KMS && props.encryptionMasterKey) {\n        encryption = QueueEncryption.KMS; // KMS is implied by specifying an encryption key\n      }\n\n      if (encryption === QueueEncryption.UNENCRYPTED) {\n        return { encryptionProps: {} };\n      }\n\n      if (encryption === QueueEncryption.KMS_MANAGED) {\n        return {\n          encryptionProps: {\n            kmsMasterKeyId: 'alias/aws/sqs',\n            kmsDataKeyReusePeriodSeconds: props.dataKeyReuse && props.dataKeyReuse.toSeconds(),\n          },\n        };\n      }\n\n      if (encryption === QueueEncryption.KMS) {\n        const masterKey = props.encryptionMasterKey || new kms.Key(this, 'Key', {\n          description: `Created by ${this.node.path}`,\n        });\n\n        return {\n          encryptionMasterKey: masterKey,\n          encryptionProps: {\n            kmsMasterKeyId: masterKey.keyArn,\n            kmsDataKeyReusePeriodSeconds: props.dataKeyReuse && props.dataKeyReuse.toSeconds(),\n          },\n        };\n      }\n\n      throw new Error(`Unexpected 'encryptionType': ${encryption}`);\n    }\n  }\n\n  /**\n   * Look at the props, see if the FIFO props agree, and return the correct subset of props\n   */\n  private determineFifoProps(props: QueueProps): FifoProps {\n    // Check if any of the signals that we have say that this is a FIFO queue.\n    let fifoQueue = props.fifo;\n    const queueName = props.queueName;\n    if (typeof fifoQueue === 'undefined' && queueName && !Token.isUnresolved(queueName) && queueName.endsWith('.fifo')) { fifoQueue = true; }\n    if (typeof fifoQueue === 'undefined' && props.contentBasedDeduplication) { fifoQueue = true; }\n    if (typeof fifoQueue === 'undefined' && props.deduplicationScope) { fifoQueue = true; }\n    if (typeof fifoQueue === 'undefined' && props.fifoThroughputLimit) { fifoQueue = true; }\n\n    // If we have a name, see that it agrees with the FIFO setting\n    if (typeof queueName === 'string') {\n      if (fifoQueue && !queueName.endsWith('.fifo')) {\n        throw new Error(\"FIFO queue names must end in '.fifo'\");\n      }\n      if (!fifoQueue && queueName.endsWith('.fifo')) {\n        throw new Error(\"Non-FIFO queue name may not end in '.fifo'\");\n      }\n    }\n\n    if (props.contentBasedDeduplication && !fifoQueue) {\n      throw new Error('Content-based deduplication can only be defined for FIFO queues');\n    }\n\n    if (props.deduplicationScope && !fifoQueue) {\n      throw new Error('Deduplication scope can only be defined for FIFO queues');\n    }\n\n    if (props.fifoThroughputLimit && !fifoQueue) {\n      throw new Error('FIFO throughput limit can only be defined for FIFO queues');\n    }\n\n    return {\n      contentBasedDeduplication: props.contentBasedDeduplication,\n      deduplicationScope: props.deduplicationScope,\n      fifoThroughputLimit: props.fifoThroughputLimit,\n      fifoQueue,\n    };\n  }\n}\n\ninterface FifoProps {\n  readonly fifoQueue?: boolean;\n  readonly contentBasedDeduplication?: boolean;\n  readonly deduplicationScope?: DeduplicationScope;\n  readonly fifoThroughputLimit?: FifoThroughputLimit;\n}\n\ninterface EncryptionProps {\n  readonly kmsMasterKeyId?: string;\n  readonly kmsDataKeyReusePeriodSeconds?: number;\n}\n"],
  "mappings": "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",
  "names": []
}
