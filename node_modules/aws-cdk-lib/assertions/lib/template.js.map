{
  "version": 3,
  "sources": ["template.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport { Stack, Stage } from '../../core';\nimport * as fs from 'fs-extra';\nimport { Match } from './match';\nimport { Matcher } from './matcher';\nimport { findConditions, hasCondition } from './private/conditions';\nimport { checkTemplateForCyclicDependencies } from './private/cyclic';\nimport { findMappings, hasMapping } from './private/mappings';\nimport { findOutputs, hasOutput } from './private/outputs';\nimport { findParameters, hasParameter } from './private/parameters';\nimport { countResources, findResources, hasResource, hasResourceProperties } from './private/resources';\nimport { Template as TemplateType } from './private/template';\n\n/**\n * Suite of assertions that can be run on a CDK stack.\n * Typically used, as part of unit tests, to validate that the rendered\n * CloudFormation template has expected resources and properties.\n */\nexport class Template {\n\n  /**\n   * Base your assertions on the CloudFormation template synthesized by a CDK `Stack`.\n   * @param stack the CDK Stack to run assertions on\n   */\n  public static fromStack(stack: Stack): Template {\n    return new Template(toTemplate(stack));\n  }\n\n  /**\n   * Base your assertions from an existing CloudFormation template formatted as an in-memory\n   * JSON object.\n   * @param template the CloudFormation template formatted as a nested set of records\n   */\n  public static fromJSON(template: { [key: string] : any }): Template {\n    return new Template(template);\n  }\n\n  /**\n   * Base your assertions from an existing CloudFormation template formatted as a\n   * JSON string.\n   * @param template the CloudFormation template in\n   */\n  public static fromString(template: string): Template {\n    return new Template(JSON.parse(template));\n  }\n\n  private readonly template: TemplateType;\n\n  private constructor(template: { [key: string]: any }) {\n    this.template = template as TemplateType;\n    checkTemplateForCyclicDependencies(this.template);\n  }\n\n  /**\n   * The CloudFormation template deserialized into an object.\n   */\n  public toJSON(): { [key: string]: any } {\n    return this.template;\n  }\n\n  /**\n   * Assert that the given number of resources of the given type exist in the\n   * template.\n   * @param type the resource type; ex: `AWS::S3::Bucket`\n   * @param count number of expected instances\n   */\n  public resourceCountIs(type: string, count: number): void {\n    const counted = countResources(this.template, type);\n    if (counted !== count) {\n      throw new Error(`Expected ${count} resources of type ${type} but found ${counted}`);\n    }\n  }\n\n  /**\n   * Assert that a resource of the given type and properties exists in the\n   * CloudFormation template.\n   * By default, performs partial matching on the `Properties` key of the resource, via the\n   * `Match.objectLike()`. To configure different behavour, use other matchers in the `Match` class.\n   * @param type the resource type; ex: `AWS::S3::Bucket`\n   * @param props the 'Properties' section of the resource as should be expected in the template.\n   */\n  public hasResourceProperties(type: string, props: any): void {\n    const matchError = hasResourceProperties(this.template, type, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Assert that a resource of the given type and given definition exists in the\n   * CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param type the resource type; ex: `AWS::S3::Bucket`\n   * @param props the entire defintion of the resource as should be expected in the template.\n   */\n  public hasResource(type: string, props: any): void {\n    const matchError = hasResource(this.template, type, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching resources of a given type and properties in the CloudFormation template.\n   * @param type the type to match in the CloudFormation template\n   * @param props by default, matches all resources with the given type.\n   * When a literal is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findResources(type: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findResources(this.template, type, props);\n  }\n\n  /**\n   * Assert that a Parameter with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the parameter, via the `Match.objectLike()`.\n   * To configure different behavior, use other matchers in the `Match` class.\n   * @param logicalId the name of the parameter. Provide `'*'` to match all parameters in the template.\n   * @param props the parameter as should be expected in the template.\n   */\n  public hasParameter(logicalId: string, props: any): void {\n    const matchError = hasParameter(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Parameters that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the parameter. Provide `'*'` to match all parameters in the template.\n   * @param props by default, matches all Parameters in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findParameters(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findParameters(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that an Output with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param logicalId the name of the output. Provide `'*'` to match all outputs in the template.\n   * @param props the output as should be expected in the template.\n   */\n  public hasOutput(logicalId: string, props: any): void {\n    const matchError = hasOutput(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Outputs that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the output. Provide `'*'` to match all outputs in the template.\n   * @param props by default, matches all Outputs in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findOutputs(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findOutputs(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that a Mapping with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param logicalId the name of the mapping. Provide `'*'` to match all mappings in the template.\n   * @param props the output as should be expected in the template.\n   */\n  public hasMapping(logicalId: string, props: any): void {\n    const matchError = hasMapping(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Mappings that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the mapping. Provide `'*'` to match all mappings in the template.\n   * @param props by default, matches all Mappings in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findMappings(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findMappings(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that a Condition with the given properties exists in the CloudFormation template.\n   * By default, performs partial matching on the resource, via the `Match.objectLike()`.\n   * To configure different behavour, use other matchers in the `Match` class.\n   * @param logicalId the name of the mapping. Provide `'*'` to match all conditions in the template.\n   * @param props the output as should be expected in the template.\n   */\n  public hasCondition(logicalId: string, props: any): void {\n    const matchError = hasCondition(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n  /**\n   * Get the set of matching Conditions that match the given properties in the CloudFormation template.\n   * @param logicalId the name of the condition. Provide `'*'` to match all conditions in the template.\n   * @param props by default, matches all Conditions in the template.\n   * When a literal object is provided, performs a partial match via `Match.objectLike()`.\n   * Use the `Match` APIs to configure a different behaviour.\n   */\n  public findConditions(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findConditions(this.template, logicalId, props);\n  }\n\n  /**\n   * Assert that the CloudFormation template matches the given value\n   * @param expected the expected CloudFormation template as key-value pairs.\n   */\n  public templateMatches(expected: any): void {\n    const matcher = Matcher.isMatcher(expected) ? expected : Match.objectLike(expected);\n    const result = matcher.test(this.template);\n\n    if (result.hasFailed()) {\n      throw new Error([\n        'Template did not match as expected. The following mismatches were found:',\n        ...result.toHumanStrings().map(s => `\\t${s}`),\n      ].join('\\n'));\n    }\n  }\n}\n\nfunction toTemplate(stack: Stack): any {\n  const root = stack.node.root;\n  if (!Stage.isStage(root)) {\n    throw new Error('unexpected: all stacks must be part of a Stage or an App');\n  }\n\n  const assembly = root.synth();\n  if (stack.nestedStackParent) {\n    // if this is a nested stack (it has a parent), then just read the template as a string\n    return JSON.parse(fs.readFileSync(path.join(assembly.directory, stack.templateFile)).toString('utf-8'));\n  }\n  return assembly.getStackArtifact(stack.artifactId).template;\n}"],
  "mappings": "+MAAA,KAAA,QAAA,QACA,OAAA,QAAA,cACA,GAAA,QAAA,YACA,QAAA,QAAA,WACA,UAAA,QAAA,aACA,aAAA,QAAA,wBACA,SAAA,QAAA,oBACA,WAAA,QAAA,sBACA,UAAA,QAAA,qBACA,aAAA,QAAA,wBACA,YAAA,QAAA,uBAQA,cAAqB,CA8BnB,YAAoB,SAAgC,CAClD,KAAK,SAAW,SAChB,SAAA,mCAAmC,KAAK,gBA1B5B,WAAU,MAAY,yDAC3B,GAAI,UAAS,WAAW,cAQnB,UAAS,SAAiC,CACtD,MAAO,IAAI,UAAS,gBAQR,YAAW,SAAgB,CACvC,MAAO,IAAI,UAAS,KAAK,MAAM,WAa1B,QAAM,CACX,MAAO,MAAK,SASP,gBAAgB,KAAc,MAAa,CAChD,KAAM,SAAU,YAAA,eAAe,KAAK,SAAU,MAC9C,GAAI,UAAY,MACd,KAAM,IAAI,OAAM,YAAY,2BAA2B,kBAAkB,WAYtE,sBAAsB,KAAc,MAAU,CACnD,KAAM,YAAa,YAAA,sBAAsB,KAAK,SAAU,KAAM,OAC9D,GAAI,WACF,KAAM,IAAI,OAAM,YAYb,YAAY,KAAc,MAAU,CACzC,KAAM,YAAa,YAAA,YAAY,KAAK,SAAU,KAAM,OACpD,GAAI,WACF,KAAM,IAAI,OAAM,YAWb,cAAc,KAAc,MAAa,GAAE,CAChD,MAAO,aAAA,cAAc,KAAK,SAAU,KAAM,OAUrC,aAAa,UAAmB,MAAU,CAC/C,KAAM,YAAa,aAAA,aAAa,KAAK,SAAU,UAAW,OAC1D,GAAI,WACF,KAAM,IAAI,OAAM,YAWb,eAAe,UAAmB,MAAa,GAAE,CACtD,MAAO,cAAA,eAAe,KAAK,SAAU,UAAW,OAU3C,UAAU,UAAmB,MAAU,CAC5C,KAAM,YAAa,UAAA,UAAU,KAAK,SAAU,UAAW,OACvD,GAAI,WACF,KAAM,IAAI,OAAM,YAWb,YAAY,UAAmB,MAAa,GAAE,CACnD,MAAO,WAAA,YAAY,KAAK,SAAU,UAAW,OAUxC,WAAW,UAAmB,MAAU,CAC7C,KAAM,YAAa,WAAA,WAAW,KAAK,SAAU,UAAW,OACxD,GAAI,WACF,KAAM,IAAI,OAAM,YAWb,aAAa,UAAmB,MAAa,GAAE,CACpD,MAAO,YAAA,aAAa,KAAK,SAAU,UAAW,OAUzC,aAAa,UAAmB,MAAU,CAC/C,KAAM,YAAa,aAAA,aAAa,KAAK,SAAU,UAAW,OAC1D,GAAI,WACF,KAAM,IAAI,OAAM,YAWb,eAAe,UAAmB,MAAa,GAAE,CACtD,MAAO,cAAA,eAAe,KAAK,SAAU,UAAW,OAO3C,gBAAgB,SAAa,CAElC,KAAM,QAAS,AADC,WAAA,QAAQ,UAAU,UAAY,SAAW,QAAA,MAAM,WAAW,WACnD,KAAK,KAAK,UAEjC,GAAI,OAAO,YACT,KAAM,IAAI,OAAM,CACd,2EACA,GAAG,OAAO,iBAAiB,IAAI,GAAK,IAAK,MACzC,KAAK;KAhNb,QAAA,SAAA,qGAqNA,oBAAoB,MAAY,CAC9B,KAAM,MAAO,MAAM,KAAK,KACxB,GAAI,CAAC,OAAA,MAAM,QAAQ,MACjB,KAAM,IAAI,OAAM,4DAGlB,KAAM,UAAW,KAAK,QACtB,MAAI,OAAM,kBAED,KAAK,MAAM,GAAG,aAAa,KAAK,KAAK,SAAS,UAAW,MAAM,eAAe,SAAS,UAEzF,SAAS,iBAAiB,MAAM,YAAY",
  "names": []
}
