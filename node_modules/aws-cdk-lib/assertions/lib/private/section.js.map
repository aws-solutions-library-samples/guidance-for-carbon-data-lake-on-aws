{
  "version": 3,
  "sources": ["section.ts"],
  "sourcesContent": ["import { Match } from '../match';\nimport { Matcher, MatchResult } from '../matcher';\n\nexport type MatchSuccess = { match: true, matches: {[key: string]: any} };\nexport type MatchFailure = { match: false, closestResult?: MatchResult, analyzedCount: number };\n\nexport function matchSection(section: any, props: any): MatchSuccess | MatchFailure {\n  const matcher = Matcher.isMatcher(props) ? props : Match.objectLike(props);\n  let closestResult: MatchResult | undefined = undefined;\n  let matching: {[key: string]: any} = {};\n  let count = 0;\n\n  eachEntryInSection(\n    section,\n\n    (logicalId, entry) => {\n      const result = matcher.test(entry);\n      result.finished();\n      if (!result.hasFailed()) {\n        matching[logicalId] = entry;\n      } else {\n        count++;\n        if (closestResult === undefined || closestResult.failCount > result.failCount) {\n          closestResult = result;\n        }\n      }\n    },\n  );\n  if (Object.keys(matching).length > 0) {\n    return { match: true, matches: matching };\n  } else {\n    return { match: false, closestResult, analyzedCount: count };\n  }\n}\n\nfunction eachEntryInSection(\n  section: any,\n  cb: (logicalId: string, entry: {[key: string]: any}) => void): void {\n\n  for (const logicalId of Object.keys(section ?? {})) {\n    const resource: { [key: string]: any } = section[logicalId];\n    cb(logicalId, resource);\n  }\n}\n\nexport function formatFailure(closestResult: MatchResult): string {\n  return [\n    'The closest result is:',\n    leftPad(JSON.stringify(closestResult.target, undefined, 2)),\n    'with the following mismatches:',\n    ...closestResult.toHumanStrings().map(s => `\\t${s}`),\n  ].join('\\n');\n}\n\nfunction leftPad(x: string, indent: number = 2): string {\n  const pad = ' '.repeat(indent);\n  return pad + x.split('\\n').join(`\\n${pad}`);\n}\n\nexport function filterLogicalId(section: { [key: string]: {} }, logicalId: string): { [key: string]: {} } {\n  // default signal for all logicalIds is '*'\n  if (logicalId === '*') return section;\n\n  return Object.entries(section ?? {})\n    .filter(([k, _]) => k === logicalId)\n    .reduce((agg, [k, v]) => { return { ...agg, [k]: v }; }, {});\n}\n"],
  "mappings": "8IAAA,KAAA,SAAA,QAAA,YACA,UAAA,QAAA,cAKA,sBAA6B,QAAc,MAAU,CACnD,KAAM,SAAU,UAAA,QAAQ,UAAU,OAAS,MAAQ,QAAA,MAAM,WAAW,OACpE,GAAI,eACA,SAAiC,GACjC,MAAQ,EAkBZ,MAhBA,oBACE,QAEA,CAAC,UAAW,QAAS,CACnB,KAAM,QAAS,QAAQ,KAAK,OAC5B,OAAO,WACP,AAAK,OAAO,YAGV,SACI,iBAAkB,QAAa,cAAc,UAAY,OAAO,YAClE,eAAgB,SAJlB,SAAS,WAAa,QASxB,OAAO,KAAK,UAAU,OAAS,EAC1B,CAAE,MAAO,GAAM,QAAS,UAExB,CAAE,MAAO,GAAO,cAAe,cAAe,OAzBzD,QAAA,aAAA,aA6BA,4BACE,QACA,GAA4D,CAE5D,SAAW,aAAa,QAAO,KAAK,SAAO,KAAP,QAAW,IAAK,CAClD,KAAM,UAAmC,QAAQ,WACjD,GAAG,UAAW,WAIlB,uBAA8B,cAA0B,CACtD,MAAO,CACL,yBACA,QAAQ,KAAK,UAAU,cAAc,OAAQ,OAAW,IACxD,iCACA,GAAG,cAAc,iBAAiB,IAAI,GAAK,IAAK,MAChD,KAAK;GANT,QAAA,cAAA,cASA,iBAAiB,EAAW,OAAiB,EAAC,CAC5C,KAAM,KAAM,IAAI,OAAO,QACvB,MAAO,KAAM,EAAE,MAAM;GAAM,KAAK;EAAK,OAGvC,yBAAgC,QAAgC,UAAiB,CAE/E,MAAI,aAAc,IAAY,QAEvB,OAAO,QAAQ,SAAO,KAAP,QAAW,IAC9B,OAAO,CAAC,CAAC,EAAG,KAAO,IAAM,WACzB,OAAO,CAAC,IAAK,CAAC,EAAG,KAAgB,KAAK,KAAM,GAAI,IAAQ,IAN7D,QAAA,gBAAA",
  "names": []
}
