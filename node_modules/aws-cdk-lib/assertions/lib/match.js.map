{
  "version": 3,
  "sources": ["match.ts"],
  "sourcesContent": ["import { Matcher, MatchResult } from './matcher';\nimport { AbsentMatch } from './private/matchers/absent';\nimport { getType } from './private/type';\n\n/**\n * Partial and special matching during template assertions.\n */\nexport abstract class Match {\n  /**\n   * Use this matcher in the place of a field's value, if the field must not be present.\n   */\n  public static absent(): Matcher {\n    return new AbsentMatch('absent');\n  }\n\n  /**\n   * Matches the specified pattern with the array found in the same relative path of the target.\n   * The set of elements (or matchers) must be in the same order as would be found.\n   * @param pattern the pattern to match\n   */\n  public static arrayWith(pattern: any[]): Matcher {\n    return new ArrayMatch('arrayWith', pattern);\n  }\n\n  /**\n   * Matches the specified pattern with the array found in the same relative path of the target.\n   * The set of elements (or matchers) must match exactly and in order.\n   * @param pattern the pattern to match\n   */\n  public static arrayEquals(pattern: any[]): Matcher {\n    return new ArrayMatch('arrayEquals', pattern, { subsequence: false });\n  }\n\n  /**\n   * Deep exact matching of the specified pattern to the target.\n   * @param pattern the pattern to match\n   */\n  public static exact(pattern: any): Matcher {\n    return new LiteralMatch('exact', pattern, { partialObjects: false });\n  }\n\n  /**\n   * Matches the specified pattern to an object found in the same relative path of the target.\n   * The keys and their values (or matchers) must be present in the target but the target can be a superset.\n   * @param pattern the pattern to match\n   */\n  public static objectLike(pattern: {[key: string]: any}): Matcher {\n    return new ObjectMatch('objectLike', pattern);\n  }\n\n  /**\n   * Matches the specified pattern to an object found in the same relative path of the target.\n   * The keys and their values (or matchers) must match exactly with the target.\n   * @param pattern the pattern to match\n   */\n  public static objectEquals(pattern: {[key: string]: any}): Matcher {\n    return new ObjectMatch('objectEquals', pattern, { partial: false });\n  }\n\n  /**\n   * Matches any target which does NOT follow the specified pattern.\n   * @param pattern the pattern to NOT match\n   */\n  public static not(pattern: any): Matcher {\n    return new NotMatch('not', pattern);\n  }\n\n  /**\n   * Matches any string-encoded JSON and applies the specified pattern after parsing it.\n   * @param pattern the pattern to match after parsing the encoded JSON.\n   */\n  public static serializedJson(pattern: any): Matcher {\n    return new SerializedJson('serializedJson', pattern);\n  }\n\n  /**\n   * Matches any non-null value at the target.\n   */\n  public static anyValue(): Matcher {\n    return new AnyMatch('anyValue');\n  }\n\n  /**\n   * Matches targets according to a regular expression\n   */\n  public static stringLikeRegexp(pattern: string): Matcher {\n    return new StringLikeRegexpMatch('stringLikeRegexp', pattern);\n  }\n}\n\n/**\n * Options when initializing the `LiteralMatch` class.\n */\ninterface LiteralMatchOptions {\n  /**\n   * Whether objects nested at any level should be matched partially.\n   * @default false\n   */\n  readonly partialObjects?: boolean;\n}\n\n/**\n * A Match class that expects the target to match with the pattern exactly.\n * The pattern may be nested with other matchers that are then deletegated to.\n */\nclass LiteralMatch extends Matcher {\n  private readonly partialObjects: boolean;\n\n  constructor(\n    public readonly name: string,\n    private readonly pattern: any,\n    options: LiteralMatchOptions = {}) {\n\n    super();\n    this.partialObjects = options.partialObjects ?? false;\n\n    if (Matcher.isMatcher(this.pattern)) {\n      throw new Error('LiteralMatch cannot directly contain another matcher. ' +\n        'Remove the top-level matcher or nest it more deeply.');\n    }\n  }\n\n  public test(actual: any): MatchResult {\n    if (Array.isArray(this.pattern)) {\n      return new ArrayMatch(this.name, this.pattern, { subsequence: false, partialObjects: this.partialObjects }).test(actual);\n    }\n\n    if (typeof this.pattern === 'object') {\n      return new ObjectMatch(this.name, this.pattern, { partial: this.partialObjects }).test(actual);\n    }\n\n    const result = new MatchResult(actual);\n    if (typeof this.pattern !== typeof actual) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected type ${typeof this.pattern} but received ${getType(actual)}`,\n      });\n      return result;\n    }\n\n    if (actual !== this.pattern) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected ${this.pattern} but received ${actual}`,\n      });\n    }\n\n    return result;\n  }\n}\n\n/**\n * Options when initializing the `ArrayMatch` class.\n */\ninterface ArrayMatchOptions {\n  /**\n   * Whether the pattern is a subsequence of the target.\n   * A subsequence is a sequence that can be derived from another sequence by deleting\n   * some or no elements without changing the order of the remaining elements.\n   * @default true\n   */\n  readonly subsequence?: boolean;\n\n  /**\n   * Whether to continue matching objects inside the array partially\n   *\n   * @default false\n   */\n  readonly partialObjects?: boolean;\n}\n\n/**\n * Match class that matches arrays.\n */\nclass ArrayMatch extends Matcher {\n  private readonly subsequence: boolean;\n  private readonly partialObjects: boolean;\n\n  constructor(\n    public readonly name: string,\n    private readonly pattern: any[],\n    options: ArrayMatchOptions = {}) {\n\n    super();\n    this.subsequence = options.subsequence ?? true;\n    this.partialObjects = options.partialObjects ?? false;\n  }\n\n  public test(actual: any): MatchResult {\n    if (!Array.isArray(actual)) {\n      return new MatchResult(actual).recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected type array but received ${getType(actual)}`,\n      });\n    }\n    if (!this.subsequence && this.pattern.length !== actual.length) {\n      return new MatchResult(actual).recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected array of length ${this.pattern.length} but received ${actual.length}`,\n      });\n    }\n\n    let patternIdx = 0;\n    let actualIdx = 0;\n\n    const result = new MatchResult(actual);\n    while (patternIdx < this.pattern.length && actualIdx < actual.length) {\n      const patternElement = this.pattern[patternIdx];\n\n      const matcher = Matcher.isMatcher(patternElement)\n        ? patternElement\n        : new LiteralMatch(this.name, patternElement, { partialObjects: this.partialObjects });\n\n      const matcherName = matcher.name;\n      if (this.subsequence && (matcherName == 'absent' || matcherName == 'anyValue')) {\n        // array subsequence matcher is not compatible with anyValue() or absent() matcher. They don't make sense to be used together.\n        throw new Error(`The Matcher ${matcherName}() cannot be nested within arrayWith()`);\n      }\n\n      const innerResult = matcher.test(actual[actualIdx]);\n\n      if (!this.subsequence || !innerResult.hasFailed()) {\n        result.compose(`[${actualIdx}]`, innerResult);\n        patternIdx++;\n        actualIdx++;\n      } else {\n        actualIdx++;\n      }\n    }\n\n    for (; patternIdx < this.pattern.length; patternIdx++) {\n      const pattern = this.pattern[patternIdx];\n      const element = (Matcher.isMatcher(pattern) || typeof pattern === 'object') ? ' ' : ` [${pattern}] `;\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Missing element${element}at pattern index ${patternIdx}`,\n      });\n    }\n\n    return result;\n  }\n}\n\n/**\n * Options when initializing `ObjectMatch` class.\n */\ninterface ObjectMatchOptions {\n  /**\n   * Whether the pattern should partially match with the target object.\n   * The target object can contain more keys than expected by the pattern.\n   * @default true\n   */\n  readonly partial?: boolean;\n}\n\n/**\n * Match class that matches objects.\n */\nclass ObjectMatch extends Matcher {\n  private readonly partial: boolean;\n\n  constructor(\n    public readonly name: string,\n    private readonly pattern: {[key: string]: any},\n    options: ObjectMatchOptions = {}) {\n\n    super();\n    this.partial = options.partial ?? true;\n  }\n\n  public test(actual: any): MatchResult {\n    if (typeof actual !== 'object' || Array.isArray(actual)) {\n      return new MatchResult(actual).recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected type object but received ${getType(actual)}`,\n      });\n    }\n\n    const result = new MatchResult(actual);\n    if (!this.partial) {\n      for (const a of Object.keys(actual)) {\n        if (!(a in this.pattern)) {\n          result.recordFailure({\n            matcher: this,\n            path: [`/${a}`],\n            message: 'Unexpected key',\n          });\n        }\n      }\n    }\n\n    for (const [patternKey, patternVal] of Object.entries(this.pattern)) {\n      if (!(patternKey in actual) && !(patternVal instanceof AbsentMatch)) {\n        result.recordFailure({\n          matcher: this,\n          path: [`/${patternKey}`],\n          message: 'Missing key',\n        });\n        continue;\n      }\n      const matcher = Matcher.isMatcher(patternVal) ?\n        patternVal :\n        new LiteralMatch(this.name, patternVal, { partialObjects: this.partial });\n      const inner = matcher.test(actual[patternKey]);\n      result.compose(`/${patternKey}`, inner);\n    }\n\n    return result;\n  }\n}\n\nclass SerializedJson extends Matcher {\n  constructor(\n    public readonly name: string,\n    private readonly pattern: any,\n  ) {\n    super();\n  };\n\n  public test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n    if (getType(actual) !== 'string') {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected JSON as a string but found ${getType(actual)}`,\n      });\n      return result;\n    }\n    let parsed;\n    try {\n      parsed = JSON.parse(actual);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        result.recordFailure({\n          matcher: this,\n          path: [],\n          message: `Invalid JSON string: ${actual}`,\n        });\n        return result;\n      } else {\n        throw err;\n      }\n    }\n\n    const matcher = Matcher.isMatcher(this.pattern) ? this.pattern : new LiteralMatch(this.name, this.pattern);\n    const innerResult = matcher.test(parsed);\n    result.compose(`(${this.name})`, innerResult);\n    return result;\n  }\n}\n\nclass NotMatch extends Matcher {\n  constructor(\n    public readonly name: string,\n    private readonly pattern: {[key: string]: any}) {\n\n    super();\n  }\n\n  public test(actual: any): MatchResult {\n    const matcher = Matcher.isMatcher(this.pattern) ? this.pattern : new LiteralMatch(this.name, this.pattern);\n\n    const innerResult = matcher.test(actual);\n    const result = new MatchResult(actual);\n    if (innerResult.failCount === 0) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Found unexpected match: ${JSON.stringify(actual, undefined, 2)}`,\n      });\n    }\n    return result;\n  }\n}\n\nclass AnyMatch extends Matcher {\n  constructor(public readonly name: string) {\n    super();\n  }\n\n  public test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n    if (actual == null) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: 'Expected a value but found none',\n      });\n    }\n    return result;\n  }\n}\n\nclass StringLikeRegexpMatch extends Matcher {\n  constructor(\n    public readonly name: string,\n    private readonly pattern: string) {\n\n    super();\n  }\n\n  test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n\n    const regex = new RegExp(this.pattern, 'gm');\n\n    if (typeof actual !== 'string') {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Expected a string, but got '${typeof actual}'`,\n      });\n    }\n\n    if (!regex.test(actual)) {\n      result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `String '${actual}' did not match pattern '${this.pattern}'`,\n      });\n    }\n\n    return result;\n  }\n\n}\n"],
  "mappings": "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",
  "names": []
}
