{
  "version": 3,
  "sources": ["step-scaling-action.ts"],
  "sourcesContent": ["import { Duration, Lazy } from '../../core';\nimport { Construct } from 'constructs';\nimport { IAutoScalingGroup } from './auto-scaling-group';\nimport { CfnScalingPolicy } from './autoscaling.generated';\n\n/**\n * Properties for a scaling policy\n */\nexport interface StepScalingActionProps {\n  /**\n   * The auto scaling group\n   */\n  readonly autoScalingGroup: IAutoScalingGroup;\n\n  /**\n   * Period after a scaling completes before another scaling activity can start.\n   *\n   * @default The default cooldown configured on the AutoScalingGroup\n   */\n  readonly cooldown?: Duration;\n\n  /**\n   * Estimated time until a newly launched instance can send metrics to CloudWatch.\n   *\n   * @default Same as the cooldown\n   */\n  readonly estimatedInstanceWarmup?: Duration;\n\n  /**\n   * How the adjustment numbers are interpreted\n   *\n   * @default ChangeInCapacity\n   */\n  readonly adjustmentType?: AdjustmentType;\n\n  /**\n   * Minimum absolute number to adjust capacity with as result of percentage scaling.\n   *\n   * Only when using AdjustmentType = PercentChangeInCapacity, this number controls\n   * the minimum absolute effect size.\n   *\n   * @default No minimum scaling effect\n   */\n  readonly minAdjustmentMagnitude?: number;\n\n  /**\n   * The aggregation type for the CloudWatch metrics.\n   *\n   * @default Average\n   */\n  readonly metricAggregationType?: MetricAggregationType;\n}\n\n/**\n * Define a step scaling action\n *\n * This kind of scaling policy adjusts the target capacity in configurable\n * steps. The size of the step is configurable based on the metric's distance\n * to its alarm threshold.\n *\n * This Action must be used as the target of a CloudWatch alarm to take effect.\n */\nexport class StepScalingAction extends Construct {\n  /**\n   * ARN of the scaling policy\n   */\n  public readonly scalingPolicyArn: string;\n\n  private readonly adjustments = new Array<CfnScalingPolicy.StepAdjustmentProperty>();\n\n  constructor(scope: Construct, id: string, props: StepScalingActionProps) {\n    super(scope, id);\n\n    const resource = new CfnScalingPolicy(this, 'Resource', {\n      policyType: 'StepScaling',\n      autoScalingGroupName: props.autoScalingGroup.autoScalingGroupName,\n      cooldown: props.cooldown && props.cooldown.toSeconds().toString(),\n      estimatedInstanceWarmup: props.estimatedInstanceWarmup && props.estimatedInstanceWarmup.toSeconds(),\n      adjustmentType: props.adjustmentType,\n      minAdjustmentMagnitude: props.minAdjustmentMagnitude,\n      metricAggregationType: props.metricAggregationType,\n      stepAdjustments: Lazy.any({ produce: () => this.adjustments }),\n    });\n\n    this.scalingPolicyArn = resource.ref;\n  }\n\n  /**\n   * Add an adjusment interval to the ScalingAction\n   */\n  public addAdjustment(adjustment: AdjustmentTier) {\n    if (adjustment.lowerBound === undefined && adjustment.upperBound === undefined) {\n      throw new Error('At least one of lowerBound or upperBound is required');\n    }\n    this.adjustments.push({\n      metricIntervalLowerBound: adjustment.lowerBound,\n      metricIntervalUpperBound: adjustment.upperBound,\n      scalingAdjustment: adjustment.adjustment,\n    });\n  }\n}\n\n/**\n * How adjustment numbers are interpreted\n */\nexport enum AdjustmentType {\n  /**\n   * Add the adjustment number to the current capacity.\n   *\n   * A positive number increases capacity, a negative number decreases capacity.\n   */\n  CHANGE_IN_CAPACITY = 'ChangeInCapacity',\n\n  /**\n   * Add this percentage of the current capacity to itself.\n   *\n   * The number must be between -100 and 100; a positive number increases\n   * capacity and a negative number decreases it.\n   */\n  PERCENT_CHANGE_IN_CAPACITY = 'PercentChangeInCapacity',\n\n  /**\n   * Make the capacity equal to the exact number given.\n   */\n  EXACT_CAPACITY = 'ExactCapacity',\n}\n\n/**\n * How the scaling metric is going to be aggregated\n */\nexport enum MetricAggregationType {\n  /**\n   * Average\n   */\n  AVERAGE = 'Average',\n\n  /**\n   * Minimum\n   */\n  MINIMUM = 'Minimum',\n\n  /**\n   * Maximum\n   */\n  MAXIMUM = 'Maximum'\n}\n\n/**\n * An adjustment\n */\nexport interface AdjustmentTier {\n  /**\n   * What number to adjust the capacity with\n   *\n   * The number is interpeted as an added capacity, a new fixed capacity or an\n   * added percentage depending on the AdjustmentType value of the\n   * StepScalingPolicy.\n   *\n   * Can be positive or negative.\n   */\n  readonly adjustment: number;\n\n  /**\n   * Lower bound where this scaling tier applies.\n   *\n   * The scaling tier applies if the difference between the metric\n   * value and its alarm threshold is higher than this value.\n   *\n   * @default -Infinity if this is the first tier, otherwise the upperBound of the previous tier\n   */\n  readonly lowerBound?: number;\n\n  /**\n   * Upper bound where this scaling tier applies\n   *\n   * The scaling tier applies if the difference between the metric\n   * value and its alarm threshold is lower than this value.\n   *\n   * @default +Infinity\n   */\n  readonly upperBound?: number;\n}\n"],
  "mappings": "6QAAA,OAAA,QAAA,cACA,aAAA,QAAA,cAEA,wBAAA,QAAA,2BA2DA,+BAAuC,cAAA,SAAS,CAQ9C,YAAY,MAAkB,GAAY,MAA6B,CACrE,MAAM,MAAO,IAHE,KAAA,YAAc,GAAI,yFAKjC,KAAM,UAAW,GAAI,yBAAA,iBAAiB,KAAM,WAAY,CACtD,WAAY,cACZ,qBAAsB,MAAM,iBAAiB,qBAC7C,SAAU,MAAM,UAAY,MAAM,SAAS,YAAY,WACvD,wBAAyB,MAAM,yBAA2B,MAAM,wBAAwB,YACxF,eAAgB,MAAM,eACtB,uBAAwB,MAAM,uBAC9B,sBAAuB,MAAM,sBAC7B,gBAAiB,OAAA,KAAK,IAAI,CAAE,QAAS,IAAM,KAAK,gBAGlD,KAAK,iBAAmB,SAAS,IAM5B,cAAc,WAA0B,CAC7C,kFAAI,WAAW,aAAe,QAAa,WAAW,aAAe,OACnE,KAAM,IAAI,OAAM,wDAElB,KAAK,YAAY,KAAK,CACpB,yBAA0B,WAAW,WACrC,yBAA0B,WAAW,WACrC,kBAAmB,WAAW,cAnCpC,QAAA,kBAAA,qIA2CA,GAAY,gBAAZ,AAAA,UAAY,gBAAc,CAMxB,gBAAA,mBAAA,mBAQA,gBAAA,2BAAA,0BAKA,gBAAA,eAAA,kBAnBU,eAAA,QAAA,gBAAA,SAAA,eAAc,KAyB1B,GAAY,uBAAZ,AAAA,UAAY,uBAAqB,CAI/B,uBAAA,QAAA,UAKA,uBAAA,QAAA,UAKA,uBAAA,QAAA,YAdU,sBAAA,QAAA,uBAAA,SAAA,sBAAqB",
  "names": []
}
