{
  "version": 3,
  "sources": ["auto-scaling-group.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as ec2 from '../../aws-ec2';\nimport * as elb from '../../aws-elasticloadbalancing';\nimport * as elbv2 from '../../aws-elasticloadbalancingv2';\nimport * as iam from '../../aws-iam';\nimport * as sns from '../../aws-sns';\n\nimport {\n  Annotations,\n  Aspects,\n  Aws,\n  CfnAutoScalingRollingUpdate, CfnCreationPolicy, CfnUpdatePolicy,\n  Duration, Fn, IResource, Lazy, PhysicalName, Resource, Stack, Tags,\n  Token,\n  Tokenization, withResolved,\n} from '../../core';\nimport { Construct } from 'constructs';\nimport { AutoScalingGroupRequireImdsv2Aspect } from './aspects';\nimport { CfnAutoScalingGroup, CfnAutoScalingGroupProps, CfnLaunchConfiguration } from './autoscaling.generated';\nimport { BasicLifecycleHookProps, LifecycleHook } from './lifecycle-hook';\nimport { BasicScheduledActionProps, ScheduledAction } from './scheduled-action';\nimport { BasicStepScalingPolicyProps, StepScalingPolicy } from './step-scaling-policy';\nimport { BaseTargetTrackingProps, PredefinedMetric, TargetTrackingScalingPolicy } from './target-tracking-scaling-policy';\nimport { TerminationPolicy } from './termination-policy';\nimport { BlockDevice, BlockDeviceVolume, EbsDeviceVolumeType } from './volume';\n\n/**\n * Name tag constant\n */\nconst NAME_TAG: string = 'Name';\n\n/**\n * The monitoring mode for instances launched in an autoscaling group\n */\nexport enum Monitoring {\n  /**\n   * Generates metrics every 5 minutes\n   */\n  BASIC,\n\n  /**\n   * Generates metrics every minute\n   */\n  DETAILED,\n}\n\n/**\n * Basic properties of an AutoScalingGroup, except the exact machines to run and where they should run\n *\n * Constructs that want to create AutoScalingGroups can inherit\n * this interface and specialize the essential parts in various ways.\n */\nexport interface CommonAutoScalingGroupProps {\n  /**\n   * Minimum number of instances in the fleet\n   *\n   * @default 1\n   */\n  readonly minCapacity?: number;\n\n  /**\n   * Maximum number of instances in the fleet\n   *\n   * @default desiredCapacity\n   */\n  readonly maxCapacity?: number;\n\n  /**\n   * Initial amount of instances in the fleet\n   *\n   * If this is set to a number, every deployment will reset the amount of\n   * instances to this number. It is recommended to leave this value blank.\n   *\n   * @default minCapacity, and leave unchanged during deployment\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html#cfn-as-group-desiredcapacity\n   */\n  readonly desiredCapacity?: number;\n\n  /**\n   * Name of SSH keypair to grant access to instances\n   *\n   * @default - No SSH access will be possible.\n   */\n  readonly keyName?: string;\n\n  /**\n   * Where to place instances within the VPC\n   *\n   * @default - All Private subnets.\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n  /**\n   * SNS topic to send notifications about fleet changes\n   *\n   * @default - No fleet change notifications will be sent.\n   * @deprecated use `notifications`\n   */\n  readonly notificationsTopic?: sns.ITopic;\n\n  /**\n   * Configure autoscaling group to send notifications about fleet changes to an SNS topic(s)\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html#cfn-as-group-notificationconfigurations\n   * @default - No fleet change notifications will be sent.\n   */\n  readonly notifications?: NotificationConfiguration[];\n\n  /**\n   * Whether the instances can initiate connections to anywhere by default\n   *\n   * @default true\n   */\n  readonly allowAllOutbound?: boolean;\n\n  /**\n   * What to do when an AutoScalingGroup's instance configuration is changed\n   *\n   * This is applied when any of the settings on the ASG are changed that\n   * affect how the instances should be created (VPC, instance type, startup\n   * scripts, etc.). It indicates how the existing instances should be\n   * replaced with new instances matching the new config. By default, nothing\n   * is done and only new instances are launched with the new config.\n   *\n   * @default UpdateType.None\n   * @deprecated Use `updatePolicy` instead\n   */\n  readonly updateType?: UpdateType;\n\n  /**\n   * Configuration for rolling updates\n   *\n   * Only used if updateType == UpdateType.RollingUpdate.\n   *\n   * @default - RollingUpdateConfiguration with defaults.\n   * @deprecated Use `updatePolicy` instead\n   */\n  readonly rollingUpdateConfiguration?: RollingUpdateConfiguration;\n\n  /**\n   * Configuration for replacing updates.\n   *\n   * Only used if updateType == UpdateType.ReplacingUpdate. Specifies how\n   * many instances must signal success for the update to succeed.\n   *\n   * @default minSuccessfulInstancesPercent\n   * @deprecated Use `signals` instead\n   */\n  readonly replacingUpdateMinSuccessfulInstancesPercent?: number;\n\n  /**\n   * If the ASG has scheduled actions, don't reset unchanged group sizes\n   *\n   * Only used if the ASG has scheduled actions (which may scale your ASG up\n   * or down regardless of cdk deployments). If true, the size of the group\n   * will only be reset if it has been changed in the CDK app. If false, the\n   * sizes will always be changed back to what they were in the CDK app\n   * on deployment.\n   *\n   * @default true\n   */\n  readonly ignoreUnmodifiedSizeProperties?: boolean;\n\n  /**\n   * How many ResourceSignal calls CloudFormation expects before the resource is considered created\n   *\n   * @default 1 if resourceSignalTimeout is set, 0 otherwise\n   * @deprecated Use `signals` instead.\n   */\n  readonly resourceSignalCount?: number;\n\n  /**\n   * The length of time to wait for the resourceSignalCount\n   *\n   * The maximum value is 43200 (12 hours).\n   *\n   * @default Duration.minutes(5) if resourceSignalCount is set, N/A otherwise\n   * @deprecated Use `signals` instead.\n   */\n  readonly resourceSignalTimeout?: Duration;\n\n  /**\n   * Default scaling cooldown for this AutoScalingGroup\n   *\n   * @default Duration.minutes(5)\n   */\n  readonly cooldown?: Duration;\n\n  /**\n   * Whether instances in the Auto Scaling Group should have public\n   * IP addresses associated with them.\n   *\n   * @default - Use subnet setting.\n   */\n  readonly associatePublicIpAddress?: boolean;\n\n  /**\n   * The maximum hourly price (in USD) to be paid for any Spot Instance launched to fulfill the request. Spot Instances are\n   * launched when the price you specify exceeds the current Spot market price.\n   *\n   * @default none\n   */\n  readonly spotPrice?: string;\n\n  /**\n   * Configuration for health checks\n   *\n   * @default - HealthCheck.ec2 with no grace period\n   */\n  readonly healthCheck?: HealthCheck;\n\n  /**\n   * Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes.\n   *\n   * Each instance that is launched has an associated root device volume,\n   * either an Amazon EBS volume or an instance store volume.\n   * You can use block device mappings to specify additional EBS volumes or\n   * instance store volumes to attach to an instance when it is launched.\n   *\n   * @see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html\n   *\n   * @default - Uses the block device mapping of the AMI\n   */\n  readonly blockDevices?: BlockDevice[];\n\n  /**\n   * The maximum amount of time that an instance can be in service. The maximum duration applies\n   * to all current and future instances in the group. As an instance approaches its maximum duration,\n   * it is terminated and replaced, and cannot be used again.\n   *\n   * You must specify a value of at least 604,800 seconds (7 days). To clear a previously set value,\n   * leave this property undefined.\n   *\n   * @see https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-max-instance-lifetime.html\n   *\n   * @default none\n   */\n  readonly maxInstanceLifetime?: Duration;\n\n  /**\n   * Controls whether instances in this group are launched with detailed or basic monitoring.\n   *\n   * When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and your account\n   * is charged a fee. When you disable detailed monitoring, CloudWatch generates metrics every 5 minutes.\n   *\n   * @see https://docs.aws.amazon.com/autoscaling/latest/userguide/as-instance-monitoring.html#enable-as-instance-metrics\n   *\n   * @default - Monitoring.DETAILED\n   */\n  readonly instanceMonitoring?: Monitoring;\n\n  /**\n   * Enable monitoring for group metrics, these metrics describe the group rather than any of its instances.\n   * To report all group metrics use `GroupMetrics.all()`\n   * Group metrics are reported in a granularity of 1 minute at no additional charge.\n   * @default - no group metrics will be reported\n   *\n   */\n  readonly groupMetrics?: GroupMetrics[];\n\n  /**\n   * Configure waiting for signals during deployment\n   *\n   * Use this to pause the CloudFormation deployment to wait for the instances\n   * in the AutoScalingGroup to report successful startup during\n   * creation and updates. The UserData script needs to invoke `cfn-signal`\n   * with a success or failure code after it is done setting up the instance.\n   *\n   * Without waiting for signals, the CloudFormation deployment will proceed as\n   * soon as the AutoScalingGroup has been created or updated but before the\n   * instances in the group have been started.\n   *\n   * For example, to have instances wait for an Elastic Load Balancing health check before\n   * they signal success, add a health-check verification by using the\n   * cfn-init helper script. For an example, see the verify_instance_health\n   * command in the Auto Scaling rolling updates sample template:\n   *\n   * https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/AutoScaling/AutoScalingRollingUpdates.yaml\n   *\n   * @default - Do not wait for signals\n   */\n  readonly signals?: Signals;\n\n  /**\n   * What to do when an AutoScalingGroup's instance configuration is changed\n   *\n   * This is applied when any of the settings on the ASG are changed that\n   * affect how the instances should be created (VPC, instance type, startup\n   * scripts, etc.). It indicates how the existing instances should be\n   * replaced with new instances matching the new config. By default, nothing\n   * is done and only new instances are launched with the new config.\n   *\n   * @default - `UpdatePolicy.rollingUpdate()` if using `init`, `UpdatePolicy.none()` otherwise\n   */\n  readonly updatePolicy?: UpdatePolicy;\n\n  /**\n   * Whether newly-launched instances are protected from termination by Amazon\n   * EC2 Auto Scaling when scaling in.\n   *\n   * By default, Auto Scaling can terminate an instance at any time after launch\n   * when scaling in an Auto Scaling Group, subject to the group's termination\n   * policy. However, you may wish to protect newly-launched instances from\n   * being scaled in if they are going to run critical applications that should\n   * not be prematurely terminated.\n   *\n   * This flag must be enabled if the Auto Scaling Group will be associated with\n   * an ECS Capacity Provider with managed termination protection.\n   *\n   * @default false\n   */\n  readonly newInstancesProtectedFromScaleIn?: boolean;\n\n  /**\n   * The name of the Auto Scaling group. This name must be unique per Region per account.\n   * @default - Auto generated by CloudFormation\n   */\n  readonly autoScalingGroupName?: string;\n\n  /**\n   * A policy or a list of policies that are used to select the instances to\n   * terminate. The policies are executed in the order that you list them.\n   *\n   * @see https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html\n   *\n   * @default - `TerminationPolicy.DEFAULT`\n   */\n  readonly terminationPolicies?: TerminationPolicy[];\n}\n\n/**\n * Properties of a Fleet\n */\nexport interface AutoScalingGroupProps extends CommonAutoScalingGroupProps {\n  /**\n   * VPC to launch these instances in.\n   */\n  readonly vpc: ec2.IVpc;\n\n  /**\n   * Type of instance to launch\n   */\n  readonly instanceType: ec2.InstanceType;\n\n  /**\n   * AMI to launch\n   */\n  readonly machineImage: ec2.IMachineImage;\n\n  /**\n   * Security group to launch the instances in.\n   *\n   * @default - A SecurityGroup will be created if none is specified.\n   */\n  readonly securityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * Specific UserData to use\n   *\n   * The UserData may still be mutated after creation.\n   *\n   * @default - A UserData object appropriate for the MachineImage's\n   * Operating System is created.\n   */\n  readonly userData?: ec2.UserData;\n\n  /**\n   * An IAM role to associate with the instance profile assigned to this Auto Scaling Group.\n   *\n   * The role must be assumable by the service principal `ec2.amazonaws.com`:\n   *\n   * @example\n   *\n   *    const role = new iam.Role(this, 'MyRole', {\n   *      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com')\n   *    });\n   *\n   * @default A role will automatically be created, it can be accessed via the `role` property\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Apply the given CloudFormation Init configuration to the instances in the AutoScalingGroup at startup\n   *\n   * If you specify `init`, you must also specify `signals` to configure\n   * the number of instances to wait for and the timeout for waiting for the\n   * init process.\n   *\n   * @default - no CloudFormation init\n   */\n  readonly init?: ec2.CloudFormationInit;\n\n  /**\n   * Use the given options for applying CloudFormation Init\n   *\n   * Describes the configsets to use and the timeout to wait\n   *\n   * @default - default options\n   */\n  readonly initOptions?: ApplyCloudFormationInitOptions;\n\n  /**\n   * Whether IMDSv2 should be required on launched instances.\n   *\n   * @default - false\n   */\n  readonly requireImdsv2?: boolean;\n}\n\n/**\n * Configure whether the AutoScalingGroup waits for signals\n *\n * If you do configure waiting for signals, you should make sure the instances\n * invoke `cfn-signal` somewhere in their UserData to signal that they have\n * started up (either successfully or unsuccessfully).\n *\n * Signals are used both during intial creation and subsequent updates.\n */\nexport abstract class Signals {\n  /**\n   * Wait for the desiredCapacity of the AutoScalingGroup amount of signals to have been received\n   *\n   * If no desiredCapacity has been configured, wait for minCapacity signals intead.\n   *\n   * This number is used during initial creation and during replacing updates.\n   * During rolling updates, all updated instances must send a signal.\n   */\n  public static waitForAll(options: SignalsOptions = {}): Signals {\n    validatePercentage(options.minSuccessPercentage);\n    return new class extends Signals {\n      public renderCreationPolicy(renderOptions: RenderSignalsOptions): CfnCreationPolicy {\n        return this.doRender(options, renderOptions.desiredCapacity ?? renderOptions.minCapacity);\n      }\n    }();\n  }\n\n  /**\n   * Wait for the minCapacity of the AutoScalingGroup amount of signals to have been received\n   *\n   * This number is used during initial creation and during replacing updates.\n   * During rolling updates, all updated instances must send a signal.\n   */\n  public static waitForMinCapacity(options: SignalsOptions = {}): Signals {\n    validatePercentage(options.minSuccessPercentage);\n    return new class extends Signals {\n      public renderCreationPolicy(renderOptions: RenderSignalsOptions): CfnCreationPolicy {\n        return this.doRender(options, renderOptions.minCapacity);\n      }\n    }();\n  }\n\n  /**\n   * Wait for a specific amount of signals to have been received\n   *\n   * You should send one signal per instance, so this represents the number of\n   * instances to wait for.\n   *\n   * This number is used during initial creation and during replacing updates.\n   * During rolling updates, all updated instances must send a signal.\n   */\n  public static waitForCount(count: number, options: SignalsOptions = {}): Signals {\n    validatePercentage(options.minSuccessPercentage);\n    return new class extends Signals {\n      public renderCreationPolicy(): CfnCreationPolicy {\n        return this.doRender(options, count);\n      }\n    }();\n  }\n\n  /**\n   * Render the ASG's CreationPolicy\n   */\n  public abstract renderCreationPolicy(renderOptions: RenderSignalsOptions): CfnCreationPolicy;\n\n  /**\n   * Helper to render the actual creation policy, as the logic between them is quite similar\n   */\n  protected doRender(options: SignalsOptions, count?: number): CfnCreationPolicy {\n    const minSuccessfulInstancesPercent = validatePercentage(options.minSuccessPercentage);\n    return {\n      ...options.minSuccessPercentage !== undefined ? { autoScalingCreationPolicy: { minSuccessfulInstancesPercent } } : { },\n      resourceSignal: {\n        count,\n        timeout: options.timeout?.toIsoString(),\n      },\n    };\n  }\n\n}\n\n/**\n * Input for Signals.renderCreationPolicy\n */\nexport interface RenderSignalsOptions {\n  /**\n   * The desiredCapacity of the ASG\n   *\n   * @default - desired capacity not configured\n   */\n  readonly desiredCapacity?: number;\n\n  /**\n   * The minSize of the ASG\n   *\n   * @default - minCapacity not configured\n   */\n  readonly minCapacity?: number;\n}\n\n/**\n * Customization options for Signal handling\n */\nexport interface SignalsOptions {\n  /**\n   * The percentage of signals that need to be successful\n   *\n   * If this number is less than 100, a percentage of signals may be failure\n   * signals while still succeeding the creation or update in CloudFormation.\n   *\n   * @default 100\n   */\n  readonly minSuccessPercentage?: number;\n\n  /**\n   * How long to wait for the signals to be sent\n   *\n   * This should reflect how long it takes your instances to start up\n   * (including instance start time and instance initialization time).\n   *\n   * @default Duration.minutes(5)\n   */\n  readonly timeout?: Duration;\n}\n\n/**\n * How existing instances should be updated\n */\nexport abstract class UpdatePolicy {\n  /**\n   * Create a new AutoScalingGroup and switch over to it\n   */\n  public static replacingUpdate(): UpdatePolicy {\n    return new class extends UpdatePolicy {\n      public _renderUpdatePolicy(): CfnUpdatePolicy {\n        return {\n          autoScalingReplacingUpdate: { willReplace: true },\n        };\n      }\n    }();\n  }\n\n  /**\n   * Replace the instances in the AutoScalingGroup one by one, or in batches\n   */\n  public static rollingUpdate(options: RollingUpdateOptions = {}): UpdatePolicy {\n    const minSuccessPercentage = validatePercentage(options.minSuccessPercentage);\n\n    return new class extends UpdatePolicy {\n      public _renderUpdatePolicy(renderOptions: RenderUpdateOptions): CfnUpdatePolicy {\n        return {\n          autoScalingRollingUpdate: {\n            maxBatchSize: options.maxBatchSize,\n            minInstancesInService: options.minInstancesInService,\n            suspendProcesses: options.suspendProcesses ?? DEFAULT_SUSPEND_PROCESSES,\n            minSuccessfulInstancesPercent:\n              minSuccessPercentage ?? renderOptions.creationPolicy?.autoScalingCreationPolicy?.minSuccessfulInstancesPercent,\n            waitOnResourceSignals: options.waitOnResourceSignals ?? renderOptions.creationPolicy?.resourceSignal !== undefined ? true : undefined,\n            pauseTime: options.pauseTime?.toIsoString() ?? renderOptions.creationPolicy?.resourceSignal?.timeout,\n          },\n        };\n      }\n    }();\n  }\n\n  /**\n   * Render the ASG's CreationPolicy\n   * @internal\n   */\n  public abstract _renderUpdatePolicy(renderOptions: RenderUpdateOptions): CfnUpdatePolicy;\n}\n\n/**\n * Options for rendering UpdatePolicy\n */\ninterface RenderUpdateOptions {\n  /**\n   * The Creation Policy already created\n   *\n   * @default - no CreationPolicy configured\n   */\n  readonly creationPolicy?: CfnCreationPolicy;\n}\n\n/**\n * Options for customizing the rolling update\n */\nexport interface RollingUpdateOptions {\n  /**\n   * The maximum number of instances that AWS CloudFormation updates at once.\n   *\n   * This number affects the speed of the replacement.\n   *\n   * @default 1\n   */\n  readonly maxBatchSize?: number;\n\n  /**\n   * The minimum number of instances that must be in service before more instances are replaced.\n   *\n   * This number affects the speed of the replacement.\n   *\n   * @default 0\n   */\n  readonly minInstancesInService?: number;\n\n  /**\n   * Specifies the Auto Scaling processes to suspend during a stack update.\n   *\n   * Suspending processes prevents Auto Scaling from interfering with a stack\n   * update.\n   *\n   * @default HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions.\n   */\n  readonly suspendProcesses?: ScalingProcess[];\n\n  /**\n   * Specifies whether the Auto Scaling group waits on signals from new instances during an update.\n   *\n   * @default true if you configured `signals` on the AutoScalingGroup, false otherwise\n   */\n  readonly waitOnResourceSignals?: boolean;\n\n  /**\n   * The pause time after making a change to a batch of instances.\n   *\n   * @default - The `timeout` configured for `signals` on the AutoScalingGroup\n   */\n  readonly pauseTime?: Duration;\n\n  /**\n   * The percentage of instances that must signal success for the update to succeed.\n   *\n   * @default - The `minSuccessPercentage` configured for `signals` on the AutoScalingGroup\n   */\n  readonly minSuccessPercentage?: number;\n}\n\n/**\n * A set of group metrics\n */\nexport class GroupMetrics {\n\n  /**\n   * Report all group metrics.\n   */\n  public static all(): GroupMetrics {\n    return new GroupMetrics();\n  }\n\n  /**\n   * @internal\n   */\n  public _metrics = new Set<GroupMetric>();\n\n  constructor(...metrics: GroupMetric[]) {\n    metrics?.forEach(metric => this._metrics.add(metric));\n  }\n}\n\n/**\n * Group metrics that an Auto Scaling group sends to Amazon CloudWatch.\n */\nexport class GroupMetric {\n\n  /**\n   * The minimum size of the Auto Scaling group\n   */\n  public static readonly MIN_SIZE = new GroupMetric('GroupMinSize');\n\n  /**\n   * The maximum size of the Auto Scaling group\n   */\n  public static readonly MAX_SIZE = new GroupMetric('GroupMaxSize');\n\n  /**\n   * The number of instances that the Auto Scaling group attempts to maintain\n   */\n  public static readonly DESIRED_CAPACITY = new GroupMetric('GroupDesiredCapacity');\n\n  /**\n   * The number of instances that are running as part of the Auto Scaling group\n   * This metric does not include instances that are pending or terminating\n   */\n  public static readonly IN_SERVICE_INSTANCES = new GroupMetric('GroupInServiceInstances');\n\n  /**\n   * The number of instances that are pending\n   * A pending instance is not yet in service, this metric does not include instances that are in service or terminating\n   */\n  public static readonly PENDING_INSTANCES = new GroupMetric('GroupPendingInstances');\n\n  /**\n   * The number of instances that are in a Standby state\n   * Instances in this state are still running but are not actively in service\n   */\n  public static readonly STANDBY_INSTANCES = new GroupMetric('GroupStandbyInstances');\n\n  /**\n   * The number of instances that are in the process of terminating\n   * This metric does not include instances that are in service or pending\n   */\n  public static readonly TERMINATING_INSTANCES = new GroupMetric('GroupTerminatingInstances');\n\n  /**\n   * The total number of instances in the Auto Scaling group\n   * This metric identifies the number of instances that are in service, pending, and terminating\n   */\n  public static readonly TOTAL_INSTANCES = new GroupMetric('GroupTotalInstances');\n\n  /**\n   * The name of the group metric\n   */\n  public readonly name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nabstract class AutoScalingGroupBase extends Resource implements IAutoScalingGroup {\n\n  public abstract autoScalingGroupName: string;\n  public abstract autoScalingGroupArn: string;\n  public abstract readonly osType: ec2.OperatingSystemType;\n  protected albTargetGroup?: elbv2.ApplicationTargetGroup;\n  public readonly grantPrincipal: iam.IPrincipal = new iam.UnknownPrincipal({ resource: this });\n\n  /**\n   * Send a message to either an SQS queue or SNS topic when instances launch or terminate\n   */\n  public addLifecycleHook(id: string, props: BasicLifecycleHookProps): LifecycleHook {\n    return new LifecycleHook(this, `LifecycleHook${id}`, {\n      autoScalingGroup: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Scale out or in based on time\n   */\n  public scaleOnSchedule(id: string, props: BasicScheduledActionProps): ScheduledAction {\n    return new ScheduledAction(this, `ScheduledAction${id}`, {\n      autoScalingGroup: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Scale out or in to achieve a target CPU utilization\n   */\n  public scaleOnCpuUtilization(id: string, props: CpuUtilizationScalingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ASG_AVERAGE_CPU_UTILIZATION,\n      targetValue: props.targetUtilizationPercent,\n      ...props,\n    });\n  }\n\n  /**\n   * Scale out or in to achieve a target network ingress rate\n   */\n  public scaleOnIncomingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ASG_AVERAGE_NETWORK_IN,\n      targetValue: props.targetBytesPerSecond,\n      ...props,\n    });\n  }\n\n  /**\n   * Scale out or in to achieve a target network egress rate\n   */\n  public scaleOnOutgoingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ASG_AVERAGE_NETWORK_OUT,\n      targetValue: props.targetBytesPerSecond,\n      ...props,\n    });\n  }\n\n  /**\n   * Scale out or in to achieve a target request handling rate\n   *\n   * The AutoScalingGroup must have been attached to an Application Load Balancer\n   * in order to be able to call this.\n   */\n  public scaleOnRequestCount(id: string, props: RequestCountScalingProps): TargetTrackingScalingPolicy {\n    if (this.albTargetGroup === undefined) {\n      throw new Error('Attach the AutoScalingGroup to a non-imported Application Load Balancer before calling scaleOnRequestCount()');\n    }\n\n    const resourceLabel = `${this.albTargetGroup.firstLoadBalancerFullName}/${this.albTargetGroup.targetGroupFullName}`;\n\n    if ((props.targetRequestsPerMinute === undefined) === (props.targetRequestsPerSecond === undefined)) {\n      throw new Error('Specify exactly one of \\'targetRequestsPerMinute\\' or \\'targetRequestsPerSecond\\'');\n    }\n\n    let rpm: number;\n    if (props.targetRequestsPerSecond !== undefined) {\n      if (Token.isUnresolved(props.targetRequestsPerSecond)) {\n        throw new Error('\\'targetRequestsPerSecond\\' cannot be an unresolved value; use \\'targetRequestsPerMinute\\' instead.');\n      }\n      rpm = props.targetRequestsPerSecond * 60;\n    } else {\n      rpm = props.targetRequestsPerMinute!;\n    }\n\n    const policy = new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      predefinedMetric: PredefinedMetric.ALB_REQUEST_COUNT_PER_TARGET,\n      targetValue: rpm,\n      resourceLabel,\n      ...props,\n    });\n\n    policy.node.addDependency(this.albTargetGroup.loadBalancerAttached);\n    return policy;\n  }\n\n  /**\n   * Scale out or in in order to keep a metric around a target value\n   */\n  public scaleToTrackMetric(id: string, props: MetricTargetTrackingProps): TargetTrackingScalingPolicy {\n    return new TargetTrackingScalingPolicy(this, `ScalingPolicy${id}`, {\n      autoScalingGroup: this,\n      customMetric: props.metric,\n      ...props,\n    });\n  }\n\n  /**\n   * Scale out or in, in response to a metric\n   */\n  public scaleOnMetric(id: string, props: BasicStepScalingPolicyProps): StepScalingPolicy {\n    return new StepScalingPolicy(this, id, { ...props, autoScalingGroup: this });\n  }\n\n  public addUserData(..._commands: string[]): void {\n    // do nothing\n  }\n}\n\n/**\n * A Fleet represents a managed set of EC2 instances\n *\n * The Fleet models a number of AutoScalingGroups, a launch configuration, a\n * security group and an instance role.\n *\n * It allows adding arbitrary commands to the startup scripts of the instances\n * in the fleet.\n *\n * The ASG spans the availability zones specified by vpcSubnets, falling back to\n * the Vpc default strategy if not specified.\n */\nexport class AutoScalingGroup extends AutoScalingGroupBase implements\n  elb.ILoadBalancerTarget,\n  ec2.IConnectable,\n  elbv2.IApplicationLoadBalancerTarget,\n  elbv2.INetworkLoadBalancerTarget {\n\n  public static fromAutoScalingGroupName(scope: Construct, id: string, autoScalingGroupName: string): IAutoScalingGroup {\n    class Import extends AutoScalingGroupBase {\n      public autoScalingGroupName = autoScalingGroupName;\n      public autoScalingGroupArn = Stack.of(this).formatArn({\n        service: 'autoscaling',\n        resource: 'autoScalingGroup:*:autoScalingGroupName',\n        resourceName: this.autoScalingGroupName,\n      });\n      public readonly osType = ec2.OperatingSystemType.UNKNOWN;\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * The type of OS instances of this fleet are running.\n   */\n  public readonly osType: ec2.OperatingSystemType;\n\n  /**\n   * Allows specify security group connections for instances of this fleet.\n   */\n  public readonly connections: ec2.Connections;\n\n  /**\n   * The IAM role assumed by instances of this fleet.\n   */\n  public readonly role: iam.IRole;\n\n  /**\n   * The principal to grant permissions to\n   */\n  public readonly grantPrincipal: iam.IPrincipal;\n\n  /**\n   * Name of the AutoScalingGroup\n   */\n  public readonly autoScalingGroupName: string;\n\n  /**\n   * Arn of the AutoScalingGroup\n   */\n  public readonly autoScalingGroupArn: string;\n\n  /**\n   * UserData for the instances\n   */\n  public readonly userData: ec2.UserData;\n\n  /**\n   * The maximum spot price configured for the autoscaling group. `undefined`\n   * indicates that this group uses on-demand capacity.\n   */\n  public readonly spotPrice?: string;\n\n  /**\n   * The maximum amount of time that an instance can be in service.\n   */\n  public readonly maxInstanceLifetime?: Duration;\n\n  private readonly autoScalingGroup: CfnAutoScalingGroup;\n  private readonly securityGroup: ec2.ISecurityGroup;\n  private readonly securityGroups: ec2.ISecurityGroup[] = [];\n  private readonly loadBalancerNames: string[] = [];\n  private readonly targetGroupArns: string[] = [];\n  private readonly groupMetrics: GroupMetrics[] = [];\n  private readonly notifications: NotificationConfiguration[] = [];\n\n  protected newInstancesProtectedFromScaleIn?: boolean;\n\n  constructor(scope: Construct, id: string, props: AutoScalingGroupProps) {\n    super(scope, id, {\n      physicalName: props.autoScalingGroupName,\n    });\n\n    this.newInstancesProtectedFromScaleIn = props.newInstancesProtectedFromScaleIn;\n\n    if (props.initOptions && !props.init) {\n      throw new Error('Setting \\'initOptions\\' requires that \\'init\\' is also set');\n    }\n\n    this.securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'InstanceSecurityGroup', {\n      vpc: props.vpc,\n      allowAllOutbound: props.allowAllOutbound !== false,\n    });\n    this.connections = new ec2.Connections({ securityGroups: [this.securityGroup] });\n    this.securityGroups.push(this.securityGroup);\n    Tags.of(this).add(NAME_TAG, this.node.path);\n\n    this.role = props.role || new iam.Role(this, 'InstanceRole', {\n      roleName: PhysicalName.GENERATE_IF_NEEDED,\n      assumedBy: new iam.ServicePrincipal('ec2.amazonaws.com'),\n    });\n\n    this.grantPrincipal = this.role;\n\n    if (props.groupMetrics) {\n      this.groupMetrics.push(...props.groupMetrics);\n    }\n\n    const iamProfile = new iam.CfnInstanceProfile(this, 'InstanceProfile', {\n      roles: [this.role.roleName],\n    });\n\n    // use delayed evaluation\n    const imageConfig = props.machineImage.getImage(this);\n    this.userData = props.userData ?? imageConfig.userData;\n    const userDataToken = Lazy.string({ produce: () => Fn.base64(this.userData.render()) });\n    const securityGroupsToken = Lazy.list({ produce: () => this.securityGroups.map(sg => sg.securityGroupId) });\n\n    const launchConfig = new CfnLaunchConfiguration(this, 'LaunchConfig', {\n      imageId: imageConfig.imageId,\n      keyName: props.keyName,\n      instanceType: props.instanceType.toString(),\n      instanceMonitoring: (props.instanceMonitoring !== undefined ? (props.instanceMonitoring === Monitoring.DETAILED) : undefined),\n      securityGroups: securityGroupsToken,\n      iamInstanceProfile: iamProfile.ref,\n      userData: userDataToken,\n      associatePublicIpAddress: props.associatePublicIpAddress,\n      spotPrice: props.spotPrice,\n      blockDeviceMappings: (props.blockDevices !== undefined ?\n        synthesizeBlockDeviceMappings(this, props.blockDevices) : undefined),\n    });\n\n    launchConfig.node.addDependency(this.role);\n\n    // desiredCapacity just reflects what the user has supplied.\n    const desiredCapacity = props.desiredCapacity;\n    const minCapacity = props.minCapacity ?? 1;\n    const maxCapacity = props.maxCapacity ?? desiredCapacity ?? Math.max(minCapacity, 1);\n\n    withResolved(minCapacity, maxCapacity, (min, max) => {\n      if (min > max) {\n        throw new Error(`minCapacity (${min}) should be <= maxCapacity (${max})`);\n      }\n    });\n    withResolved(desiredCapacity, minCapacity, (desired, min) => {\n      if (desired === undefined) { return; }\n      if (desired < min) {\n        throw new Error(`Should have minCapacity (${min}) <= desiredCapacity (${desired})`);\n      }\n    });\n    withResolved(desiredCapacity, maxCapacity, (desired, max) => {\n      if (desired === undefined) { return; }\n      if (max < desired) {\n        throw new Error(`Should have desiredCapacity (${desired}) <= maxCapacity (${max})`);\n      }\n    });\n\n    if (desiredCapacity !== undefined) {\n      Annotations.of(this).addWarning('desiredCapacity has been configured. Be aware this will reset the size of your AutoScalingGroup on every deployment. See https://github.com/aws/aws-cdk/issues/5215');\n    }\n\n    this.maxInstanceLifetime = props.maxInstanceLifetime;\n    if (this.maxInstanceLifetime &&\n      (this.maxInstanceLifetime.toSeconds() < 604800 || this.maxInstanceLifetime.toSeconds() > 31536000)) {\n      throw new Error('maxInstanceLifetime must be between 7 and 365 days (inclusive)');\n    }\n\n    if (props.notificationsTopic && props.notifications) {\n      throw new Error('Cannot set \\'notificationsTopic\\' and \\'notifications\\', \\'notificationsTopic\\' is deprecated use \\'notifications\\' instead');\n    }\n\n    if (props.notificationsTopic) {\n      this.notifications = [{\n        topic: props.notificationsTopic,\n      }];\n    }\n\n    if (props.notifications) {\n      this.notifications = props.notifications.map(nc => ({\n        topic: nc.topic,\n        scalingEvents: nc.scalingEvents ?? ScalingEvents.ALL,\n      }));\n    }\n\n    const { subnetIds, hasPublic } = props.vpc.selectSubnets(props.vpcSubnets);\n    const asgProps: CfnAutoScalingGroupProps = {\n      autoScalingGroupName: this.physicalName,\n      cooldown: props.cooldown?.toSeconds().toString(),\n      minSize: Tokenization.stringifyNumber(minCapacity),\n      maxSize: Tokenization.stringifyNumber(maxCapacity),\n      desiredCapacity: desiredCapacity !== undefined ? Tokenization.stringifyNumber(desiredCapacity) : undefined,\n      launchConfigurationName: launchConfig.ref,\n      loadBalancerNames: Lazy.list({ produce: () => this.loadBalancerNames }, { omitEmpty: true }),\n      targetGroupArns: Lazy.list({ produce: () => this.targetGroupArns }, { omitEmpty: true }),\n      notificationConfigurations: this.renderNotificationConfiguration(),\n      metricsCollection: Lazy.any({ produce: () => this.renderMetricsCollection() }),\n      vpcZoneIdentifier: subnetIds,\n      healthCheckType: props.healthCheck && props.healthCheck.type,\n      healthCheckGracePeriod: props.healthCheck && props.healthCheck.gracePeriod && props.healthCheck.gracePeriod.toSeconds(),\n      maxInstanceLifetime: this.maxInstanceLifetime ? this.maxInstanceLifetime.toSeconds() : undefined,\n      newInstancesProtectedFromScaleIn: Lazy.any({ produce: () => this.newInstancesProtectedFromScaleIn }),\n      terminationPolicies: props.terminationPolicies,\n    };\n\n    if (!hasPublic && props.associatePublicIpAddress) {\n      throw new Error(\"To set 'associatePublicIpAddress: true' you must select Public subnets (vpcSubnets: { subnetType: SubnetType.PUBLIC })\");\n    }\n\n    this.autoScalingGroup = new CfnAutoScalingGroup(this, 'ASG', asgProps);\n    this.osType = imageConfig.osType;\n    this.autoScalingGroupName = this.getResourceNameAttribute(this.autoScalingGroup.ref),\n    this.autoScalingGroupArn = Stack.of(this).formatArn({\n      service: 'autoscaling',\n      resource: 'autoScalingGroup:*:autoScalingGroupName',\n      resourceName: this.autoScalingGroupName,\n    });\n    this.node.defaultChild = this.autoScalingGroup;\n\n    this.applyUpdatePolicies(props, { desiredCapacity, minCapacity });\n    if (props.init) {\n      this.applyCloudFormationInit(props.init, props.initOptions);\n    }\n\n    this.spotPrice = props.spotPrice;\n\n    if (props.requireImdsv2) {\n      Aspects.of(this).add(new AutoScalingGroupRequireImdsv2Aspect());\n    }\n  }\n\n  /**\n   * Add the security group to all instances via the launch configuration\n   * security groups array.\n   *\n   * @param securityGroup: The security group to add\n   */\n  public addSecurityGroup(securityGroup: ec2.ISecurityGroup): void {\n    this.securityGroups.push(securityGroup);\n  }\n\n  /**\n   * Attach to a classic load balancer\n   */\n  public attachToClassicLB(loadBalancer: elb.LoadBalancer): void {\n    this.loadBalancerNames.push(loadBalancer.loadBalancerName);\n  }\n\n  /**\n   * Attach to ELBv2 Application Target Group\n   */\n  public attachToApplicationTargetGroup(targetGroup: elbv2.IApplicationTargetGroup): elbv2.LoadBalancerTargetProps {\n    if (this.albTargetGroup !== undefined) {\n      throw new Error('Cannot add AutoScalingGroup to 2nd Target Group');\n    }\n\n    this.targetGroupArns.push(targetGroup.targetGroupArn);\n    if (targetGroup instanceof elbv2.ApplicationTargetGroup) {\n      // Copy onto self if it's a concrete type. We need this for autoscaling\n      // based on request count, which we cannot do with an imported TargetGroup.\n      this.albTargetGroup = targetGroup;\n    }\n\n    targetGroup.registerConnectable(this);\n    return { targetType: elbv2.TargetType.INSTANCE };\n  }\n\n  /**\n   * Attach to ELBv2 Application Target Group\n   */\n  public attachToNetworkTargetGroup(targetGroup: elbv2.INetworkTargetGroup): elbv2.LoadBalancerTargetProps {\n    this.targetGroupArns.push(targetGroup.targetGroupArn);\n    return { targetType: elbv2.TargetType.INSTANCE };\n  }\n\n  public addUserData(...commands: string[]): void {\n    this.userData.addCommands(...commands);\n  }\n\n  /**\n   * Adds a statement to the IAM role assumed by instances of this fleet.\n   */\n  public addToRolePolicy(statement: iam.PolicyStatement) {\n    this.role.addToPrincipalPolicy(statement);\n  }\n\n  /**\n   * Use a CloudFormation Init configuration at instance startup\n   *\n   * This does the following:\n   *\n   * - Attaches the CloudFormation Init metadata to the AutoScalingGroup resource.\n   * - Add commands to the UserData to run `cfn-init` and `cfn-signal`.\n   * - Update the instance's CreationPolicy to wait for `cfn-init` to finish\n   *   before reporting success.\n   */\n  public applyCloudFormationInit(init: ec2.CloudFormationInit, options: ApplyCloudFormationInitOptions = {}) {\n    if (!this.autoScalingGroup.cfnOptions.creationPolicy?.resourceSignal) {\n      throw new Error('When applying CloudFormationInit, you must also configure signals by supplying \\'signals\\' at instantiation time.');\n    }\n\n    init.attach(this.autoScalingGroup, {\n      platform: this.osType,\n      instanceRole: this.role,\n      userData: this.userData,\n      configSets: options.configSets,\n      embedFingerprint: options.embedFingerprint,\n      printLog: options.printLog,\n      ignoreFailures: options.ignoreFailures,\n      includeRole: options.includeRole,\n      includeUrl: options.includeUrl,\n    });\n  }\n\n  /**\n   * Ensures newly-launched instances are protected from scale-in.\n   */\n  public protectNewInstancesFromScaleIn() {\n    this.newInstancesProtectedFromScaleIn = true;\n  }\n\n  /**\n   * Returns `true` if newly-launched instances are protected from scale-in.\n   */\n  public areNewInstancesProtectedFromScaleIn(): boolean {\n    return this.newInstancesProtectedFromScaleIn === true;\n  }\n\n  /**\n   * Apply CloudFormation update policies for the AutoScalingGroup\n   */\n  private applyUpdatePolicies(props: AutoScalingGroupProps, signalOptions: RenderSignalsOptions) {\n    // Make sure people are not using the old and new properties together\n    const oldProps: Array<keyof AutoScalingGroupProps> = [\n      'updateType',\n      'rollingUpdateConfiguration',\n      'resourceSignalCount',\n      'resourceSignalTimeout',\n      'replacingUpdateMinSuccessfulInstancesPercent',\n    ];\n    for (const prop of oldProps) {\n      if ((props.signals || props.updatePolicy) && props[prop] !== undefined) {\n        throw new Error(`Cannot set 'signals'/'updatePolicy' and '${prop}' together. Prefer 'signals'/'updatePolicy'`);\n      }\n    }\n\n    // Reify updatePolicy to `rollingUpdate` default in case it is combined with `init`\n    props = {\n      ...props,\n      updatePolicy: props.updatePolicy ?? (props.init ? UpdatePolicy.rollingUpdate() : undefined),\n    };\n\n    if (props.signals || props.updatePolicy) {\n      this.applyNewSignalUpdatePolicies(props, signalOptions);\n    } else {\n      this.applyLegacySignalUpdatePolicies(props);\n    }\n\n    // The following is technically part of the \"update policy\" but it's also a completely\n    // separate aspect of rolling/replacing update, so it's just its own top-level property.\n    // Default is 'true' because that's what you're most likely to want\n    if (props.ignoreUnmodifiedSizeProperties !== false) {\n      this.autoScalingGroup.cfnOptions.updatePolicy = {\n        ...this.autoScalingGroup.cfnOptions.updatePolicy,\n        autoScalingScheduledAction: { ignoreUnmodifiedGroupSizeProperties: true },\n      };\n    }\n\n    if (props.signals && !props.init) {\n      // To be able to send a signal using `cfn-init`, the execution role needs\n      // `cloudformation:SignalResource`. Normally the binding of CfnInit would\n      // grant that permissions and another one, but if the user wants to use\n      // `signals` without `init`, add the permissions here.\n      //\n      // If they call `applyCloudFormationInit()` after construction, nothing bad\n      // happens either, we'll just have a duplicate statement which doesn't hurt.\n      this.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['cloudformation:SignalResource'],\n        resources: [Aws.STACK_ID],\n      }));\n    }\n  }\n\n  /**\n   * Use 'signals' and 'updatePolicy' to determine the creation and update policies\n   */\n  private applyNewSignalUpdatePolicies(props: AutoScalingGroupProps, signalOptions: RenderSignalsOptions) {\n    this.autoScalingGroup.cfnOptions.creationPolicy = props.signals?.renderCreationPolicy(signalOptions);\n    this.autoScalingGroup.cfnOptions.updatePolicy = props.updatePolicy?._renderUpdatePolicy({\n      creationPolicy: this.autoScalingGroup.cfnOptions.creationPolicy,\n    });\n  }\n\n  private applyLegacySignalUpdatePolicies(props: AutoScalingGroupProps) {\n    if (props.updateType === UpdateType.REPLACING_UPDATE) {\n      this.autoScalingGroup.cfnOptions.updatePolicy = {\n        ...this.autoScalingGroup.cfnOptions.updatePolicy,\n        autoScalingReplacingUpdate: {\n          willReplace: true,\n        },\n      };\n\n      if (props.replacingUpdateMinSuccessfulInstancesPercent !== undefined) {\n        // Yes, this goes on CreationPolicy, not as a process parameter to ReplacingUpdate.\n        // It's a little confusing, but the docs seem to explicitly state it will only be used\n        // during the update?\n        //\n        // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-creationpolicy.html\n        this.autoScalingGroup.cfnOptions.creationPolicy = {\n          ...this.autoScalingGroup.cfnOptions.creationPolicy,\n          autoScalingCreationPolicy: {\n            minSuccessfulInstancesPercent: validatePercentage(props.replacingUpdateMinSuccessfulInstancesPercent),\n          },\n        };\n      }\n    } else if (props.updateType === UpdateType.ROLLING_UPDATE) {\n      this.autoScalingGroup.cfnOptions.updatePolicy = {\n        ...this.autoScalingGroup.cfnOptions.updatePolicy,\n        autoScalingRollingUpdate: renderRollingUpdateConfig(props.rollingUpdateConfiguration),\n      };\n    }\n\n    if (props.resourceSignalCount !== undefined || props.resourceSignalTimeout !== undefined) {\n      this.autoScalingGroup.cfnOptions.creationPolicy = {\n        ...this.autoScalingGroup.cfnOptions.creationPolicy,\n        resourceSignal: {\n          count: props.resourceSignalCount,\n          timeout: props.resourceSignalTimeout && props.resourceSignalTimeout.toIsoString(),\n        },\n      };\n    }\n  }\n\n  private renderNotificationConfiguration(): CfnAutoScalingGroup.NotificationConfigurationProperty[] | undefined {\n    if (this.notifications.length === 0) {\n      return undefined;\n    }\n\n    return this.notifications.map(notification => ({\n      topicArn: notification.topic.topicArn,\n      notificationTypes: notification.scalingEvents ? notification.scalingEvents._types : ScalingEvents.ALL._types,\n    }));\n  }\n\n  private renderMetricsCollection(): CfnAutoScalingGroup.MetricsCollectionProperty[] | undefined {\n    if (this.groupMetrics.length === 0) {\n      return undefined;\n    }\n\n    return this.groupMetrics.map(group => ({\n      granularity: '1Minute',\n      metrics: group._metrics?.size !== 0 ? [...group._metrics].map(m => m.name) : undefined,\n    }));\n  }\n}\n\n/**\n * The type of update to perform on instances in this AutoScalingGroup\n *\n * @deprecated Use UpdatePolicy instead\n */\nexport enum UpdateType {\n  /**\n   * Don't do anything\n   */\n  NONE = 'None',\n\n  /**\n   * Replace the entire AutoScalingGroup\n   *\n   * Builds a new AutoScalingGroup first, then delete the old one.\n   */\n  REPLACING_UPDATE = 'Replace',\n\n  /**\n   * Replace the instances in the AutoScalingGroup.\n   */\n  ROLLING_UPDATE = 'RollingUpdate',\n}\n\n/**\n * AutoScalingGroup fleet change notifications configurations.\n * You can configure AutoScaling to send an SNS notification whenever your Auto Scaling group scales.\n */\nexport interface NotificationConfiguration {\n  /**\n   * SNS topic to send notifications about fleet scaling events\n   */\n  readonly topic: sns.ITopic;\n\n  /**\n   * Which fleet scaling events triggers a notification\n   * @default ScalingEvents.ALL\n   */\n  readonly scalingEvents?: ScalingEvents;\n}\n\n/**\n * Fleet scaling events\n */\nexport enum ScalingEvent {\n  /**\n   * Notify when an instance was launched\n   */\n  INSTANCE_LAUNCH = 'autoscaling:EC2_INSTANCE_LAUNCH',\n\n  /**\n   * Notify when an instance was terminated\n   */\n  INSTANCE_TERMINATE = 'autoscaling:EC2_INSTANCE_TERMINATE',\n\n  /**\n   * Notify when an instance failed to terminate\n   */\n  INSTANCE_TERMINATE_ERROR = 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR',\n\n  /**\n   * Notify when an instance failed to launch\n   */\n  INSTANCE_LAUNCH_ERROR = 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR',\n\n  /**\n   * Send a test notification to the topic\n   */\n  TEST_NOTIFICATION = 'autoscaling:TEST_NOTIFICATION'\n}\n\n/**\n * Additional settings when a rolling update is selected\n * @deprecated use `UpdatePolicy.rollingUpdate()`\n */\nexport interface RollingUpdateConfiguration {\n  /**\n   * The maximum number of instances that AWS CloudFormation updates at once.\n   *\n   * @default 1\n   */\n  readonly maxBatchSize?: number;\n\n  /**\n   * The minimum number of instances that must be in service before more instances are replaced.\n   *\n   * This number affects the speed of the replacement.\n   *\n   * @default 0\n   */\n  readonly minInstancesInService?: number;\n\n  /**\n   * The percentage of instances that must signal success for an update to succeed.\n   *\n   * If an instance doesn't send a signal within the time specified in the\n   * pauseTime property, AWS CloudFormation assumes that the instance wasn't\n   * updated.\n   *\n   * This number affects the success of the replacement.\n   *\n   * If you specify this property, you must also enable the\n   * waitOnResourceSignals and pauseTime properties.\n   *\n   * @default 100\n   */\n  readonly minSuccessfulInstancesPercent?: number;\n\n  /**\n   * The pause time after making a change to a batch of instances.\n   *\n   * This is intended to give those instances time to start software applications.\n   *\n   * Specify PauseTime in the ISO8601 duration format (in the format\n   * PT#H#M#S, where each # is the number of hours, minutes, and seconds,\n   * respectively). The maximum PauseTime is one hour (PT1H).\n   *\n   * @default Duration.minutes(5) if the waitOnResourceSignals property is true, otherwise 0\n   */\n  readonly pauseTime?: Duration;\n\n  /**\n   * Specifies whether the Auto Scaling group waits on signals from new instances during an update.\n   *\n   * AWS CloudFormation must receive a signal from each new instance within\n   * the specified PauseTime before continuing the update.\n   *\n   * To have instances wait for an Elastic Load Balancing health check before\n   * they signal success, add a health-check verification by using the\n   * cfn-init helper script. For an example, see the verify_instance_health\n   * command in the Auto Scaling rolling updates sample template.\n   *\n   * @default true if you specified the minSuccessfulInstancesPercent property, false otherwise\n   */\n  readonly waitOnResourceSignals?: boolean;\n\n  /**\n   * Specifies the Auto Scaling processes to suspend during a stack update.\n   *\n   * Suspending processes prevents Auto Scaling from interfering with a stack\n   * update.\n   *\n   * @default HealthCheck, ReplaceUnhealthy, AZRebalance, AlarmNotification, ScheduledActions.\n   */\n  readonly suspendProcesses?: ScalingProcess[];\n}\n\n/**\n * A list of ScalingEvents, you can use one of the predefined lists, such as ScalingEvents.ERRORS\n * or create a custom group by instantiating a `NotificationTypes` object, e.g: `new NotificationTypes(`NotificationType.INSTANCE_LAUNCH`)`.\n */\nexport class ScalingEvents {\n  /**\n   * Fleet scaling errors\n   */\n  public static readonly ERRORS = new ScalingEvents(ScalingEvent.INSTANCE_LAUNCH_ERROR, ScalingEvent.INSTANCE_TERMINATE_ERROR);\n\n  /**\n   * All fleet scaling events\n   */\n  public static readonly ALL = new ScalingEvents(ScalingEvent.INSTANCE_LAUNCH,\n    ScalingEvent.INSTANCE_LAUNCH_ERROR,\n    ScalingEvent.INSTANCE_TERMINATE,\n    ScalingEvent.INSTANCE_TERMINATE_ERROR);\n\n  /**\n   * Fleet scaling launch events\n   */\n  public static readonly LAUNCH_EVENTS = new ScalingEvents(ScalingEvent.INSTANCE_LAUNCH, ScalingEvent.INSTANCE_LAUNCH_ERROR);\n\n  /**\n   * Fleet termination launch events\n   */\n  public static readonly TERMINATION_EVENTS = new ScalingEvents(ScalingEvent.INSTANCE_TERMINATE, ScalingEvent.INSTANCE_TERMINATE_ERROR);\n\n\n  /**\n   * @internal\n   */\n  public readonly _types: ScalingEvent[];\n\n  constructor(...types: ScalingEvent[]) {\n    this._types = types;\n  }\n}\n\nexport enum ScalingProcess {\n  LAUNCH = 'Launch',\n  TERMINATE = 'Terminate',\n  HEALTH_CHECK = 'HealthCheck',\n  REPLACE_UNHEALTHY = 'ReplaceUnhealthy',\n  AZ_REBALANCE = 'AZRebalance',\n  ALARM_NOTIFICATION = 'AlarmNotification',\n  SCHEDULED_ACTIONS = 'ScheduledActions',\n  ADD_TO_LOAD_BALANCER = 'AddToLoadBalancer'\n}\n\n// Recommended list of processes to suspend from here:\n// https://aws.amazon.com/premiumsupport/knowledge-center/auto-scaling-group-rolling-updates/\nconst DEFAULT_SUSPEND_PROCESSES = [ScalingProcess.HEALTH_CHECK, ScalingProcess.REPLACE_UNHEALTHY, ScalingProcess.AZ_REBALANCE,\n  ScalingProcess.ALARM_NOTIFICATION, ScalingProcess.SCHEDULED_ACTIONS];\n\n/**\n * EC2 Heath check options\n */\nexport interface Ec2HealthCheckOptions {\n  /**\n   * Specified the time Auto Scaling waits before checking the health status of an EC2 instance that has come into service\n   *\n   * @default Duration.seconds(0)\n   */\n  readonly grace?: Duration;\n}\n\n/**\n * ELB Heath check options\n */\nexport interface ElbHealthCheckOptions {\n  /**\n   * Specified the time Auto Scaling waits before checking the health status of an EC2 instance that has come into service\n   *\n   * This option is required for ELB health checks.\n   */\n  readonly grace: Duration;\n}\n\n/**\n * Health check settings\n */\nexport class HealthCheck {\n  /**\n   * Use EC2 for health checks\n   *\n   * @param options EC2 health check options\n   */\n  public static ec2(options: Ec2HealthCheckOptions = {}): HealthCheck {\n    return new HealthCheck(HealthCheckType.EC2, options.grace);\n  }\n\n  /**\n   * Use ELB for health checks.\n   * It considers the instance unhealthy if it fails either the EC2 status checks or the load balancer health checks.\n   *\n   * @param options ELB health check options\n   */\n  public static elb(options: ElbHealthCheckOptions): HealthCheck {\n    return new HealthCheck(HealthCheckType.ELB, options.grace);\n  }\n\n  private constructor(public readonly type: string, public readonly gracePeriod?: Duration) { }\n}\n\nenum HealthCheckType {\n  EC2 = 'EC2',\n  ELB = 'ELB',\n}\n\n/**\n * Render the rolling update configuration into the appropriate object\n */\nfunction renderRollingUpdateConfig(config: RollingUpdateConfiguration = {}): CfnAutoScalingRollingUpdate {\n  const waitOnResourceSignals = config.minSuccessfulInstancesPercent !== undefined;\n  const pauseTime = config.pauseTime || (waitOnResourceSignals ? Duration.minutes(5) : Duration.seconds(0));\n\n  return {\n    maxBatchSize: config.maxBatchSize,\n    minInstancesInService: config.minInstancesInService,\n    minSuccessfulInstancesPercent: validatePercentage(config.minSuccessfulInstancesPercent),\n    waitOnResourceSignals,\n    pauseTime: pauseTime && pauseTime.toIsoString(),\n    suspendProcesses: config.suspendProcesses ?? DEFAULT_SUSPEND_PROCESSES,\n  };\n}\n\nfunction validatePercentage(x?: number): number | undefined {\n  if (x === undefined || (0 <= x && x <= 100)) { return x; }\n  throw new Error(`Expected: a percentage 0..100, got: ${x}`);\n}\n\n/**\n * An AutoScalingGroup\n */\nexport interface IAutoScalingGroup extends IResource, iam.IGrantable {\n  /**\n   * The name of the AutoScalingGroup\n   * @attribute\n   */\n  readonly autoScalingGroupName: string;\n\n  /**\n   * The arn of the AutoScalingGroup\n   * @attribute\n   */\n  readonly autoScalingGroupArn: string;\n\n  /**\n   * The operating system family that the instances in this auto-scaling group belong to.\n   * Is 'UNKNOWN' for imported ASGs.\n   */\n  readonly osType: ec2.OperatingSystemType;\n\n  /**\n   * Add command to the startup script of fleet instances.\n   * The command must be in the scripting language supported by the fleet's OS (i.e. Linux/Windows).\n   * Does nothing for imported ASGs.\n   */\n  addUserData(...commands: string[]): void;\n\n  /**\n   * Send a message to either an SQS queue or SNS topic when instances launch or terminate\n   */\n  addLifecycleHook(id: string, props: BasicLifecycleHookProps): LifecycleHook;\n\n  /**\n   * Scale out or in based on time\n   */\n  scaleOnSchedule(id: string, props: BasicScheduledActionProps): ScheduledAction;\n\n  /**\n   * Scale out or in to achieve a target CPU utilization\n   */\n  scaleOnCpuUtilization(id: string, props: CpuUtilizationScalingProps): TargetTrackingScalingPolicy;\n\n  /**\n   * Scale out or in to achieve a target network ingress rate\n   */\n  scaleOnIncomingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy;\n\n  /**\n   * Scale out or in to achieve a target network egress rate\n   */\n  scaleOnOutgoingBytes(id: string, props: NetworkUtilizationScalingProps): TargetTrackingScalingPolicy;\n\n  /**\n   * Scale out or in in order to keep a metric around a target value\n   */\n  scaleToTrackMetric(id: string, props: MetricTargetTrackingProps): TargetTrackingScalingPolicy;\n\n  /**\n   * Scale out or in, in response to a metric\n   */\n  scaleOnMetric(id: string, props: BasicStepScalingPolicyProps): StepScalingPolicy;\n}\n\n/**\n * Properties for enabling scaling based on CPU utilization\n */\nexport interface CpuUtilizationScalingProps extends BaseTargetTrackingProps {\n  /**\n   * Target average CPU utilization across the task\n   */\n  readonly targetUtilizationPercent: number;\n}\n\n/**\n * Properties for enabling scaling based on network utilization\n */\nexport interface NetworkUtilizationScalingProps extends BaseTargetTrackingProps {\n  /**\n   * Target average bytes/seconds on each instance\n   */\n  readonly targetBytesPerSecond: number;\n}\n\n/**\n * Properties for enabling scaling based on request/second\n */\nexport interface RequestCountScalingProps extends BaseTargetTrackingProps {\n  /**\n   * Target average requests/seconds on each instance\n   *\n   * @deprecated Use 'targetRequestsPerMinute' instead\n   * @default - Specify exactly one of 'targetRequestsPerMinute' and 'targetRequestsPerSecond'\n   */\n  readonly targetRequestsPerSecond?: number;\n\n  /**\n   * Target average requests/minute on each instance\n   * @default - Specify exactly one of 'targetRequestsPerMinute' and 'targetRequestsPerSecond'\n   */\n  readonly targetRequestsPerMinute?: number;\n}\n\n/**\n * Properties for enabling tracking of an arbitrary metric\n */\nexport interface MetricTargetTrackingProps extends BaseTargetTrackingProps {\n  /**\n   * Metric to track\n   *\n   * The metric must represent a utilization, so that if it's higher than the\n   * target value, your ASG should scale out, and if it's lower it should\n   * scale in.\n   */\n  readonly metric: cloudwatch.IMetric;\n\n  /**\n   * Value to keep the metric around\n   */\n  readonly targetValue: number;\n}\n\n/**\n * Synthesize an array of block device mappings from a list of block device\n *\n * @param construct the instance/asg construct, used to host any warning\n * @param blockDevices list of block devices\n */\nfunction synthesizeBlockDeviceMappings(construct: Construct, blockDevices: BlockDevice[]): CfnLaunchConfiguration.BlockDeviceMappingProperty[] {\n  return blockDevices.map<CfnLaunchConfiguration.BlockDeviceMappingProperty>(({ deviceName, volume, mappingEnabled }) => {\n    const { virtualName, ebsDevice: ebs } = volume;\n\n    if (volume === BlockDeviceVolume._NO_DEVICE || mappingEnabled === false) {\n      return {\n        deviceName,\n        noDevice: true,\n      };\n    }\n\n    if (ebs) {\n      const { iops, volumeType } = ebs;\n\n      if (!iops) {\n        if (volumeType === EbsDeviceVolumeType.IO1) {\n          throw new Error('iops property is required with volumeType: EbsDeviceVolumeType.IO1');\n        }\n      } else if (volumeType !== EbsDeviceVolumeType.IO1) {\n        Annotations.of(construct).addWarning('iops will be ignored without volumeType: EbsDeviceVolumeType.IO1');\n      }\n    }\n\n    return {\n      deviceName, ebs, virtualName,\n    };\n  });\n}\n\n/**\n * Options for applying CloudFormation init to an instance or instance group\n */\nexport interface ApplyCloudFormationInitOptions {\n  /**\n   * ConfigSet to activate\n   *\n   * @default ['default']\n   */\n  readonly configSets?: string[];\n\n  /**\n   * Force instance replacement by embedding a config fingerprint\n   *\n   * If `true` (the default), a hash of the config will be embedded into the\n   * UserData, so that if the config changes, the UserData changes and\n   * instances will be replaced (given an UpdatePolicy has been configured on\n   * the AutoScalingGroup).\n   *\n   * If `false`, no such hash will be embedded, and if the CloudFormation Init\n   * config changes nothing will happen to the running instances. If a\n   * config update introduces errors, you will not notice until after the\n   * CloudFormation deployment successfully finishes and the next instance\n   * fails to launch.\n   *\n   * @default true\n   */\n  readonly embedFingerprint?: boolean;\n\n  /**\n   * Print the results of running cfn-init to the Instance System Log\n   *\n   * By default, the output of running cfn-init is written to a log file\n   * on the instance. Set this to `true` to print it to the System Log\n   * (visible from the EC2 Console), `false` to not print it.\n   *\n   * (Be aware that the system log is refreshed at certain points in\n   * time of the instance life cycle, and successful execution may\n   * not always show up).\n   *\n   * @default true\n   */\n  readonly printLog?: boolean;\n\n  /**\n   * Don't fail the instance creation when cfn-init fails\n   *\n   * You can use this to prevent CloudFormation from rolling back when\n   * instances fail to start up, to help in debugging.\n   *\n   * @default false\n   */\n  readonly ignoreFailures?: boolean;\n\n  /**\n   * Include --url argument when running cfn-init and cfn-signal commands\n   *\n   * This will be the cloudformation endpoint in the deployed region\n   * e.g. https://cloudformation.us-east-1.amazonaws.com\n   *\n   * @default false\n   */\n  readonly includeUrl?: boolean;\n\n  /**\n  * Include --role argument when running cfn-init and cfn-signal commands\n  *\n  * This will be the IAM instance profile attached to the EC2 instance\n  *\n  * @default false\n  */\n  readonly includeRole?: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
