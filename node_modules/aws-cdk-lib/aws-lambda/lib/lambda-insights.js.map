{
  "version": 3,
  "sources": ["lambda-insights.ts"],
  "sourcesContent": ["import { Lazy, Stack, Token } from '../../core';\nimport { FactName, RegionInfo } from '../../region-info';\nimport { Construct, IConstruct } from 'constructs';\nimport { Architecture } from './architecture';\nimport { IFunction } from './function-base';\n\n\n/**\n * Config returned from {@link LambdaInsightsVersion._bind}\n */\ninterface InsightsBindConfig {\n  /**\n   * ARN of the Lambda Insights Layer Version\n   */\n  readonly arn: string;\n}\n\n// To add new versions, update fact-tables.ts `CLOUDWATCH_LAMBDA_INSIGHTS_ARNS` and create a new `public static readonly VERSION_A_B_C_D`\n\n/**\n * Version of CloudWatch Lambda Insights\n */\nexport abstract class LambdaInsightsVersion {\n\n  /**\n   * Version 1.0.54.0\n   */\n  public static readonly VERSION_1_0_54_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.54.0');\n\n  /**\n   * Version 1.0.86.0\n   */\n  public static readonly VERSION_1_0_86_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.86.0');\n\n  /**\n   * Version 1.0.89.0\n   */\n  public static readonly VERSION_1_0_89_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.89.0');\n\n  /**\n   * Version 1.0.98.0\n   */\n  public static readonly VERSION_1_0_98_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.98.0');\n\n  /**\n   * Version 1.0.119.0\n   */\n  public static readonly VERSION_1_0_119_0 = LambdaInsightsVersion.fromInsightsVersion('1.0.119.0');\n\n  /**\n   * Use the insights extension associated with the provided ARN. Make sure the ARN is associated\n   * with same region as your function\n   *\n   * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versions.html\n   */\n  public static fromInsightVersionArn(arn: string): LambdaInsightsVersion {\n    class InsightsArn extends LambdaInsightsVersion {\n      public readonly layerVersionArn = arn;\n      public _bind(_scope: Construct, _function: IFunction): InsightsBindConfig {\n        return { arn };\n      }\n    }\n    return new InsightsArn();\n  }\n\n  // Use the verison to build the object. Not meant to be called by the user -- user should use e.g. VERSION_1_0_54_0\n  private static fromInsightsVersion(insightsVersion: string): LambdaInsightsVersion {\n\n    class InsightsVersion extends LambdaInsightsVersion {\n      public readonly layerVersionArn = Lazy.uncachedString({\n        produce: (context) => getVersionArn(context.scope, insightsVersion),\n      });\n\n      public _bind(_scope: Construct, _function: IFunction): InsightsBindConfig {\n        const arch = _function.architecture?.name ?? Architecture.X86_64.name;\n        // Check if insights version is valid. This should only happen if one of the public static readonly versions are set incorrectly\n        // or if the version is not available for the Lambda Architecture\n        const versionExists = RegionInfo.regions.some(regionInfo => regionInfo.cloudwatchLambdaInsightsArn(insightsVersion, arch));\n        if (!versionExists) {\n          throw new Error(`Insights version ${insightsVersion} does not exist.`);\n        }\n        return {\n          arn: getVersionArn(_scope, insightsVersion, arch),\n        };\n      }\n    }\n    return new InsightsVersion();\n  }\n\n  /**\n   * The arn of the Lambda Insights extension\n   */\n  public readonly layerVersionArn: string = '';\n\n  /**\n   * Returns the arn of the Lambda Insights extension based on the\n   * Lambda architecture\n   * @internal\n   */\n  public abstract _bind(_scope: Construct, _function: IFunction): InsightsBindConfig;\n}\n\n/**\n * Function to retrieve the correct Lambda Insights ARN from RegionInfo,\n * or create a mapping to look it up at stack deployment time.\n *\n * This function is run on CDK synthesis.\n */\nfunction getVersionArn(scope: IConstruct, insightsVersion: string, architecture?: string): string {\n\n  const scopeStack = Stack.of(scope);\n  const region = scopeStack.region;\n  const arch = architecture ?? Architecture.X86_64.name;\n\n  // Region is defined, look up the arn, or throw an error if the version isn't supported by a region\n  if (region !== undefined && !Token.isUnresolved(region)) {\n    const arn = RegionInfo.get(region).cloudwatchLambdaInsightsArn(insightsVersion, arch);\n    if (arn === undefined) {\n      throw new Error(`Insights version ${insightsVersion} is not supported in region ${region}`);\n    }\n    return arn;\n  }\n\n  // Otherwise, need to add a mapping to be looked up at deployment time\n  return scopeStack.regionalFact(FactName.cloudwatchLambdaInsightsVersion(insightsVersion, arch));\n}\n"],
  "mappings": "iKAAA,OAAA,QAAA,cACA,cAAA,QAAA,qBAEA,eAAA,QAAA,kBAmBA,2BAA2C,CAA3C,aAAA,CAsEkB,KAAA,gBAA0B,SArC5B,uBAAsB,IAAW,CAC7C,yBAA0B,sBAAqB,CAA/C,aAAA,qBACkB,KAAA,gBAAkB,IAC3B,MAAM,OAAmB,UAAoB,CAClD,MAAO,CAAE,MAGb,MAAO,IAAI,mBAIE,qBAAoB,gBAAuB,CAExD,6BAA8B,sBAAqB,CAAnD,aAAA,qBACkB,KAAA,gBAAkB,OAAA,KAAK,eAAe,CACpD,QAAS,AAAC,SAAY,cAAc,QAAQ,MAAO,mBAG9C,MAAM,OAAmB,UAAoB,WAClD,KAAM,MAAI,IAAA,IAAG,UAAU,gBAAY,MAAA,KAAA,OAAA,OAAA,GAAE,QAAI,MAAA,KAAA,OAAA,GAAI,eAAA,aAAa,OAAO,KAIjE,GAAI,CADkB,cAAA,WAAW,QAAQ,KAAK,YAAc,WAAW,4BAA4B,gBAAiB,OAElH,KAAM,IAAI,OAAM,oBAAoB,mCAEtC,MAAO,CACL,IAAK,cAAc,OAAQ,gBAAiB,QAIlD,MAAO,IAAI,kBAhEf,QAAA,sBAAA,4IAKyB,sBAAA,iBAAmB,sBAAsB,oBAAoB,YAK7D,sBAAA,iBAAmB,sBAAsB,oBAAoB,YAK7D,sBAAA,iBAAmB,sBAAsB,oBAAoB,YAK7D,sBAAA,iBAAmB,sBAAsB,oBAAoB,YAK7D,sBAAA,kBAAoB,sBAAsB,oBAAoB,aA6DvF,uBAAuB,MAAmB,gBAAyB,aAAqB,CAEtF,KAAM,YAAa,OAAA,MAAM,GAAG,OACtB,OAAS,WAAW,OACpB,KAAO,cAAY,KAAZ,aAAgB,eAAA,aAAa,OAAO,KAGjD,GAAI,SAAW,QAAa,CAAC,OAAA,MAAM,aAAa,QAAS,CACvD,KAAM,KAAM,cAAA,WAAW,IAAI,QAAQ,4BAA4B,gBAAiB,MAChF,GAAI,MAAQ,OACV,KAAM,IAAI,OAAM,oBAAoB,8CAA8C,UAEpF,MAAO,KAIT,MAAO,YAAW,aAAa,cAAA,SAAS,gCAAgC,gBAAiB",
  "names": []
}
