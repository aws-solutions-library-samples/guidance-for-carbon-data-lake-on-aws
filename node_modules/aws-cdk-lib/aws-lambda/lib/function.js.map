{
  "version": 3,
  "sources": ["function.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport { IProfilingGroup, ProfilingGroup, ComputePlatform } from '../../aws-codeguruprofiler';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as logs from '../../aws-logs';\nimport * as sns from '../../aws-sns';\nimport * as sqs from '../../aws-sqs';\nimport { Annotations, ArnFormat, CfnResource, Duration, Fn, Lazy, Names, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { Architecture } from './architecture';\nimport { Code, CodeConfig } from './code';\nimport { ICodeSigningConfig } from './code-signing-config';\nimport { EventInvokeConfigOptions } from './event-invoke-config';\nimport { IEventSource } from './event-source';\nimport { FileSystem } from './filesystem';\nimport { FunctionAttributes, FunctionBase, IFunction } from './function-base';\nimport { calculateFunctionHash, trimFromStart } from './function-hash';\nimport { Handler } from './handler';\nimport { LambdaInsightsVersion } from './lambda-insights';\nimport { Version, VersionOptions } from './lambda-version';\nimport { CfnFunction } from './lambda.generated';\nimport { LayerVersion, ILayerVersion } from './layers';\nimport { Runtime } from './runtime';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line\nimport { LogRetentionRetryOptions } from './log-retention';\n\n/**\n * X-Ray Tracing Modes (https://docs.aws.amazon.com/lambda/latest/dg/API_TracingConfig.html)\n */\nexport enum Tracing {\n  /**\n   * Lambda will respect any tracing header it receives from an upstream service.\n   * If no tracing header is received, Lambda will call X-Ray for a tracing decision.\n   */\n  ACTIVE = 'Active',\n  /**\n   * Lambda will only trace the request from an upstream service\n   * if it contains a tracing header with \"sampled=1\"\n   */\n  PASS_THROUGH = 'PassThrough',\n  /**\n   * Lambda will not trace any request.\n   */\n  DISABLED = 'Disabled'\n}\n\n/**\n * Non runtime options\n */\nexport interface FunctionOptions extends EventInvokeConfigOptions {\n  /**\n   * A description of the function.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n\n  /**\n   * The function execution time (in seconds) after which Lambda terminates\n   * the function. Because the execution time affects cost, set this value\n   * based on the function's expected execution time.\n   *\n   * @default Duration.seconds(3)\n   */\n  readonly timeout?: Duration;\n\n  /**\n   * Key-value pairs that Lambda caches and makes available for your Lambda\n   * functions. Use environment variables to apply configuration changes, such\n   * as test and production environment configurations, without changing your\n   * Lambda function source code.\n   *\n   * @default - No environment variables.\n   */\n  readonly environment?: { [key: string]: string };\n\n  /**\n   * A name for the function.\n   *\n   * @default - AWS CloudFormation generates a unique physical ID and uses that\n   * ID for the function's name. For more information, see Name Type.\n   */\n  readonly functionName?: string;\n\n  /**\n   * The amount of memory, in MB, that is allocated to your Lambda function.\n   * Lambda uses this value to proportionally allocate the amount of CPU\n   * power. For more information, see Resource Model in the AWS Lambda\n   * Developer Guide.\n   *\n   * @default 128\n   */\n  readonly memorySize?: number;\n\n  /**\n   * Initial policy statements to add to the created Lambda Role.\n   *\n   * You can call `addToRolePolicy` to the created lambda to add statements post creation.\n   *\n   * @default - No policy statements are added to the created Lambda role.\n   */\n  readonly initialPolicy?: iam.PolicyStatement[];\n\n  /**\n   * Lambda execution role.\n   *\n   * This is the role that will be assumed by the function upon execution.\n   * It controls the permissions that the function will have. The Role must\n   * be assumable by the 'lambda.amazonaws.com' service principal.\n   *\n   * The default Role automatically has permissions granted for Lambda execution. If you\n   * provide a Role, you must add the relevant AWS managed policies yourself.\n   *\n   * The relevant managed policies are \"service-role/AWSLambdaBasicExecutionRole\" and\n   * \"service-role/AWSLambdaVPCAccessExecutionRole\".\n   *\n   * @default - A unique role will be generated for this lambda function.\n   * Both supplied and generated roles can always be changed by calling `addToRolePolicy`.\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * VPC network to place Lambda network interfaces\n   *\n   * Specify this if the Lambda function needs to access resources in a VPC.\n   *\n   * @default - Function is not placed within a VPC.\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * Where to place the network interfaces within the VPC.\n   *\n   * Only used if 'vpc' is supplied. Note: internet access for Lambdas\n   * requires a NAT gateway, so picking Public subnets is not allowed.\n   *\n   * @default - the Vpc default strategy if not specified\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n\n  /**\n   * What security group to associate with the Lambda's network interfaces.\n   * This property is being deprecated, consider using securityGroups instead.\n   *\n   * Only used if 'vpc' is supplied.\n   *\n   * Use securityGroups property instead.\n   * Function constructor will throw an error if both are specified.\n   *\n   * @default - If the function is placed within a VPC and a security group is\n   * not specified, either by this or securityGroups prop, a dedicated security\n   * group will be created for this function.\n   *\n   * @deprecated - This property is deprecated, use securityGroups instead\n   */\n  readonly securityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * The list of security groups to associate with the Lambda's network interfaces.\n   *\n   * Only used if 'vpc' is supplied.\n   *\n   * @default - If the function is placed within a VPC and a security group is\n   * not specified, either by this or securityGroup prop, a dedicated security\n   * group will be created for this function.\n   */\n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n  /**\n   * Whether to allow the Lambda to send all network traffic\n   *\n   * If set to false, you must individually add traffic rules to allow the\n   * Lambda to connect to network targets.\n   *\n   * @default true\n   */\n  readonly allowAllOutbound?: boolean;\n\n  /**\n   * Enabled DLQ. If `deadLetterQueue` is undefined,\n   * an SQS queue with default options will be defined for your Function.\n   *\n   * @default - false unless `deadLetterQueue` is set, which implies DLQ is enabled.\n   */\n  readonly deadLetterQueueEnabled?: boolean;\n\n  /**\n   * The SQS queue to use if DLQ is enabled.\n   * If SNS topic is desired, specify `deadLetterTopic` property instead.\n   *\n   * @default - SQS queue with 14 day retention period if `deadLetterQueueEnabled` is `true`\n   */\n  readonly deadLetterQueue?: sqs.IQueue;\n\n  /**\n   * The SNS topic to use as a DLQ.\n   * Note that if `deadLetterQueueEnabled` is set to `true`, an SQS queue will be created\n   * rather than an SNS topic. Using an SNS topic as a DLQ requires this property to be set explicitly.\n   *\n   * @default - no SNS topic\n   */\n  readonly deadLetterTopic?: sns.ITopic;\n\n  /**\n   * Enable AWS X-Ray Tracing for Lambda Function.\n   *\n   * @default Tracing.Disabled\n   */\n  readonly tracing?: Tracing;\n\n  /**\n   * Enable profiling.\n   * @see https://docs.aws.amazon.com/codeguru/latest/profiler-ug/setting-up-lambda.html\n   *\n   * @default - No profiling.\n   */\n  readonly profiling?: boolean;\n\n  /**\n   * Profiling Group.\n   * @see https://docs.aws.amazon.com/codeguru/latest/profiler-ug/setting-up-lambda.html\n   *\n   * @default - A new profiling group will be created if `profiling` is set.\n   */\n  readonly profilingGroup?: IProfilingGroup;\n\n  /**\n   * Specify the version of CloudWatch Lambda insights to use for monitoring\n   * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights.html\n   *\n   * When used with `DockerImageFunction` or `DockerImageCode`, the Docker image should have\n   * the Lambda insights agent installed.\n   * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-docker.html\n   *\n   * @default - No Lambda Insights\n   */\n  readonly insightsVersion?: LambdaInsightsVersion;\n\n  /**\n   * A list of layers to add to the function's execution environment. You can configure your Lambda function to pull in\n   * additional code during initialization in the form of layers. Layers are packages of libraries or other dependencies\n   * that can be used by multiple functions.\n   *\n   * @default - No layers.\n   */\n  readonly layers?: ILayerVersion[];\n\n  /**\n   * The maximum of concurrent executions you want to reserve for the function.\n   *\n   * @default - No specific limit - account limit.\n   * @see https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html\n   */\n  readonly reservedConcurrentExecutions?: number;\n\n  /**\n   * Event sources for this function.\n   *\n   * You can also add event sources using `addEventSource`.\n   *\n   * @default - No event sources.\n   */\n  readonly events?: IEventSource[];\n\n  /**\n   * The number of days log events are kept in CloudWatch Logs. When updating\n   * this property, unsetting it doesn't remove the log retention policy. To\n   * remove the retention policy, set the value to `INFINITE`.\n   *\n   * @default logs.RetentionDays.INFINITE\n   */\n  readonly logRetention?: logs.RetentionDays;\n\n  /**\n   * The IAM role for the Lambda function associated with the custom resource\n   * that sets the retention policy.\n   *\n   * @default - A new role is created.\n   */\n  readonly logRetentionRole?: iam.IRole;\n\n  /**\n   * When log retention is specified, a custom resource attempts to create the CloudWatch log group.\n   * These options control the retry policy when interacting with CloudWatch APIs.\n   *\n   * @default - Default AWS SDK retry options.\n   */\n  readonly logRetentionRetryOptions?: LogRetentionRetryOptions;\n\n  /**\n   * Options for the `lambda.Version` resource automatically created by the\n   * `fn.currentVersion` method.\n   * @default - default options as described in `VersionOptions`\n   */\n  readonly currentVersionOptions?: VersionOptions;\n\n  /**\n   * The filesystem configuration for the lambda function\n   *\n   * @default - will not mount any filesystem\n   */\n  readonly filesystem?: FileSystem;\n\n  /**\n   * Lambda Functions in a public subnet can NOT access the internet.\n   * Use this property to acknowledge this limitation and still place the function in a public subnet.\n   * @see https://stackoverflow.com/questions/52992085/why-cant-an-aws-lambda-function-inside-a-public-subnet-in-a-vpc-connect-to-the/52994841#52994841\n   *\n   * @default false\n   */\n  readonly allowPublicSubnet?: boolean;\n\n  /**\n   * The AWS KMS key that's used to encrypt your function's environment variables.\n   *\n   * @default - AWS Lambda creates and uses an AWS managed customer master key (CMK).\n   */\n  readonly environmentEncryption?: kms.IKey;\n\n  /**\n   * Code signing config associated with this function\n   *\n   * @default - Not Sign the Code\n   */\n  readonly codeSigningConfig?: ICodeSigningConfig;\n\n  /**\n   * DEPRECATED\n   * @default [Architecture.X86_64]\n   * @deprecated use `architecture`\n   */\n  readonly architectures?: Architecture[];\n\n  /**\n   * The system architectures compatible with this lambda function.\n   * @default Architecture.X86_64\n   */\n  readonly architecture?: Architecture;\n}\n\nexport interface FunctionProps extends FunctionOptions {\n  /**\n   * The runtime environment for the Lambda function that you are uploading.\n   * For valid values, see the Runtime property in the AWS Lambda Developer\n   * Guide.\n   *\n   * Use `Runtime.FROM_IMAGE` when when defining a function from a Docker image.\n   */\n  readonly runtime: Runtime;\n\n  /**\n   * The source code of your Lambda function. You can point to a file in an\n   * Amazon Simple Storage Service (Amazon S3) bucket or specify your source\n   * code as inline text.\n   */\n  readonly code: Code;\n\n  /**\n   * The name of the method within your code that Lambda calls to execute\n   * your function. The format includes the file name. It can also include\n   * namespaces and other qualifiers, depending on the runtime.\n   * For more information, see https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-features.html#gettingstarted-features-programmingmodel.\n   *\n   * Use `Handler.FROM_IMAGE` when defining a function from a Docker image.\n   *\n   * NOTE: If you specify your source code as inline text by specifying the\n   * ZipFile property within the Code property, specify index.function_name as\n   * the handler.\n   */\n  readonly handler: string;\n}\n\n/**\n * Deploys a file from inside the construct library as a function.\n *\n * The supplied file is subject to the 4096 bytes limit of being embedded in a\n * CloudFormation template.\n *\n * The construct includes an associated role with the lambda.\n *\n * This construct does not yet reproduce all features from the underlying resource\n * library.\n */\nexport class Function extends FunctionBase {\n\n  /**\n   * Returns a `lambda.Version` which represents the current version of this\n   * Lambda function. A new version will be created every time the function's\n   * configuration changes.\n   *\n   * You can specify options for this version using the `currentVersionOptions`\n   * prop when initializing the `lambda.Function`.\n   */\n  public get currentVersion(): Version {\n    if (this._currentVersion) {\n      return this._currentVersion;\n    }\n\n    this._currentVersion = new Version(this, 'CurrentVersion', {\n      lambda: this,\n      ...this.currentVersionOptions,\n    });\n\n    // override the version's logical ID with a lazy string which includes the\n    // hash of the function itself, so a new version resource is created when\n    // the function configuration changes.\n    const cfn = this._currentVersion.node.defaultChild as CfnResource;\n    const originalLogicalId = this.stack.resolve(cfn.logicalId) as string;\n\n    cfn.overrideLogicalId(Lazy.uncachedString({\n      produce: () => {\n        const hash = calculateFunctionHash(this);\n        const logicalId = trimFromStart(originalLogicalId, 255 - 32);\n        return `${logicalId}${hash}`;\n      },\n    }));\n\n    return this._currentVersion;\n  }\n\n  /** @internal */\n  public static _VER_PROPS: { [key: string]: boolean } = {};\n\n  /**\n   * Record whether specific properties in the `AWS::Lambda::Function` resource should\n   * also be associated to the Version resource.\n   * See 'currentVersion' section in the module README for more details.\n   * @param propertyName The property to classify\n   * @param locked whether the property should be associated to the version or not.\n   */\n  public static classifyVersionProperty(propertyName: string, locked: boolean) {\n    this._VER_PROPS[propertyName] = locked;\n  }\n\n  /**\n   * Import a lambda function into the CDK using its name\n   */\n  public static fromFunctionName(scope: Construct, id: string, functionName: string): IFunction {\n    return Function.fromFunctionAttributes(scope, id, {\n      functionArn: Stack.of(scope).formatArn({\n        service: 'lambda',\n        resource: 'function',\n        resourceName: functionName,\n        arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n      }),\n    });\n  }\n\n  /**\n   * Import a lambda function into the CDK using its ARN\n   */\n  public static fromFunctionArn(scope: Construct, id: string, functionArn: string): IFunction {\n    return Function.fromFunctionAttributes(scope, id, { functionArn });\n  }\n\n  /**\n   * Creates a Lambda function object which represents a function not defined\n   * within this stack.\n   *\n   * @param scope The parent construct\n   * @param id The name of the lambda construct\n   * @param attrs the attributes of the function to import\n   */\n  public static fromFunctionAttributes(scope: Construct, id: string, attrs: FunctionAttributes): IFunction {\n    const functionArn = attrs.functionArn;\n    const functionName = extractNameFromArn(attrs.functionArn);\n    const role = attrs.role;\n\n    class Import extends FunctionBase {\n      public readonly functionName = functionName;\n      public readonly functionArn = functionArn;\n      public readonly grantPrincipal: iam.IPrincipal;\n      public readonly role = role;\n      public readonly permissionsNode = this.node;\n      public readonly architecture = attrs.architecture ?? Architecture.X86_64;\n\n      protected readonly canCreatePermissions = attrs.sameEnvironment ?? this._isStackAccount();\n      protected readonly _skipPermissions = attrs.skipPermissions ?? false;\n\n      constructor(s: Construct, i: string) {\n        super(s, i, {\n          environmentFromArn: functionArn,\n        });\n\n        this.grantPrincipal = role || new iam.UnknownPrincipal({ resource: this });\n\n        if (attrs.securityGroup) {\n          this._connections = new ec2.Connections({\n            securityGroups: [attrs.securityGroup],\n          });\n        } else if (attrs.securityGroupId) {\n          this._connections = new ec2.Connections({\n            securityGroups: [ec2.SecurityGroup.fromSecurityGroupId(scope, 'SecurityGroup', attrs.securityGroupId)],\n          });\n        }\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * Return the given named metric for this Lambda\n   */\n  public static metricAll(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/Lambda',\n      metricName,\n      ...props,\n    });\n  }\n  /**\n   * Metric for the number of Errors executing all Lambdas\n   *\n   * @default sum over 5 minutes\n   */\n  public static metricAllErrors(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Errors', { statistic: 'sum', ...props });\n  }\n\n  /**\n   * Metric for the Duration executing all Lambdas\n   *\n   * @default average over 5 minutes\n   */\n  public static metricAllDuration(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Duration', props);\n  }\n\n  /**\n   * Metric for the number of invocations of all Lambdas\n   *\n   * @default sum over 5 minutes\n   */\n  public static metricAllInvocations(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Invocations', { statistic: 'sum', ...props });\n  }\n\n  /**\n   * Metric for the number of throttled invocations of all Lambdas\n   *\n   * @default sum over 5 minutes\n   */\n  public static metricAllThrottles(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('Throttles', { statistic: 'sum', ...props });\n  }\n\n  /**\n   * Metric for the number of concurrent executions across all Lambdas\n   *\n   * @default max over 5 minutes\n   */\n  public static metricAllConcurrentExecutions(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    // Mini-FAQ: why max? This metric is a gauge that is emitted every\n    // minute, so either max or avg or a percentile make sense (but sum\n    // doesn't). Max is more sensitive to spiky load changes which is\n    // probably what you're interested in if you're looking at this metric\n    // (Load spikes may lead to concurrent execution errors that would\n    // otherwise not be visible in the avg)\n    return this.metricAll('ConcurrentExecutions', { statistic: 'max', ...props });\n  }\n\n  /**\n   * Metric for the number of unreserved concurrent executions across all Lambdas\n   *\n   * @default max over 5 minutes\n   */\n  public static metricAllUnreservedConcurrentExecutions(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metricAll('UnreservedConcurrentExecutions', { statistic: 'max', ...props });\n  }\n\n  /**\n   * Name of this function\n   */\n  public readonly functionName: string;\n\n  /**\n   * ARN of this function\n   */\n  public readonly functionArn: string;\n\n  /**\n   * Execution role associated with this function\n   */\n  public readonly role?: iam.IRole;\n\n  /**\n   * The runtime configured for this lambda.\n   */\n  public readonly runtime: Runtime;\n\n  /**\n   * The principal this Lambda Function is running as\n   */\n  public readonly grantPrincipal: iam.IPrincipal;\n\n  /**\n   * The DLQ (as queue) associated with this Lambda Function (this is an optional attribute).\n   */\n  public readonly deadLetterQueue?: sqs.IQueue;\n\n  /**\n   * The DLQ (as topic) associated with this Lambda Function (this is an optional attribute).\n   */\n  public readonly deadLetterTopic?: sns.ITopic;\n\n  /**\n   * The architecture of this Lambda Function (this is an optional attribute and defaults to X86_64).\n   */\n  public readonly architecture: Architecture;\n\n  /**\n   * The timeout configured for this lambda.\n   */\n  public readonly timeout?: Duration;\n\n  public readonly permissionsNode = this.node;\n\n\n  protected readonly canCreatePermissions = true;\n\n  private readonly layers: ILayerVersion[] = [];\n\n  private _logGroup?: logs.ILogGroup;\n\n  /**\n   * Environment variables for this function\n   */\n  private environment: { [key: string]: EnvironmentConfig } = {};\n\n  private readonly currentVersionOptions?: VersionOptions;\n  private _currentVersion?: Version;\n\n  private _architecture?: Architecture;\n\n  constructor(scope: Construct, id: string, props: FunctionProps) {\n    super(scope, id, {\n      physicalName: props.functionName,\n    });\n\n    if (props.functionName && !Token.isUnresolved(props.functionName)) {\n      if (props.functionName.length > 64) {\n        throw new Error(`Function name can not be longer than 64 characters but has ${props.functionName.length} characters.`);\n      }\n      if (!/^[a-zA-Z0-9-_]+$/.test(props.functionName)) {\n        throw new Error(`Function name ${props.functionName} can contain only letters, numbers, hyphens, or underscores with no spaces.`);\n      }\n    }\n\n    const managedPolicies = new Array<iam.IManagedPolicy>();\n\n    // the arn is in the form of - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n    managedPolicies.push(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'));\n\n    if (props.vpc) {\n      // Policy that will have ENI creation permissions\n      managedPolicies.push(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaVPCAccessExecutionRole'));\n    }\n\n    this.role = props.role || new iam.Role(this, 'ServiceRole', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n      managedPolicies,\n    });\n    this.grantPrincipal = this.role;\n\n    // add additional managed policies when necessary\n    if (props.filesystem) {\n      const config = props.filesystem.config;\n      if (config.policies) {\n        config.policies.forEach(p => {\n          this.role?.addToPrincipalPolicy(p);\n        });\n      }\n    }\n\n    for (const statement of (props.initialPolicy || [])) {\n      this.role.addToPrincipalPolicy(statement);\n    }\n\n    const code = props.code.bind(this);\n    verifyCodeConfig(code, props);\n\n    let profilingGroupEnvironmentVariables: { [key: string]: string } = {};\n    if (props.profilingGroup && props.profiling !== false) {\n      this.validateProfiling(props);\n      props.profilingGroup.grantPublish(this.role);\n      profilingGroupEnvironmentVariables = {\n        AWS_CODEGURU_PROFILER_GROUP_ARN: Stack.of(scope).formatArn({\n          service: 'codeguru-profiler',\n          resource: 'profilingGroup',\n          resourceName: props.profilingGroup.profilingGroupName,\n        }),\n        AWS_CODEGURU_PROFILER_ENABLED: 'TRUE',\n      };\n    } else if (props.profiling) {\n      this.validateProfiling(props);\n      const profilingGroup = new ProfilingGroup(this, 'ProfilingGroup', {\n        computePlatform: ComputePlatform.AWS_LAMBDA,\n      });\n      profilingGroup.grantPublish(this.role);\n      profilingGroupEnvironmentVariables = {\n        AWS_CODEGURU_PROFILER_GROUP_ARN: profilingGroup.profilingGroupArn,\n        AWS_CODEGURU_PROFILER_ENABLED: 'TRUE',\n      };\n    }\n\n    const env = { ...profilingGroupEnvironmentVariables, ...props.environment };\n    for (const [key, value] of Object.entries(env)) {\n      this.addEnvironment(key, value);\n    }\n\n    // DLQ can be either sns.ITopic or sqs.IQueue\n    const dlqTopicOrQueue = this.buildDeadLetterQueue(props);\n    if (dlqTopicOrQueue !== undefined) {\n      if (this.isQueue(dlqTopicOrQueue)) {\n        this.deadLetterQueue = dlqTopicOrQueue;\n      } else {\n        this.deadLetterTopic = dlqTopicOrQueue;\n      }\n    }\n\n    let fileSystemConfigs: CfnFunction.FileSystemConfigProperty[] | undefined = undefined;\n    if (props.filesystem) {\n      fileSystemConfigs = [{\n        arn: props.filesystem.config.arn,\n        localMountPath: props.filesystem.config.localMountPath,\n      }];\n    }\n\n    if (props.architecture && props.architectures !== undefined) {\n      throw new Error('Either architecture or architectures must be specified but not both.');\n    }\n    if (props.architectures && props.architectures.length > 1) {\n      throw new Error('Only one architecture must be specified.');\n    }\n    this._architecture = props.architecture ?? (props.architectures && props.architectures[0]);\n\n    const resource: CfnFunction = new CfnFunction(this, 'Resource', {\n      functionName: this.physicalName,\n      description: props.description,\n      code: {\n        s3Bucket: code.s3Location && code.s3Location.bucketName,\n        s3Key: code.s3Location && code.s3Location.objectKey,\n        s3ObjectVersion: code.s3Location && code.s3Location.objectVersion,\n        zipFile: code.inlineCode,\n        imageUri: code.image?.imageUri,\n      },\n      layers: Lazy.list({ produce: () => this.layers.map(layer => layer.layerVersionArn) }, { omitEmpty: true }), // Evaluated on synthesis\n      handler: props.handler === Handler.FROM_IMAGE ? undefined : props.handler,\n      timeout: props.timeout && props.timeout.toSeconds(),\n      packageType: props.runtime === Runtime.FROM_IMAGE ? 'Image' : undefined,\n      runtime: props.runtime === Runtime.FROM_IMAGE ? undefined : props.runtime.name,\n      role: this.role.roleArn,\n      // Uncached because calling '_checkEdgeCompatibility', which gets called in the resolve of another\n      // Token, actually *modifies* the 'environment' map.\n      environment: Lazy.uncachedAny({ produce: () => this.renderEnvironment() }),\n      memorySize: props.memorySize,\n      vpcConfig: this.configureVpc(props),\n      deadLetterConfig: this.buildDeadLetterConfig(dlqTopicOrQueue),\n      tracingConfig: this.buildTracingConfig(props),\n      reservedConcurrentExecutions: props.reservedConcurrentExecutions,\n      imageConfig: undefinedIfNoKeys({\n        command: code.image?.cmd,\n        entryPoint: code.image?.entrypoint,\n        workingDirectory: code.image?.workingDirectory,\n      }),\n      kmsKeyArn: props.environmentEncryption?.keyArn,\n      fileSystemConfigs,\n      codeSigningConfigArn: props.codeSigningConfig?.codeSigningConfigArn,\n      architectures: this._architecture ? [this._architecture.name] : undefined,\n    });\n\n    resource.node.addDependency(this.role);\n\n    this.functionName = this.getResourceNameAttribute(resource.ref);\n    this.functionArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'lambda',\n      resource: 'function',\n      resourceName: this.physicalName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n\n    this.runtime = props.runtime;\n    this.timeout = props.timeout;\n\n    this.architecture = props.architecture ?? Architecture.X86_64;\n\n    if (props.layers) {\n      if (props.runtime === Runtime.FROM_IMAGE) {\n        throw new Error('Layers are not supported for container image functions');\n      }\n\n      this.addLayers(...props.layers);\n    }\n\n    for (const event of props.events || []) {\n      this.addEventSource(event);\n    }\n\n    // Log retention\n    if (props.logRetention) {\n      const logRetention = new logs.LogRetention(this, 'LogRetention', {\n        logGroupName: `/aws/lambda/${this.functionName}`,\n        retention: props.logRetention,\n        role: props.logRetentionRole,\n        logRetentionRetryOptions: props.logRetentionRetryOptions as logs.LogRetentionRetryOptions,\n      });\n      this._logGroup = logs.LogGroup.fromLogGroupArn(this, 'LogGroup', logRetention.logGroupArn);\n    }\n\n    props.code.bindToResource(resource);\n\n    // Event Invoke Config\n    if (props.onFailure || props.onSuccess || props.maxEventAge || props.retryAttempts !== undefined) {\n      this.configureAsyncInvoke({\n        onFailure: props.onFailure,\n        onSuccess: props.onSuccess,\n        maxEventAge: props.maxEventAge,\n        retryAttempts: props.retryAttempts,\n      });\n    }\n\n    this.currentVersionOptions = props.currentVersionOptions;\n\n    if (props.filesystem) {\n      if (!props.vpc) {\n        throw new Error('Cannot configure \\'filesystem\\' without configuring a VPC.');\n      }\n      const config = props.filesystem.config;\n      if (config.dependency) {\n        this.node.addDependency(...config.dependency);\n      }\n      // There could be a race if the Lambda is used in a CustomResource. It is possible for the Lambda to\n      // fail to attach to a given FileSystem if we do not have a dependency on the SecurityGroup ingress/egress\n      // rules that were created between this Lambda's SG & the Filesystem SG.\n      this.connections.securityGroups.forEach(sg => {\n        sg.node.findAll().forEach(child => {\n          if (child instanceof CfnResource && child.cfnResourceType === 'AWS::EC2::SecurityGroupEgress') {\n            resource.node.addDependency(child);\n          }\n        });\n      });\n      config.connections?.securityGroups.forEach(sg => {\n        sg.node.findAll().forEach(child => {\n          if (child instanceof CfnResource && child.cfnResourceType === 'AWS::EC2::SecurityGroupIngress') {\n            resource.node.addDependency(child);\n          }\n        });\n      });\n    }\n\n    // Configure Lambda insights\n    this.configureLambdaInsights(props);\n  }\n\n  /**\n   * Adds an environment variable to this Lambda function.\n   * If this is a ref to a Lambda function, this operation results in a no-op.\n   * @param key The environment variable key.\n   * @param value The environment variable's value.\n   * @param options Environment variable options.\n   */\n  public addEnvironment(key: string, value: string, options?: EnvironmentOptions): this {\n    this.environment[key] = { value, ...options };\n    return this;\n  }\n\n  /**\n   * Adds one or more Lambda Layers to this Lambda function.\n   *\n   * @param layers the layers to be added.\n   *\n   * @throws if there are already 5 layers on this function, or the layer is incompatible with this function's runtime.\n   */\n  public addLayers(...layers: ILayerVersion[]): void {\n    for (const layer of layers) {\n      if (this.layers.length === 5) {\n        throw new Error('Unable to add layer: this lambda function already uses 5 layers.');\n      }\n      if (layer.compatibleRuntimes && !layer.compatibleRuntimes.find(runtime => runtime.runtimeEquals(this.runtime))) {\n        const runtimes = layer.compatibleRuntimes.map(runtime => runtime.name).join(', ');\n        throw new Error(`This lambda function uses a runtime that is incompatible with this layer (${this.runtime.name} is not in [${runtimes}])`);\n      }\n\n      // Currently no validations for compatible architectures since Lambda service\n      // allows layers configured with one architecture to be used with a Lambda function\n      // from another architecture.\n\n      this.layers.push(layer);\n    }\n  }\n\n  /**\n   * Add a new version for this Lambda\n   *\n   * If you want to deploy through CloudFormation and use aliases, you need to\n   * add a new version (with a new name) to your Lambda every time you want to\n   * deploy an update. An alias can then refer to the newly created Version.\n   *\n   * All versions should have distinct names, and you should not delete versions\n   * as long as your Alias needs to refer to them.\n   *\n   * @param name A unique name for this version.\n   * @param codeSha256 The SHA-256 hash of the most recently deployed Lambda\n   *  source code, or omit to skip validation.\n   * @param description A description for this version.\n   * @param provisionedExecutions A provisioned concurrency configuration for a\n   * function's version.\n   * @param asyncInvokeConfig configuration for this version when it is invoked\n   * asynchronously.\n   * @returns A new Version object.\n   *\n   * @deprecated This method will create an AWS::Lambda::Version resource which\n   * snapshots the AWS Lambda function *at the time of its creation* and it\n   * won't get updated when the function changes. Instead, use\n   * `this.currentVersion` to obtain a reference to a version resource that gets\n   * automatically recreated when the function configuration (or code) changes.\n   */\n  public addVersion(\n    name: string,\n    codeSha256?: string,\n    description?: string,\n    provisionedExecutions?: number,\n    asyncInvokeConfig: EventInvokeConfigOptions = {}): Version {\n\n    return new Version(this, 'Version' + name, {\n      lambda: this,\n      codeSha256,\n      description,\n      provisionedConcurrentExecutions: provisionedExecutions,\n      ...asyncInvokeConfig,\n    });\n  }\n\n  /**\n   * The LogGroup where the Lambda function's logs are made available.\n   *\n   * If either `logRetention` is set or this property is called, a CloudFormation custom resource is added to the stack that\n   * pre-creates the log group as part of the stack deployment, if it already doesn't exist, and sets the correct log retention\n   * period (never expire, by default).\n   *\n   * Further, if the log group already exists and the `logRetention` is not set, the custom resource will reset the log retention\n   * to never expire even if it was configured with a different value.\n   */\n  public get logGroup(): logs.ILogGroup {\n    if (!this._logGroup) {\n      const logRetention = new logs.LogRetention(this, 'LogRetention', {\n        logGroupName: `/aws/lambda/${this.functionName}`,\n        retention: logs.RetentionDays.INFINITE,\n      });\n      this._logGroup = logs.LogGroup.fromLogGroupArn(this, `${this.node.id}-LogGroup`, logRetention.logGroupArn);\n    }\n    return this._logGroup;\n  }\n\n  /** @internal */\n  public _checkEdgeCompatibility(): void {\n    // Check env vars\n    const envEntries = Object.entries(this.environment);\n    for (const [key, config] of envEntries) {\n      if (config.removeInEdge) {\n        delete this.environment[key];\n        Annotations.of(this).addInfo(`Removed ${key} environment variable for Lambda@Edge compatibility`);\n      }\n    }\n    const envKeys = Object.keys(this.environment);\n    if (envKeys.length !== 0) {\n      throw new Error(`The function ${this.node.path} contains environment variables [${envKeys}] and is not compatible with Lambda@Edge. \\\nEnvironment variables can be marked for removal when used in Lambda@Edge by setting the \\'removeInEdge\\' property in the \\'addEnvironment()\\' API.`);\n    }\n\n    return;\n  }\n\n  /**\n   * Configured lambda insights on the function if specified. This is acheived by adding an imported layer which is added to the\n   * list of lambda layers on synthesis.\n   *\n   * https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versions.html\n   */\n  private configureLambdaInsights(props: FunctionProps): void {\n    if (props.insightsVersion === undefined) {\n      return;\n    }\n    if (props.runtime !== Runtime.FROM_IMAGE) {\n      // Layers cannot be added to Lambda container images. The image should have the insights agent installed.\n      // See https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-docker.html\n      this.addLayers(LayerVersion.fromLayerVersionArn(this, 'LambdaInsightsLayer', props.insightsVersion._bind(this, this).arn));\n    }\n    this.role?.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('CloudWatchLambdaInsightsExecutionRolePolicy'));\n  }\n\n  private renderEnvironment() {\n    if (!this.environment || Object.keys(this.environment).length === 0) {\n      return undefined;\n    }\n\n    const variables: { [key: string]: string } = {};\n    // Sort environment so the hash of the function used to create\n    // `currentVersion` is not affected by key order (this is how lambda does\n    // it). For backwards compatibility we do not sort environment variables in case\n    // _currentVersion is not defined. Otherwise, this would have invalidated\n    // the template, and for example, may cause unneeded updates for nested\n    // stacks.\n    const keys = this._currentVersion\n      ? Object.keys(this.environment).sort()\n      : Object.keys(this.environment);\n\n    for (const key of keys) {\n      variables[key] = this.environment[key].value;\n    }\n\n    return { variables };\n  }\n\n  /**\n   * If configured, set up the VPC-related properties\n   *\n   * Returns the VpcConfig that should be added to the\n   * Lambda creation properties.\n   */\n  private configureVpc(props: FunctionProps): CfnFunction.VpcConfigProperty | undefined {\n    if ((props.securityGroup || props.allowAllOutbound !== undefined) && !props.vpc) {\n      throw new Error('Cannot configure \\'securityGroup\\' or \\'allowAllOutbound\\' without configuring a VPC');\n    }\n\n    if (!props.vpc) { return undefined; }\n\n    if (props.securityGroup && props.allowAllOutbound !== undefined) {\n      throw new Error('Configure \\'allowAllOutbound\\' directly on the supplied SecurityGroup.');\n    }\n\n    let securityGroups: ec2.ISecurityGroup[];\n\n    if (props.securityGroup && props.securityGroups) {\n      throw new Error('Only one of the function props, securityGroup or securityGroups, is allowed');\n    }\n\n    if (props.securityGroups) {\n      securityGroups = props.securityGroups;\n    } else {\n      const securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'SecurityGroup', {\n        vpc: props.vpc,\n        description: 'Automatic security group for Lambda Function ' + Names.uniqueId(this),\n        allowAllOutbound: props.allowAllOutbound,\n      });\n      securityGroups = [securityGroup];\n    }\n\n    this._connections = new ec2.Connections({ securityGroups });\n\n    if (props.filesystem) {\n      if (props.filesystem.config.connections) {\n        props.filesystem.config.connections.allowDefaultPortFrom(this);\n      }\n    }\n\n    const allowPublicSubnet = props.allowPublicSubnet ?? false;\n    const { subnetIds } = props.vpc.selectSubnets(props.vpcSubnets);\n    const publicSubnetIds = new Set(props.vpc.publicSubnets.map(s => s.subnetId));\n    for (const subnetId of subnetIds) {\n      if (publicSubnetIds.has(subnetId) && !allowPublicSubnet) {\n        throw new Error('Lambda Functions in a public subnet can NOT access the internet. ' +\n          'If you are aware of this limitation and would still like to place the function int a public subnet, set `allowPublicSubnet` to true');\n      }\n    }\n\n    // List can't be empty here, if we got this far you intended to put your Lambda\n    // in subnets. We're going to guarantee that we get the nice error message by\n    // making VpcNetwork do the selection again.\n\n    return {\n      subnetIds,\n      securityGroupIds: securityGroups.map(sg => sg.securityGroupId),\n    };\n  }\n\n  private isQueue(deadLetterQueue: sqs.IQueue | sns.ITopic): deadLetterQueue is sqs.IQueue {\n    return (<sqs.IQueue>deadLetterQueue).queueArn !== undefined;\n  }\n\n  private buildDeadLetterQueue(props: FunctionProps): sqs.IQueue | sns.ITopic | undefined {\n    if (!props.deadLetterQueue && !props.deadLetterQueueEnabled && !props.deadLetterTopic) {\n      return undefined;\n    }\n    if (props.deadLetterQueue && props.deadLetterQueueEnabled === false) {\n      throw Error('deadLetterQueue defined but deadLetterQueueEnabled explicitly set to false');\n    }\n    if (props.deadLetterTopic && (props.deadLetterQueue || props.deadLetterQueueEnabled !== undefined)) {\n      throw new Error('deadLetterQueue and deadLetterTopic cannot be specified together at the same time');\n    }\n\n    let deadLetterQueue: sqs.IQueue | sns.ITopic;\n    if (props.deadLetterTopic) {\n      deadLetterQueue = props.deadLetterTopic;\n      this.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['sns:Publish'],\n        resources: [deadLetterQueue.topicArn],\n      }));\n    } else {\n      deadLetterQueue = props.deadLetterQueue || new sqs.Queue(this, 'DeadLetterQueue', {\n        retentionPeriod: Duration.days(14),\n      });\n      this.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['sqs:SendMessage'],\n        resources: [deadLetterQueue.queueArn],\n      }));\n    }\n\n    return deadLetterQueue;\n  }\n\n  private buildDeadLetterConfig(deadLetterQueue?: sqs.IQueue | sns.ITopic) {\n    if (deadLetterQueue) {\n      return {\n        targetArn: this.isQueue(deadLetterQueue) ? deadLetterQueue.queueArn : deadLetterQueue.topicArn,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  private buildTracingConfig(props: FunctionProps) {\n    if (props.tracing === undefined || props.tracing === Tracing.DISABLED) {\n      return undefined;\n    }\n\n    this.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['xray:PutTraceSegments', 'xray:PutTelemetryRecords'],\n      resources: ['*'],\n    }));\n\n    return {\n      mode: props.tracing,\n    };\n  }\n\n  private validateProfiling(props: FunctionProps) {\n    if (!props.runtime.supportsCodeGuruProfiling) {\n      throw new Error(`CodeGuru profiling is not supported by runtime ${props.runtime.name}`);\n    }\n    if (props.environment && (props.environment.AWS_CODEGURU_PROFILER_GROUP_ARN || props.environment.AWS_CODEGURU_PROFILER_ENABLED)) {\n      throw new Error('AWS_CODEGURU_PROFILER_GROUP_ARN and AWS_CODEGURU_PROFILER_ENABLED must not be set when profiling options enabled');\n    }\n  }\n}\n\n/**\n * Environment variables options\n */\nexport interface EnvironmentOptions {\n  /**\n   * When used in Lambda@Edge via edgeArn() API, these environment\n   * variables will be removed. If not set, an error will be thrown.\n   * @see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-requirements-limits.html#lambda-requirements-lambda-function-configuration\n   *\n   * @default false - using the function in Lambda@Edge will throw\n   */\n  readonly removeInEdge?: boolean\n}\n\n/**\n * Configuration for an environment variable\n */\ninterface EnvironmentConfig extends EnvironmentOptions {\n  readonly value: string;\n}\n\n/**\n * Given an opaque (token) ARN, returns a CloudFormation expression that extracts the function\n * name from the ARN.\n *\n * Function ARNs look like this:\n *\n *   arn:aws:lambda:region:account-id:function:function-name\n *\n * ..which means that in order to extract the `function-name` component from the ARN, we can\n * split the ARN using \":\" and select the component in index 6.\n *\n * @returns `FnSelect(6, FnSplit(':', arn))`\n */\nfunction extractNameFromArn(arn: string) {\n  return Fn.select(6, Fn.split(':', arn));\n}\n\nexport function verifyCodeConfig(code: CodeConfig, props: FunctionProps) {\n  // mutually exclusive\n  const codeType = [code.inlineCode, code.s3Location, code.image];\n\n  if (codeType.filter(x => !!x).length !== 1) {\n    throw new Error('lambda.Code must specify exactly one of: \"inlineCode\", \"s3Location\", or \"image\"');\n  }\n\n  if (!!code.image === (props.handler !== Handler.FROM_IMAGE)) {\n    throw new Error('handler must be `Handler.FROM_IMAGE` when using image asset for Lambda function');\n  }\n\n  if (!!code.image === (props.runtime !== Runtime.FROM_IMAGE)) {\n    throw new Error('runtime must be `Runtime.FROM_IMAGE` when using image asset for Lambda function');\n  }\n\n  // if this is inline code, check that the runtime supports\n  if (code.inlineCode && !props.runtime.supportsInlineCode) {\n    throw new Error(`Inline source not allowed for ${props.runtime!.name}`);\n  }\n}\n\nfunction undefinedIfNoKeys<A>(struct: A): A | undefined {\n  const allUndefined = Object.values(struct).every(val => val === undefined);\n  return allUndefined ? undefined : struct;\n}\n"],
  "mappings": "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",
  "names": []
}
