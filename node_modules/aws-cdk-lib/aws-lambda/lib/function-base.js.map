{
  "version": 3,
  "sources": ["function-base.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport { ArnFormat, IResource, Resource, Token } from '../../core';\nimport { Node } from 'constructs';\nimport { AliasOptions } from './alias';\nimport { Architecture } from './architecture';\nimport { EventInvokeConfig, EventInvokeConfigOptions } from './event-invoke-config';\nimport { IEventSource } from './event-source';\nimport { EventSourceMapping, EventSourceMappingOptions } from './event-source-mapping';\nimport { IVersion } from './lambda-version';\nimport { CfnPermission } from './lambda.generated';\nimport { Permission } from './permission';\nimport { addAlias, flatMap } from './util';\n\nexport interface IFunction extends IResource, ec2.IConnectable, iam.IGrantable {\n\n  /**\n   * The name of the function.\n   *\n   * @attribute\n   */\n  readonly functionName: string;\n\n  /**\n   * The ARN of the function.\n   *\n   * @attribute\n   */\n  readonly functionArn: string;\n\n  /**\n   * The IAM role associated with this function.\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Whether or not this Lambda function was bound to a VPC\n   *\n   * If this is is `false`, trying to access the `connections` object will fail.\n   */\n  readonly isBoundToVpc: boolean;\n\n  /**\n   * The `$LATEST` version of this function.\n   *\n   * Note that this is reference to a non-specific AWS Lambda version, which\n   * means the function this version refers to can return different results in\n   * different invocations.\n   *\n   * To obtain a reference to an explicit version which references the current\n   * function configuration, use `lambdaFunction.currentVersion` instead.\n   */\n  readonly latestVersion: IVersion;\n\n  /**\n   * The construct node where permissions are attached.\n   */\n  readonly permissionsNode: Node;\n\n  /**\n   * The system architectures compatible with this lambda function.\n   */\n  readonly architecture: Architecture;\n\n  /**\n   * Adds an event source that maps to this AWS Lambda function.\n   * @param id construct ID\n   * @param options mapping options\n   */\n  addEventSourceMapping(id: string, options: EventSourceMappingOptions): EventSourceMapping;\n\n  /**\n   * Adds a permission to the Lambda resource policy.\n   * @param id The id for the permission construct\n   * @param permission The permission to grant to this Lambda function. @see Permission for details.\n   */\n  addPermission(id: string, permission: Permission): void;\n\n  /**\n   * Adds a statement to the IAM role assumed by the instance.\n   */\n  addToRolePolicy(statement: iam.PolicyStatement): void;\n\n  /**\n   * Grant the given identity permissions to invoke this Lambda\n   */\n  grantInvoke(identity: iam.IGrantable): iam.Grant;\n\n  /**\n   * Return the given named metric for this Lambda\n   */\n  metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * Metric for the Duration of this Lambda\n   *\n   * @default average over 5 minutes\n   */\n  metricDuration(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * Metric for the number of invocations of this Lambda\n   *\n   * @default sum over 5 minutes\n   */\n  metricInvocations(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * Metric for the number of throttled invocations of this Lambda\n   *\n   * @default sum over 5 minutes\n   */\n  metricThrottles(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n  /**\n   * Adds an event source to this function.\n   *\n   * Event sources are implemented in the @aws-cdk/aws-lambda-event-sources module.\n   *\n   * The following example adds an SQS Queue as an event source:\n   * ```\n   * import { SqsEventSource } from '@aws-cdk/aws-lambda-event-sources';\n   * myFunction.addEventSource(new SqsEventSource(myQueue));\n   * ```\n   */\n  addEventSource(source: IEventSource): void;\n\n  /**\n   * Configures options for asynchronous invocation.\n   */\n  configureAsyncInvoke(options: EventInvokeConfigOptions): void;\n}\n\n/**\n * Represents a Lambda function defined outside of this stack.\n */\nexport interface FunctionAttributes {\n  /**\n   * The ARN of the Lambda function.\n   *\n   * Format: arn:<partition>:lambda:<region>:<account-id>:function:<function-name>\n   */\n  readonly functionArn: string;\n\n  /**\n   * The IAM execution role associated with this function.\n   *\n   * If the role is not specified, any role-related operations will no-op.\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Id of the security group of this Lambda, if in a VPC.\n   *\n   * This needs to be given in order to support allowing connections\n   * to this Lambda.\n   *\n   * @deprecated use `securityGroup` instead\n   */\n  readonly securityGroupId?: string;\n\n  /**\n   * The security group of this Lambda, if in a VPC.\n   *\n   * This needs to be given in order to support allowing connections\n   * to this Lambda.\n   */\n  readonly securityGroup?: ec2.ISecurityGroup;\n\n  /**\n   * Setting this property informs the CDK that the imported function is in the same environment as the stack.\n   * This affects certain behaviours such as, whether this function's permission can be modified.\n   * When not configured, the CDK attempts to auto-determine this. For environment agnostic stacks, i.e., stacks\n   * where the account is not specified with the `env` property, this is determined to be false.\n   *\n   * Set this to property *ONLY IF* the imported function is in the same account as the stack\n   * it's imported in.\n   * @default - depends: true, if the Stack is configured with an explicit `env` (account and region) and the account is the same as this function.\n   * For environment-agnostic stacks this will default to `false`.\n   */\n  readonly sameEnvironment?: boolean;\n\n  /**\n   * Setting this property informs the CDK that the imported function ALREADY HAS the necessary permissions\n   * for what you are trying to do. When not configured, the CDK attempts to auto-determine whether or not\n   * additional permissions are necessary on the function when grant APIs are used. If the CDK tried to add\n   * permissions on an imported lambda, it will fail.\n   *\n   * Set this property *ONLY IF* you are committing to manage the imported function's permissions outside of\n   * CDK. You are acknowledging that your CDK code alone will have insufficient permissions to access the\n   * imported function.\n   *\n   * @default false\n   */\n  readonly skipPermissions?: boolean;\n\n  /**\n   * The architecture of this Lambda Function (this is an optional attribute and defaults to X86_64).\n   * @default - Architecture.X86_64\n   */\n  readonly architecture?: Architecture;\n}\n\nexport abstract class FunctionBase extends Resource implements IFunction, ec2.IClientVpnConnectionHandler {\n  /**\n   * The principal this Lambda Function is running as\n   */\n  public abstract readonly grantPrincipal: iam.IPrincipal;\n\n  /**\n   * The name of the function.\n   */\n  public abstract readonly functionName: string;\n\n  /**\n   * The ARN fo the function.\n   */\n  public abstract readonly functionArn: string;\n\n  /**\n   * The IAM role associated with this function.\n   *\n   * Undefined if the function was imported without a role.\n   */\n  public abstract readonly role?: iam.IRole;\n\n  /**\n   * The construct node where permissions are attached.\n   */\n  public abstract readonly permissionsNode: Node;\n\n  /**\n   * The architecture of this Lambda Function.\n   */\n  public abstract readonly architecture: Architecture;\n\n  /**\n   * Whether the addPermission() call adds any permissions\n   *\n   * True for new Lambdas, false for version $LATEST and imported Lambdas\n   * from different accounts.\n   */\n  protected abstract readonly canCreatePermissions: boolean;\n\n  /**\n   * Whether the user decides to skip adding permissions.\n   * The only use case is for cross-account, imported lambdas\n   * where the user commits to modifying the permisssions\n   * on the imported lambda outside CDK.\n   * @internal\n   */\n  protected readonly _skipPermissions?: boolean;\n\n  /**\n   * Actual connections object for this Lambda\n   *\n   * May be unset, in which case this Lambda is not configured use in a VPC.\n   * @internal\n   */\n  protected _connections?: ec2.Connections;\n\n  private _latestVersion?: LatestVersion;\n\n  /**\n   * Mapping of invocation principals to grants. Used to de-dupe `grantInvoke()` calls.\n   * @internal\n   */\n  protected _invocationGrants: Record<string, iam.Grant> = {};\n\n  /**\n   * Adds a permission to the Lambda resource policy.\n   * @param id The id for the permission construct\n   * @param permission The permission to grant to this Lambda function. @see Permission for details.\n   */\n  public addPermission(id: string, permission: Permission) {\n    if (!this.canCreatePermissions) {\n      // FIXME: @deprecated(v2) - throw an error if calling `addPermission` on a resource that doesn't support it.\n      return;\n    }\n\n    const principal = this.parsePermissionPrincipal(permission.principal);\n    const { sourceAccount, sourceArn } = this.parseConditions(permission.principal) ?? {};\n    const action = permission.action ?? 'lambda:InvokeFunction';\n    const scope = permission.scope ?? this;\n\n    new CfnPermission(scope, id, {\n      action,\n      principal,\n      functionName: this.functionArn,\n      eventSourceToken: permission.eventSourceToken,\n      sourceAccount: permission.sourceAccount ?? sourceAccount,\n      sourceArn: permission.sourceArn ?? sourceArn,\n    });\n  }\n\n  /**\n   * Adds a statement to the IAM role assumed by the instance.\n   */\n  public addToRolePolicy(statement: iam.PolicyStatement) {\n    if (!this.role) {\n      return;\n    }\n\n    this.role.addToPrincipalPolicy(statement);\n  }\n\n  /**\n   * Access the Connections object\n   *\n   * Will fail if not a VPC-enabled Lambda Function\n   */\n  public get connections(): ec2.Connections {\n    if (!this._connections) {\n      // eslint-disable-next-line max-len\n      throw new Error('Only VPC-associated Lambda Functions have security groups to manage. Supply the \"vpc\" parameter when creating the Lambda, or \"securityGroupId\" when importing it.');\n    }\n    return this._connections;\n  }\n\n  public get latestVersion(): IVersion {\n    if (!this._latestVersion) {\n      this._latestVersion = new LatestVersion(this);\n    }\n    return this._latestVersion;\n  }\n\n  /**\n   * Whether or not this Lambda function was bound to a VPC\n   *\n   * If this is is `false`, trying to access the `connections` object will fail.\n   */\n  public get isBoundToVpc(): boolean {\n    return !!this._connections;\n  }\n\n  public addEventSourceMapping(id: string, options: EventSourceMappingOptions): EventSourceMapping {\n    return new EventSourceMapping(this, id, {\n      target: this,\n      ...options,\n    });\n  }\n\n  /**\n   * Grant the given identity permissions to invoke this Lambda\n   */\n  public grantInvoke(grantee: iam.IGrantable): iam.Grant {\n    const identifier = `Invoke${grantee.grantPrincipal}`; // calls the .toString() of the principal\n\n    // Memoize the result so subsequent grantInvoke() calls are idempotent\n    let grant = this._invocationGrants[identifier];\n    if (!grant) {\n      grant = iam.Grant.addToPrincipalOrResource({\n        grantee,\n        actions: ['lambda:InvokeFunction'],\n        resourceArns: [this.functionArn],\n\n        // Fake resource-like object on which to call addToResourcePolicy(), which actually\n        // calls addPermission()\n        resource: {\n          addToResourcePolicy: (_statement) => {\n            // Couldn't add permissions to the principal, so add them locally.\n            this.addPermission(identifier, {\n              principal: grantee.grantPrincipal!,\n              action: 'lambda:InvokeFunction',\n            });\n\n            const permissionNode = this._functionNode().tryFindChild(identifier);\n            if (!permissionNode && !this._skipPermissions) {\n              throw new Error('Cannot modify permission to lambda function. Function is either imported or $LATEST version.\\n'\n                + 'If the function is imported from the same account use `fromFunctionAttributes()` API with the `sameEnvironment` flag.\\n'\n                + 'If the function is imported from a different account and already has the correct permissions use `fromFunctionAttributes()` API with the `skipPermissions` flag.');\n            }\n            return { statementAdded: true, policyDependable: permissionNode };\n          },\n          node: this.node,\n          stack: this.stack,\n          env: this.env,\n          applyRemovalPolicy: this.applyRemovalPolicy,\n        },\n      });\n      this._invocationGrants[identifier] = grant;\n    }\n    return grant;\n  }\n\n  public addEventSource(source: IEventSource) {\n    source.bind(this);\n  }\n\n  public configureAsyncInvoke(options: EventInvokeConfigOptions): void {\n    if (this.node.tryFindChild('EventInvokeConfig') !== undefined) {\n      throw new Error(`An EventInvokeConfig has already been configured for the function at ${this.node.path}`);\n    }\n\n    new EventInvokeConfig(this, 'EventInvokeConfig', {\n      function: this,\n      ...options,\n    });\n  }\n\n  /**\n   * Returns the construct tree node that corresponds to the lambda function.\n   * For use internally for constructs, when the tree is set up in non-standard ways. Ex: SingletonFunction.\n   * @internal\n   */\n  protected _functionNode(): Node {\n    return this.node;\n  }\n\n  /**\n   * Given the function arn, check if the account id matches this account\n   *\n   * Function ARNs look like this:\n   *\n   *   arn:aws:lambda:region:account-id:function:function-name\n   *\n   * ..which means that in order to extract the `account-id` component from the ARN, we can\n   * split the ARN using \":\" and select the component in index 4.\n   *\n   * @returns true if account id of function matches the account specified on the stack, false otherwise.\n   *\n   * @internal\n   */\n  protected _isStackAccount(): boolean {\n    if (Token.isUnresolved(this.stack.account) || Token.isUnresolved(this.functionArn)) {\n      return false;\n    }\n    return this.stack.splitArn(this.functionArn, ArnFormat.SLASH_RESOURCE_NAME).account === this.stack.account;\n  }\n\n  /**\n   * Translate IPrincipal to something we can pass to AWS::Lambda::Permissions\n   *\n   * Do some nasty things because `Permission` supports a subset of what the\n   * full IAM principal language supports, and we may not be able to parse strings\n   * outright because they may be tokens.\n   *\n   * Try to recognize some specific Principal classes first, then try a generic\n   * fallback.\n   */\n  private parsePermissionPrincipal(principal: iam.IPrincipal) {\n    // Try some specific common classes first.\n    // use duck-typing, not instance of\n    // @deprecated: after v2, we can change these to 'instanceof'\n    if ('wrapped' in principal) {\n      // eslint-disable-next-line dot-notation\n      principal = principal['wrapped'];\n    }\n\n    if ('accountId' in principal) {\n      return (principal as iam.AccountPrincipal).accountId;\n    }\n\n    if ('service' in principal) {\n      return (principal as iam.ServicePrincipal).service;\n    }\n\n    if ('arn' in principal) {\n      return (principal as iam.ArnPrincipal).arn;\n    }\n\n    // Try a best-effort approach to support simple principals that are not any of the predefined\n    // classes, but are simple enough that they will fit into the Permission model. Main target\n    // here: imported Roles, Users, Groups.\n    //\n    // The principal cannot have conditions and must have a single { AWS: [arn] } entry.\n    const json = principal.policyFragment.principalJson;\n    if (Object.keys(principal.policyFragment.conditions).length === 0 && json.AWS) {\n      if (typeof json.AWS === 'string') { return json.AWS; }\n      if (Array.isArray(json.AWS) && json.AWS.length === 1 && typeof json.AWS[0] === 'string') {\n        return json.AWS[0];\n      }\n    }\n\n    throw new Error(`Invalid principal type for Lambda permission statement: ${principal.constructor.name}. ` +\n      'Supported: AccountPrincipal, ArnPrincipal, ServicePrincipal');\n  }\n\n  private parseConditions(principal: iam.IPrincipal): { sourceAccount: string, sourceArn: string } | null {\n    if (this.isPrincipalWithConditions(principal)) {\n      const conditions: iam.Conditions = principal.policyFragment.conditions;\n      const conditionPairs = flatMap(\n        Object.entries(conditions),\n        ([operator, conditionObjs]) => Object.keys(conditionObjs as object).map(key => { return { operator, key }; }),\n      );\n      const supportedPrincipalConditions = [{ operator: 'ArnLike', key: 'aws:SourceArn' }, { operator: 'StringEquals', key: 'aws:SourceAccount' }];\n\n      const unsupportedConditions = conditionPairs.filter(\n        (condition) => !supportedPrincipalConditions.some(\n          (supportedCondition) => supportedCondition.operator === condition.operator && supportedCondition.key === condition.key,\n        ),\n      );\n\n      if (unsupportedConditions.length == 0) {\n        return {\n          sourceAccount: conditions.StringEquals['aws:SourceAccount'],\n          sourceArn: conditions.ArnLike['aws:SourceArn'],\n        };\n      } else {\n        throw new Error(`PrincipalWithConditions had unsupported conditions for Lambda permission statement: ${JSON.stringify(unsupportedConditions)}. ` +\n          `Supported operator/condition pairs: ${JSON.stringify(supportedPrincipalConditions)}`);\n      }\n    } else {\n      return null;\n    }\n  }\n\n  private isPrincipalWithConditions(principal: iam.IPrincipal): principal is iam.PrincipalWithConditions {\n    return 'conditions' in principal;\n  }\n}\n\nexport abstract class QualifiedFunctionBase extends FunctionBase {\n  public abstract readonly lambda: IFunction;\n\n  public readonly permissionsNode = this.node;\n\n  /**\n   * The qualifier of the version or alias of this function.\n   * A qualifier is the identifier that's appended to a version or alias ARN.\n   * @see https://docs.aws.amazon.com/lambda/latest/dg/API_GetFunctionConfiguration.html#API_GetFunctionConfiguration_RequestParameters\n   */\n  protected abstract readonly qualifier: string;\n\n  public get latestVersion() {\n    return this.lambda.latestVersion;\n  }\n\n  public configureAsyncInvoke(options: EventInvokeConfigOptions): void {\n    if (this.node.tryFindChild('EventInvokeConfig') !== undefined) {\n      throw new Error(`An EventInvokeConfig has already been configured for the qualified function at ${this.node.path}`);\n    }\n\n    new EventInvokeConfig(this, 'EventInvokeConfig', {\n      function: this.lambda,\n      qualifier: this.qualifier,\n      ...options,\n    });\n  }\n}\n\n/**\n * The $LATEST version of a function, useful when attempting to create aliases.\n */\nclass LatestVersion extends FunctionBase implements IVersion {\n  public readonly lambda: IFunction;\n  public readonly version = '$LATEST';\n  public readonly permissionsNode = this.node;\n\n  protected readonly canCreatePermissions = false;\n\n  constructor(lambda: FunctionBase) {\n    super(lambda, '$LATEST');\n    this.lambda = lambda;\n  }\n\n  public get functionArn() {\n    return `${this.lambda.functionArn}:${this.version}`;\n  }\n\n  public get functionName() {\n    return `${this.lambda.functionName}:${this.version}`;\n  }\n\n  public get architecture() {\n    return this.lambda.architecture;\n  }\n\n  public get grantPrincipal() {\n    return this.lambda.grantPrincipal;\n  }\n\n  public get latestVersion() {\n    return this;\n  }\n\n  public get role() {\n    return this.lambda.role;\n  }\n\n  public addAlias(aliasName: string, options: AliasOptions = {}) {\n    return addAlias(this, this, aliasName, options);\n  }\n\n  public get edgeArn(): never {\n    throw new Error('$LATEST function version cannot be used for Lambda@Edge');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
