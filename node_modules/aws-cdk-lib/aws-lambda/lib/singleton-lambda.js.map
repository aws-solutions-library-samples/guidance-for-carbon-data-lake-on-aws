{
  "version": 3,
  "sources": ["singleton-lambda.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as logs from '../../aws-logs';\nimport * as cdk from '../../core';\nimport { Construct, IConstruct, IDependable, Node } from 'constructs';\nimport { Architecture } from './architecture';\nimport { Function as LambdaFunction, FunctionProps, EnvironmentOptions } from './function';\nimport { FunctionBase } from './function-base';\nimport { Version } from './lambda-version';\nimport { ILayerVersion } from './layers';\nimport { Permission } from './permission';\nimport { Runtime } from './runtime';\n\n/**\n * Properties for a newly created singleton Lambda\n */\nexport interface SingletonFunctionProps extends FunctionProps {\n  /**\n   * A unique identifier to identify this lambda\n   *\n   * The identifier should be unique across all custom resource providers.\n   * We recommend generating a UUID per provider.\n   */\n  readonly uuid: string;\n\n  /**\n   * A descriptive name for the purpose of this Lambda.\n   *\n   * If the Lambda does not have a physical name, this string will be\n   * reflected its generated name. The combination of lambdaPurpose\n   * and uuid must be unique.\n   *\n   * @default SingletonLambda\n   */\n  readonly lambdaPurpose?: string;\n}\n\n/**\n * A Lambda that will only ever be added to a stack once.\n *\n * This construct is a way to guarantee that the lambda function will be guaranteed to be part of the stack,\n * once and only once, irrespective of how many times the construct is declared to be part of the stack.\n * This is guaranteed as long as the `uuid` property and the optional `lambdaPurpose` property stay the same\n * whenever they're declared into the stack.\n *\n * @resource AWS::Lambda::Function\n */\nexport class SingletonFunction extends FunctionBase {\n  public readonly grantPrincipal: iam.IPrincipal;\n  public readonly functionName: string;\n  public readonly functionArn: string;\n  public readonly role?: iam.IRole;\n  public readonly permissionsNode: Node;\n  public readonly architecture: Architecture;\n\n  /**\n   * The runtime environment for the Lambda function.\n   */\n  public readonly runtime: Runtime;\n\n  protected readonly canCreatePermissions: boolean;\n  private lambdaFunction: LambdaFunction;\n\n  constructor(scope: Construct, id: string, props: SingletonFunctionProps) {\n    super(scope, id);\n\n    this.lambdaFunction = this.ensureLambda(props);\n    this.permissionsNode = this.lambdaFunction.node;\n    this.architecture = this.lambdaFunction.architecture;\n\n    this.functionArn = this.lambdaFunction.functionArn;\n    this.functionName = this.lambdaFunction.functionName;\n    this.role = this.lambdaFunction.role;\n    this.runtime = this.lambdaFunction.runtime;\n    this.grantPrincipal = this.lambdaFunction.grantPrincipal;\n\n    this.canCreatePermissions = true; // Doesn't matter, addPermission is overriden anyway\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public get isBoundToVpc(): boolean {\n    return this.lambdaFunction.isBoundToVpc;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public get connections(): ec2.Connections {\n    return this.lambdaFunction.connections;\n  }\n\n  /**\n   * The LogGroup where the Lambda function's logs are made available.\n   *\n   * If either `logRetention` is set or this property is called, a CloudFormation custom resource is added to the stack that\n   * pre-creates the log group as part of the stack deployment, if it already doesn't exist, and sets the correct log retention\n   * period (never expire, by default).\n   *\n   * Further, if the log group already exists and the `logRetention` is not set, the custom resource will reset the log retention\n   * to never expire even if it was configured with a different value.\n   */\n  public get logGroup(): logs.ILogGroup {\n    return this.lambdaFunction.logGroup;\n  }\n\n  /**\n   * Returns a `lambda.Version` which represents the current version of this\n   * singleton Lambda function. A new version will be created every time the\n   * function's configuration changes.\n   *\n   * You can specify options for this version using the `currentVersionOptions`\n   * prop when initializing the `lambda.SingletonFunction`.\n   */\n  public get currentVersion(): Version {\n    return this.lambdaFunction.currentVersion;\n  }\n\n  /**\n   * Adds an environment variable to this Lambda function.\n   * If this is a ref to a Lambda function, this operation results in a no-op.\n   * @param key The environment variable key.\n   * @param value The environment variable's value.\n   * @param options Environment variable options.\n   */\n  public addEnvironment(key: string, value: string, options?: EnvironmentOptions) {\n    return this.lambdaFunction.addEnvironment(key, value, options);\n  }\n\n  /**\n   * Adds one or more Lambda Layers to this Lambda function.\n   *\n   * @param layers the layers to be added.\n   *\n   * @throws if there are already 5 layers on this function, or the layer is incompatible with this function's runtime.\n   */\n  public addLayers(...layers: ILayerVersion[]) {\n    return this.lambdaFunction.addLayers(...layers);\n  }\n\n  public addPermission(name: string, permission: Permission) {\n    return this.lambdaFunction.addPermission(name, permission);\n  }\n\n  /**\n   * Using node.addDependency() does not work on this method as the underlying lambda function is modeled\n   * as a singleton across the stack. Use this method instead to declare dependencies.\n   */\n  public addDependency(...up: IDependable[]) {\n    this.lambdaFunction.node.addDependency(...up);\n  }\n\n  /**\n   * The SingletonFunction construct cannot be added as a dependency of another construct using\n   * node.addDependency(). Use this method instead to declare this as a dependency of another construct.\n   */\n  public dependOn(down: IConstruct) {\n    down.node.addDependency(this.lambdaFunction);\n  }\n\n  /** @internal */\n  public _checkEdgeCompatibility() {\n    return this.lambdaFunction._checkEdgeCompatibility();\n  }\n\n  /**\n   * Returns the construct tree node that corresponds to the lambda function.\n   * @internal\n   */\n  protected _functionNode(): Node {\n    return this.lambdaFunction.node;\n  }\n\n  private ensureLambda(props: SingletonFunctionProps): LambdaFunction {\n    const constructName = (props.lambdaPurpose || 'SingletonLambda') + slugify(props.uuid);\n    const existing = cdk.Stack.of(this).node.tryFindChild(constructName);\n    if (existing) {\n      // Just assume this is true\n      return existing as LambdaFunction;\n    }\n\n    return new LambdaFunction(cdk.Stack.of(this), constructName, props);\n  }\n}\n\nfunction slugify(x: string): string {\n  return x.replace(/[^a-zA-Z0-9]/g, '');\n}\n"],
  "mappings": "wNAGA,IAAA,QAAA,cAGA,WAAA,QAAA,cACA,gBAAA,QAAA,mBAwCA,+BAAuC,iBAAA,YAAY,CAgBjD,YAAY,MAAkB,GAAY,MAA6B,CACrE,MAAM,MAAO,iFAEb,KAAK,eAAiB,KAAK,aAAa,OACxC,KAAK,gBAAkB,KAAK,eAAe,KAC3C,KAAK,aAAe,KAAK,eAAe,aAExC,KAAK,YAAc,KAAK,eAAe,YACvC,KAAK,aAAe,KAAK,eAAe,aACxC,KAAK,KAAO,KAAK,eAAe,KAChC,KAAK,QAAU,KAAK,eAAe,QACnC,KAAK,eAAiB,KAAK,eAAe,eAE1C,KAAK,qBAAuB,MAMnB,eAAY,CACrB,MAAO,MAAK,eAAe,gBAMlB,cAAW,CACpB,MAAO,MAAK,eAAe,eAalB,WAAQ,CACjB,MAAO,MAAK,eAAe,YAWlB,iBAAc,CACvB,MAAO,MAAK,eAAe,eAUtB,eAAe,IAAa,MAAe,QAA4B,mFACrE,KAAK,eAAe,eAAe,IAAK,MAAO,SAUjD,aAAa,OAAuB,6EAClC,KAAK,eAAe,UAAU,GAAG,QAGnC,cAAc,KAAc,WAAsB,8EAChD,KAAK,eAAe,cAAc,KAAM,YAO1C,iBAAiB,GAAiB,CACvC,KAAK,eAAe,KAAK,cAAc,GAAG,IAOrC,SAAS,KAAgB,CAC9B,KAAK,KAAK,cAAc,KAAK,gBAIxB,yBAAuB,CAC5B,MAAO,MAAK,eAAe,0BAOnB,eAAa,CACrB,MAAO,MAAK,eAAe,KAGrB,aAAa,MAA6B,CAChD,KAAM,eAAiB,OAAM,eAAiB,mBAAqB,QAAQ,MAAM,MAC3E,SAAW,IAAI,MAAM,GAAG,MAAM,KAAK,aAAa,eACtD,MAAI,WAKG,GAAI,YAAA,SAAe,IAAI,MAAM,GAAG,MAAO,cAAe,QAvIjE,QAAA,kBAAA,gIA2IA,iBAAiB,EAAS,CACxB,MAAO,GAAE,QAAQ,gBAAiB",
  "names": []
}
