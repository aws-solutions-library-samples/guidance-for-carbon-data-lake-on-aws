{
  "version": 3,
  "sources": ["lambda.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as lambda from '../../aws-lambda';\nimport * as sns from '../../aws-sns';\nimport { ArnFormat, Names, Stack, Token } from '../../core';\nimport { SubscriptionProps } from './subscription';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n/**\n * Properties for a Lambda subscription\n */\nexport interface LambdaSubscriptionProps extends SubscriptionProps {\n\n}\n/**\n * Use a Lambda function as a subscription target\n */\nexport class LambdaSubscription implements sns.ITopicSubscription {\n  constructor(private readonly fn: lambda.IFunction, private readonly props: LambdaSubscriptionProps = {}) {\n  }\n\n  /**\n   * Returns a configuration for a Lambda function to subscribe to an SNS topic\n   */\n  public bind(topic: sns.ITopic): sns.TopicSubscriptionConfig {\n    // Create subscription under *consuming* construct to make sure it ends up\n    // in the correct stack in cases of cross-stack subscriptions.\n    if (!(this.fn instanceof Construct)) {\n      throw new Error('The supplied lambda Function object must be an instance of Construct');\n    }\n\n    this.fn.addPermission(`AllowInvoke:${Names.nodeUniqueId(topic.node)}`, {\n      sourceArn: topic.topicArn,\n      principal: new iam.ServicePrincipal('sns.amazonaws.com'),\n    });\n\n    // if the topic and function are created in different stacks\n    // then we need to make sure the topic is created first\n    if (topic instanceof sns.Topic && topic.stack !== this.fn.stack) {\n      this.fn.stack.addDependency(topic.stack);\n    }\n\n    return {\n      subscriberScope: this.fn,\n      subscriberId: topic.node.id,\n      endpoint: this.fn.functionArn,\n      protocol: sns.SubscriptionProtocol.LAMBDA,\n      filterPolicy: this.props.filterPolicy,\n      region: this.regionFromArn(topic),\n      deadLetterQueue: this.props.deadLetterQueue,\n    };\n  }\n\n  private regionFromArn(topic: sns.ITopic): string | undefined {\n    // no need to specify `region` for topics defined within the same stack.\n    if (topic instanceof sns.Topic) {\n      if (topic.stack !== this.fn.stack) {\n        // only if we know the region, will not work for\n        // env agnostic stacks\n        if (!Token.isUnresolved(topic.stack.region) &&\n          (topic.stack.region !== this.fn.stack.region)) {\n          return topic.stack.region;\n        }\n      }\n      return undefined;\n    }\n    return Stack.of(topic).splitArn(topic.topicArn, ArnFormat.SLASH_RESOURCE_NAME).region;\n  }\n}\n"],
  "mappings": "yNAAA,IAAA,QAAA,iBAEA,IAAA,QAAA,iBACA,OAAA,QAAA,cAKA,aAAA,QAAA,cAWA,wBAA+B,CAC7B,YAA6B,GAAuC,MAAiC,GAAE,CAA1E,KAAA,GAAA,GAAuC,KAAA,MAAA,4JAM7D,KAAK,MAAiB,CAG3B,6DAAI,CAAE,MAAK,aAAc,cAAA,WACvB,KAAM,IAAI,OAAM,wEAGlB,YAAK,GAAG,cAAc,eAAe,OAAA,MAAM,aAAa,MAAM,QAAS,CACrE,UAAW,MAAM,SACjB,UAAW,GAAI,KAAI,iBAAiB,uBAKlC,gBAAiB,KAAI,OAAS,MAAM,QAAU,KAAK,GAAG,OACxD,KAAK,GAAG,MAAM,cAAc,MAAM,OAG7B,CACL,gBAAiB,KAAK,GACtB,aAAc,MAAM,KAAK,GACzB,SAAU,KAAK,GAAG,YAClB,SAAU,IAAI,qBAAqB,OACnC,aAAc,KAAK,MAAM,aACzB,OAAQ,KAAK,cAAc,OAC3B,gBAAiB,KAAK,MAAM,iBAIxB,cAAc,MAAiB,CAErC,MAAI,iBAAiB,KAAI,MACnB,MAAM,QAAU,KAAK,GAAG,OAGtB,CAAC,OAAA,MAAM,aAAa,MAAM,MAAM,SACjC,MAAM,MAAM,SAAW,KAAK,GAAG,MAAM,OAC/B,MAAM,MAAM,OAGvB,OAEK,OAAA,MAAM,GAAG,OAAO,SAAS,MAAM,SAAU,OAAA,UAAU,qBAAqB,QAjDnF,QAAA,mBAAA",
  "names": []
}
