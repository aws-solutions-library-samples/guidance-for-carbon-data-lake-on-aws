{
  "version": 3,
  "sources": ["key.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as cxschema from '../../cloud-assembly-schema';\nimport { FeatureFlags, IResource, Lazy, RemovalPolicy, Resource, Stack, Duration, Token, ContextProvider, Arn, ArnFormat } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { IConstruct, Construct } from 'constructs';\nimport { Alias } from './alias';\nimport { KeyLookupOptions } from './key-lookup';\nimport { CfnKey } from './kms.generated';\nimport * as perms from './private/perms';\n\n/**\n * A KMS Key, either managed by this CDK app, or imported.\n */\nexport interface IKey extends IResource {\n  /**\n   * The ARN of the key.\n   *\n   * @attribute\n   */\n  readonly keyArn: string;\n\n  /**\n   * The ID of the key\n   * (the part that looks something like: 1234abcd-12ab-34cd-56ef-1234567890ab).\n   *\n   * @attribute\n   */\n  readonly keyId: string;\n\n  /**\n   * Defines a new alias for the key.\n   */\n  addAlias(alias: string): Alias;\n\n  /**\n   * Adds a statement to the KMS key resource policy.\n   * @param statement The policy statement to add\n   * @param allowNoOp If this is set to `false` and there is no policy\n   * defined (i.e. external key), the operation will fail. Otherwise, it will\n   * no-op.\n   */\n  addToResourcePolicy(statement: iam.PolicyStatement, allowNoOp?: boolean): iam.AddToResourcePolicyResult;\n\n  /**\n   * Grant the indicated permissions on this key to the given principal\n   */\n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n  /**\n   * Grant decryption permissions using this key to the given principal\n   */\n  grantDecrypt(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Grant encryption permissions using this key to the given principal\n   */\n  grantEncrypt(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Grant encryption and decryption permissions using this key to the given principal\n   */\n  grantEncryptDecrypt(grantee: iam.IGrantable): iam.Grant;\n}\n\nabstract class KeyBase extends Resource implements IKey {\n  /**\n   * The ARN of the key.\n   */\n  public abstract readonly keyArn: string;\n\n  public abstract readonly keyId: string;\n\n  /**\n   * Optional policy document that represents the resource policy of this key.\n   *\n   * If specified, addToResourcePolicy can be used to edit this policy.\n   * Otherwise this method will no-op.\n   */\n  protected abstract readonly policy?: iam.PolicyDocument;\n\n  /**\n   * Optional property to control trusting account identities.\n   *\n   * If specified, grants will default identity policies instead of to both\n   * resource and identity policies. This matches the default behavior when creating\n   * KMS keys via the API or console.\n   */\n  protected abstract readonly trustAccountIdentities: boolean;\n\n  /**\n   * Collection of aliases added to the key\n   *\n   * Tracked to determine whether or not the aliasName should be added to the end of its ID\n   */\n  private readonly aliases: Alias[] = [];\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    this.node.addValidation({ validate: () => this.policy?.validateForResourcePolicy() ?? [] });\n  }\n\n  /**\n   * Defines a new alias for the key.\n   */\n  public addAlias(aliasName: string): Alias {\n    const aliasId = this.aliases.length > 0 ? `Alias${aliasName}` : 'Alias';\n\n    const alias = new Alias(this, aliasId, { aliasName, targetKey: this });\n    this.aliases.push(alias);\n\n    return alias;\n  }\n\n  /**\n   * Adds a statement to the KMS key resource policy.\n   * @param statement The policy statement to add\n   * @param allowNoOp If this is set to `false` and there is no policy\n   * defined (i.e. external key), the operation will fail. Otherwise, it will\n   * no-op.\n   */\n  public addToResourcePolicy(statement: iam.PolicyStatement, allowNoOp = true): iam.AddToResourcePolicyResult {\n    const stack = Stack.of(this);\n\n    if (!this.policy) {\n      if (allowNoOp) { return { statementAdded: false }; }\n      throw new Error(`Unable to add statement to IAM resource policy for KMS key: ${JSON.stringify(stack.resolve(this.keyArn))}`);\n    }\n\n    this.policy.addStatements(statement);\n    return { statementAdded: true, policyDependable: this.policy };\n  }\n\n  /**\n   * Grant the indicated permissions on this key to the given principal\n   *\n   * This modifies both the principal's policy as well as the resource policy,\n   * since the default CloudFormation setup for KMS keys is that the policy\n   * must not be empty and so default grants won't work.\n   */\n  public grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant {\n    // KMS verifies whether the principals included in its key policy actually exist.\n    // This is a problem if the stack the grantee is part of depends on the key stack\n    // (as it won't exist before the key policy is attempted to be created).\n    // In that case, make the account the resource policy principal\n    const granteeStackDependsOnKeyStack = this.granteeStackDependsOnKeyStack(grantee);\n    const principal = granteeStackDependsOnKeyStack\n      ? new iam.AccountPrincipal(granteeStackDependsOnKeyStack)\n      : grantee.grantPrincipal;\n\n    const crossAccountAccess = this.isGranteeFromAnotherAccount(grantee);\n    const crossRegionAccess = this.isGranteeFromAnotherRegion(grantee);\n    const crossEnvironment = crossAccountAccess || crossRegionAccess;\n    const grantOptions: iam.GrantWithResourceOptions = {\n      grantee,\n      actions,\n      resource: this,\n      resourceArns: [this.keyArn],\n      resourceSelfArns: crossEnvironment ? undefined : ['*'],\n    };\n    if (this.trustAccountIdentities && !crossEnvironment) {\n      return iam.Grant.addToPrincipalOrResource(grantOptions);\n    } else {\n      return iam.Grant.addToPrincipalAndResource({\n        ...grantOptions,\n        // if the key is used in a cross-environment matter,\n        // we can't access the Key ARN (they don't have physical names),\n        // so fall back to using '*'. ToDo we need to make this better... somehow\n        resourceArns: crossEnvironment ? ['*'] : [this.keyArn],\n        resourcePolicyPrincipal: principal,\n      });\n    }\n  }\n\n  /**\n   * Grant decryption permissions using this key to the given principal\n   */\n  public grantDecrypt(grantee: iam.IGrantable): iam.Grant {\n    return this.grant(grantee, ...perms.DECRYPT_ACTIONS);\n  }\n\n  /**\n   * Grant encryption permissions using this key to the given principal\n   */\n  public grantEncrypt(grantee: iam.IGrantable): iam.Grant {\n    return this.grant(grantee, ...perms.ENCRYPT_ACTIONS);\n  }\n\n  /**\n   * Grant encryption and decryption permissions using this key to the given principal\n   */\n  public grantEncryptDecrypt(grantee: iam.IGrantable): iam.Grant {\n    return this.grant(grantee, ...[...perms.DECRYPT_ACTIONS, ...perms.ENCRYPT_ACTIONS]);\n  }\n\n  /**\n   * Checks whether the grantee belongs to a stack that will be deployed\n   * after the stack containing this key.\n   *\n   * @param grantee the grantee to give permissions to\n   * @returns the account ID of the grantee stack if its stack does depend on this stack,\n   *   undefined otherwise\n   */\n  private granteeStackDependsOnKeyStack(grantee: iam.IGrantable): string | undefined {\n    const grantPrincipal = grantee.grantPrincipal;\n    if (!isConstruct(grantPrincipal)) {\n      return undefined;\n    }\n    // this logic should only apply to newly created\n    // (= not imported) resources\n    if (!this.principalIsANewlyCreatedResource(grantPrincipal)) {\n      return undefined;\n    }\n    // return undefined;\n    const keyStack = Stack.of(this);\n    const granteeStack = Stack.of(grantPrincipal);\n    if (keyStack === granteeStack) {\n      return undefined;\n    }\n    return granteeStack.dependencies.includes(keyStack)\n      ? granteeStack.account\n      : undefined;\n  }\n\n  private principalIsANewlyCreatedResource(principal: IConstruct): boolean {\n    // yes, this sucks\n    // this is just a temporary stopgap to stem the bleeding while we work on a proper fix\n    return principal instanceof iam.Role ||\n      principal instanceof iam.User ||\n      principal instanceof iam.Group;\n  }\n\n  private isGranteeFromAnotherRegion(grantee: iam.IGrantable): boolean {\n    if (!isConstruct(grantee)) {\n      return false;\n    }\n    const bucketStack = Stack.of(this);\n    const identityStack = Stack.of(grantee);\n    return bucketStack.region !== identityStack.region;\n  }\n\n  private isGranteeFromAnotherAccount(grantee: iam.IGrantable): boolean {\n    if (!isConstruct(grantee)) {\n      return false;\n    }\n    const bucketStack = Stack.of(this);\n    const identityStack = Stack.of(grantee);\n    return bucketStack.account !== identityStack.account;\n  }\n}\n\n/**\n * The key spec, represents the cryptographic configuration of keys.\n */\nexport enum KeySpec {\n  /**\n   * The default key spec.\n   *\n   * Valid usage: ENCRYPT_DECRYPT\n   */\n  SYMMETRIC_DEFAULT = 'SYMMETRIC_DEFAULT',\n\n  /**\n   * RSA with 2048 bits of key.\n   *\n   * Valid usage: ENCRYPT_DECRYPT and SIGN_VERIFY\n   */\n  RSA_2048 = 'RSA_2048',\n\n  /**\n   * RSA with 3072 bits of key.\n   *\n   * Valid usage: ENCRYPT_DECRYPT and SIGN_VERIFY\n   */\n  RSA_3072 = 'RSA_3072',\n\n  /**\n   * RSA with 4096 bits of key.\n   *\n   * Valid usage: ENCRYPT_DECRYPT and SIGN_VERIFY\n   */\n  RSA_4096 = 'RSA_4096',\n\n  /**\n   * NIST FIPS 186-4, Section 6.4, ECDSA signature using the curve specified by the key and\n   * SHA-256 for the message digest.\n   *\n   * Valid usage: SIGN_VERIFY\n   */\n  ECC_NIST_P256 = 'ECC_NIST_P256',\n\n  /**\n   * NIST FIPS 186-4, Section 6.4, ECDSA signature using the curve specified by the key and\n   * SHA-384 for the message digest.\n   *\n   * Valid usage: SIGN_VERIFY\n   */\n  ECC_NIST_P384 = 'ECC_NIST_P384',\n\n  /**\n   * NIST FIPS 186-4, Section 6.4, ECDSA signature using the curve specified by the key and\n   * SHA-512 for the message digest.\n   *\n   * Valid usage: SIGN_VERIFY\n   */\n  ECC_NIST_P521 = 'ECC_NIST_P521',\n\n  /**\n   * Standards for Efficient Cryptography 2, Section 2.4.1, ECDSA signature on the Koblitz curve.\n   *\n   * Valid usage: SIGN_VERIFY\n   */\n  ECC_SECG_P256K1 = 'ECC_SECG_P256K1',\n}\n\n/**\n * The key usage, represents the cryptographic operations of keys.\n */\nexport enum KeyUsage {\n  /**\n   * Encryption and decryption.\n   */\n  ENCRYPT_DECRYPT = 'ENCRYPT_DECRYPT',\n\n  /**\n   * Signing and verification\n   */\n  SIGN_VERIFY = 'SIGN_VERIFY',\n}\n\n/**\n * Construction properties for a KMS Key object\n */\nexport interface KeyProps {\n  /**\n   * A description of the key. Use a description that helps your users decide\n   * whether the key is appropriate for a particular task.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n\n  /**\n   * Initial alias to add to the key\n   *\n   * More aliases can be added later by calling `addAlias`.\n   *\n   * @default - No alias is added for the key.\n   */\n  readonly alias?: string;\n\n  /**\n   * Indicates whether AWS KMS rotates the key.\n   *\n   * @default false\n   */\n  readonly enableKeyRotation?: boolean;\n\n  /**\n   * Indicates whether the key is available for use.\n   *\n   * @default - Key is enabled.\n   */\n  readonly enabled?: boolean;\n\n  /**\n   * The cryptographic configuration of the key. The valid value depends on usage of the key.\n   *\n   * IMPORTANT: If you change this property of an existing key, the existing key is scheduled for deletion\n   * and a new key is created with the specified value.\n   *\n   * @default KeySpec.SYMMETRIC_DEFAULT\n   */\n  readonly keySpec?: KeySpec;\n\n  /**\n   * The cryptographic operations for which the key can be used.\n   *\n   * IMPORTANT: If you change this property of an existing key, the existing key is scheduled for deletion\n   * and a new key is created with the specified value.\n   *\n   * @default KeyUsage.ENCRYPT_DECRYPT\n   */\n  readonly keyUsage?: KeyUsage;\n\n  /**\n   * Custom policy document to attach to the KMS key.\n   *\n   * NOTE - If the `@aws-cdk/aws-kms:defaultKeyPolicies` feature flag is set (the default for new projects),\n   * this policy will *override* the default key policy and become the only key policy for the key. If the\n   * feature flag is not set, this policy will be appended to the default key policy.\n   *\n   * @default - A policy document with permissions for the account root to\n   * administer the key will be created.\n   */\n  readonly policy?: iam.PolicyDocument;\n\n  /**\n   * A list of principals to add as key administrators to the key policy.\n   *\n   * Key administrators have permissions to manage the key (e.g., change permissions, revoke), but do not have permissions\n   * to use the key in cryptographic operations (e.g., encrypt, decrypt).\n   *\n   * These principals will be added to the default key policy (if none specified), or to the specified policy (if provided).\n   *\n   * @default []\n   */\n  readonly admins?: iam.IPrincipal[];\n\n  /**\n   * Whether the encryption key should be retained when it is removed from the Stack. This is useful when one wants to\n   * retain access to data that was encrypted with a key that is being retired.\n   *\n   * @default RemovalPolicy.Retain\n   */\n  readonly removalPolicy?: RemovalPolicy;\n\n  /**\n   * Whether the key usage can be granted by IAM policies\n   *\n   * Setting this to true adds a default statement which delegates key\n   * access control completely to the identity's IAM policy (similar\n   * to how it works for other AWS resources). This matches the default behavior\n   * when creating KMS keys via the API or console.\n   *\n   * If the `@aws-cdk/aws-kms:defaultKeyPolicies` feature flag is set (the default for new projects),\n   * this flag will always be treated as 'true' and does not need to be explicitly set.\n   *\n   * @default - false, unless the `@aws-cdk/aws-kms:defaultKeyPolicies` feature flag is set.\n   * @see https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam\n   * @deprecated redundant with the `@aws-cdk/aws-kms:defaultKeyPolicies` feature flag\n   */\n  readonly trustAccountIdentities?: boolean;\n\n  /**\n   * Specifies the number of days in the waiting period before\n   * AWS KMS deletes a CMK that has been removed from a CloudFormation stack.\n   *\n   * When you remove a customer master key (CMK) from a CloudFormation stack, AWS KMS schedules the CMK for deletion\n   * and starts the mandatory waiting period. The PendingWindowInDays property determines the length of waiting period.\n   * During the waiting period, the key state of CMK is Pending Deletion, which prevents the CMK from being used in\n   * cryptographic operations. When the waiting period expires, AWS KMS permanently deletes the CMK.\n   *\n   * Enter a value between 7 and 30 days.\n   *\n   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-key.html#cfn-kms-key-pendingwindowindays\n   * @default - 30 days\n   */\n  readonly pendingWindow?: Duration;\n}\n\n/**\n * Defines a KMS key.\n *\n * @resource AWS::KMS::Key\n */\nexport class Key extends KeyBase {\n  /**\n   * Import an externally defined KMS Key using its ARN.\n   *\n   * @param scope  the construct that will \"own\" the imported key.\n   * @param id     the id of the imported key in the construct tree.\n   * @param keyArn the ARN of an existing KMS key.\n   */\n  public static fromKeyArn(scope: Construct, id: string, keyArn: string): IKey {\n    class Import extends KeyBase {\n      public readonly keyArn = keyArn;\n      public readonly keyId: string;\n      protected readonly policy?: iam.PolicyDocument | undefined = undefined;\n      // defaulting true: if we are importing the key the key policy is\n      // undefined and impossible to change here; this means updating identity\n      // policies is really the only option\n      protected readonly trustAccountIdentities: boolean = true;\n\n      constructor(keyId: string) {\n        super(scope, id);\n\n        this.keyId = keyId;\n      }\n    }\n\n    const keyResourceName = Stack.of(scope).splitArn(keyArn, ArnFormat.SLASH_RESOURCE_NAME).resourceName;\n    if (!keyResourceName) {\n      throw new Error(`KMS key ARN must be in the format 'arn:aws:kms:<region>:<account>:key/<keyId>', got: '${keyArn}'`);\n    }\n\n    return new Import(keyResourceName);\n  }\n\n  /**\n   * Create a mutable {@link IKey} based on a low-level {@link CfnKey}.\n   * This is most useful when combined with the cloudformation-include module.\n   * This method is different than {@link fromKeyArn()} because the {@link IKey}\n   * returned from this method is mutable;\n   * meaning, calling any mutating methods on it,\n   * like {@link IKey.addToResourcePolicy()},\n   * will actually be reflected in the resulting template,\n   * as opposed to the object returned from {@link fromKeyArn()},\n   * on which calling those methods would have no effect.\n   */\n  public static fromCfnKey(cfnKey: CfnKey): IKey {\n    // use a \"weird\" id that has a higher chance of being unique\n    const id = '@FromCfnKey';\n\n    // if fromCfnKey() was already called on this cfnKey,\n    // return the same L2\n    // (as different L2s would conflict, because of the mutation of the keyPolicy property of the L1 below)\n    const existing = cfnKey.node.tryFindChild(id);\n    if (existing) {\n      return <IKey>existing;\n    }\n\n    let keyPolicy: iam.PolicyDocument;\n    try {\n      keyPolicy = iam.PolicyDocument.fromJson(cfnKey.keyPolicy);\n    } catch (e) {\n      // If the KeyPolicy contains any CloudFormation functions,\n      // PolicyDocument.fromJson() throws an exception.\n      // In that case, because we would have to effectively make the returned IKey immutable,\n      // throw an exception suggesting to use the other importing methods instead.\n      // We might make this parsing logic smarter later,\n      // but let's start by erroring out.\n      throw new Error('Could not parse the PolicyDocument of the passed AWS::KMS::Key resource because it contains CloudFormation functions. ' +\n        'This makes it impossible to create a mutable IKey from that Policy. ' +\n        'You have to use fromKeyArn instead, passing it the ARN attribute property of the low-level CfnKey');\n    }\n\n    // change the key policy of the L1, so that all changes done in the L2 are reflected in the resulting template\n    cfnKey.keyPolicy = Lazy.any({ produce: () => keyPolicy.toJSON() });\n\n    return new class extends KeyBase {\n      public readonly keyArn = cfnKey.attrArn;\n      public readonly keyId = cfnKey.ref;\n      protected readonly policy = keyPolicy;\n      protected readonly trustAccountIdentities = false;\n    }(cfnKey, id);\n  }\n\n  /**\n   * Import an existing Key by querying the AWS environment this stack is deployed to.\n   *\n   * This function only needs to be used to use Keys not defined in your CDK\n   * application. If you are looking to share a Key between stacks, you can\n   * pass the `Key` object between stacks and use it as normal. In addition,\n   * it's not necessary to use this method if an interface accepts an `IKey`.\n   * In this case, `Alias.fromAliasName()` can be used which returns an alias\n   * that extends `IKey`.\n   *\n   * Calling this method will lead to a lookup when the CDK CLI is executed.\n   * You can therefore not use any values that will only be available at\n   * CloudFormation execution time (i.e., Tokens).\n   *\n   * The Key information will be cached in `cdk.context.json` and the same Key\n   * will be used on future runs. To refresh the lookup, you will have to\n   * evict the value from the cache using the `cdk context` command. See\n   * https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information.\n   */\n  public static fromLookup(scope: Construct, id: string, options: KeyLookupOptions): IKey {\n    class Import extends KeyBase {\n      public readonly keyArn: string;\n      public readonly keyId: string;\n      protected readonly policy?: iam.PolicyDocument | undefined = undefined;\n      // defaulting true: if we are importing the key the key policy is\n      // undefined and impossible to change here; this means updating identity\n      // policies is really the only option\n      protected readonly trustAccountIdentities: boolean = true;\n\n      constructor(keyId: string, keyArn: string) {\n        super(scope, id);\n\n        this.keyId = keyId;\n        this.keyArn = keyArn;\n      }\n    }\n    if (Token.isUnresolved(options.aliasName)) {\n      throw new Error('All arguments to Key.fromLookup() must be concrete (no Tokens)');\n    }\n\n    const attributes: cxapi.KeyContextResponse = ContextProvider.getValue(scope, {\n      provider: cxschema.ContextProvider.KEY_PROVIDER,\n      props: {\n        aliasName: options.aliasName,\n      } as cxschema.KeyContextQuery,\n      dummyValue: {\n        keyId: '1234abcd-12ab-34cd-56ef-1234567890ab',\n      },\n    }).value;\n\n    return new Import(attributes.keyId,\n      Arn.format({ resource: 'key', service: 'kms', resourceName: attributes.keyId }, Stack.of(scope)));\n  }\n\n  public readonly keyArn: string;\n  public readonly keyId: string;\n  protected readonly policy?: iam.PolicyDocument;\n  protected readonly trustAccountIdentities: boolean;\n\n  constructor(scope: Construct, id: string, props: KeyProps = {}) {\n    super(scope, id);\n\n    const denyLists = {\n      [KeyUsage.ENCRYPT_DECRYPT]: [\n        KeySpec.ECC_NIST_P256,\n        KeySpec.ECC_NIST_P384,\n        KeySpec.ECC_NIST_P521,\n        KeySpec.ECC_SECG_P256K1,\n      ],\n      [KeyUsage.SIGN_VERIFY]: [\n        KeySpec.SYMMETRIC_DEFAULT,\n      ],\n    };\n    const keySpec = props.keySpec ?? KeySpec.SYMMETRIC_DEFAULT;\n    const keyUsage = props.keyUsage ?? KeyUsage.ENCRYPT_DECRYPT;\n    if (denyLists[keyUsage].includes(keySpec)) {\n      throw new Error(`key spec '${keySpec}' is not valid with usage '${keyUsage}'`);\n    }\n\n    if (keySpec !== KeySpec.SYMMETRIC_DEFAULT && props.enableKeyRotation) {\n      throw new Error('key rotation cannot be enabled on asymmetric keys');\n    }\n\n    const defaultKeyPoliciesFeatureEnabled = FeatureFlags.of(this).isEnabled(cxapi.KMS_DEFAULT_KEY_POLICIES);\n\n    this.policy = props.policy ?? new iam.PolicyDocument();\n    if (defaultKeyPoliciesFeatureEnabled) {\n      if (props.trustAccountIdentities === false) {\n        throw new Error('`trustAccountIdentities` cannot be false if the @aws-cdk/aws-kms:defaultKeyPolicies feature flag is set');\n      }\n\n      this.trustAccountIdentities = true;\n      // Set the default key policy if one hasn't been provided by the user.\n      if (!props.policy) {\n        this.addDefaultAdminPolicy();\n      }\n    } else {\n      this.trustAccountIdentities = props.trustAccountIdentities ?? false;\n      if (this.trustAccountIdentities) {\n        this.addDefaultAdminPolicy();\n      } else {\n        this.addLegacyAdminPolicy();\n      }\n    }\n\n    let pendingWindowInDays;\n    if (props.pendingWindow) {\n      pendingWindowInDays = props.pendingWindow.toDays();\n      if (pendingWindowInDays < 7 || pendingWindowInDays > 30) {\n        throw new Error(`'pendingWindow' value must between 7 and 30 days. Received: ${pendingWindowInDays}`);\n      }\n    }\n\n    const resource = new CfnKey(this, 'Resource', {\n      description: props.description,\n      enableKeyRotation: props.enableKeyRotation,\n      enabled: props.enabled,\n      keySpec: props.keySpec,\n      keyUsage: props.keyUsage,\n      keyPolicy: this.policy,\n      pendingWindowInDays: pendingWindowInDays,\n    });\n\n    this.keyArn = resource.attrArn;\n    this.keyId = resource.ref;\n    resource.applyRemovalPolicy(props.removalPolicy);\n\n    (props.admins ?? []).forEach((p) => this.grantAdmin(p));\n\n    if (props.alias !== undefined) {\n      this.addAlias(props.alias);\n    }\n  }\n\n  /**\n   * Grant admins permissions using this key to the given principal\n   *\n   * Key administrators have permissions to manage the key (e.g., change permissions, revoke), but do not have permissions\n   * to use the key in cryptographic operations (e.g., encrypt, decrypt).\n   */\n  public grantAdmin(grantee: iam.IGrantable): iam.Grant {\n    return this.grant(grantee, ...perms.ADMIN_ACTIONS);\n  }\n\n  /**\n   * Adds the default key policy to the key. This policy gives the AWS account (root user) full access to the CMK,\n   * which reduces the risk of the CMK becoming unmanageable and enables IAM policies to allow access to the CMK.\n   * This is the same policy that is default when creating a Key via the KMS API or Console.\n   * @see https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default\n   */\n  private addDefaultAdminPolicy() {\n    this.addToResourcePolicy(new iam.PolicyStatement({\n      resources: ['*'],\n      actions: ['kms:*'],\n      principals: [new iam.AccountRootPrincipal()],\n    }));\n  }\n\n  /**\n   * Grants the account admin privileges -- not full account access -- plus the GenerateDataKey action.\n   * The GenerateDataKey action was added for interop with S3 in https://github.com/aws/aws-cdk/issues/3458.\n   *\n   * This policy is discouraged and deprecated by the `@aws-cdk/aws-kms:defaultKeyPolicies` feature flag.\n   *\n   * @link https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default\n   * @deprecated\n   */\n  private addLegacyAdminPolicy() {\n    // This is equivalent to `[...perms.ADMIN_ACTIONS, 'kms:GenerateDataKey']`,\n    // but keeping this explicit ordering for backwards-compatibility (changing the ordering causes resource updates)\n    const actions = [\n      'kms:Create*',\n      'kms:Describe*',\n      'kms:Enable*',\n      'kms:List*',\n      'kms:Put*',\n      'kms:Update*',\n      'kms:Revoke*',\n      'kms:Disable*',\n      'kms:Get*',\n      'kms:Delete*',\n      'kms:ScheduleKeyDeletion',\n      'kms:CancelKeyDeletion',\n      'kms:GenerateDataKey',\n      'kms:TagResource',\n      'kms:UntagResource',\n    ];\n\n    this.addToResourcePolicy(new iam.PolicyStatement({\n      resources: ['*'],\n      actions,\n      principals: [new iam.AccountRootPrincipal()],\n    }));\n  }\n}\n\n/**\n * Whether the given object is a Construct\n *\n * Normally we'd do `x instanceof Construct`, but that is not robust against\n * multiple copies of the `constructs` library on disk. This can happen\n * when upgrading and downgrading between v2 and v1, and in the use of CDK\n * Pipelines is going to an error that says \"Can't use Pipeline/Pipeline/Role in\n * a cross-environment fashion\", which is very confusing.\n */\nfunction isConstruct(x: any): x is Construct {\n  const sym = Symbol.for('constructs.Construct.node');\n  return (typeof x === 'object' && x &&\n    (x instanceof Construct // happy fast case\n    || !!(x as any).node // constructs v10\n    || !!(x as any)[sym])); // constructs v3\n}"],
  "mappings": "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",
  "names": []
}
