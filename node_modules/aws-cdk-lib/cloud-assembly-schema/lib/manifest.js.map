{
  "version": 3,
  "sources": ["manifest.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as jsonschema from 'jsonschema';\nimport * as semver from 'semver';\nimport * as assets from './assets';\nimport * as assembly from './cloud-assembly';\n\n/* eslint-disable @typescript-eslint/no-var-requires */\n/* eslint-disable @typescript-eslint/no-require-imports */\n\n// this prefix is used by the CLI to identify this specific error.\n// in which case we want to instruct the user to upgrade his CLI.\n// see exec.ts#createAssembly\nexport const VERSION_MISMATCH: string = 'Cloud assembly schema version mismatch';\n\nconst ASSETS_SCHEMA = require('../schema/assets.schema.json');\n\nconst ASSEMBLY_SCHEMA = require('../schema/cloud-assembly.schema.json');\n\n/**\n * Version is shared for both manifests\n */\nconst SCHEMA_VERSION = require('../schema/cloud-assembly.version.json').version;\n\n/**\n * Protocol utility class.\n */\nexport class Manifest {\n  /**\n   * Validates and saves the cloud assembly manifest to file.\n   *\n   * @param manifest - manifest.\n   * @param filePath - output file path.\n   */\n  public static saveAssemblyManifest(manifest: assembly.AssemblyManifest, filePath: string) {\n    Manifest.saveManifest(manifest, filePath, ASSEMBLY_SCHEMA, Manifest.patchStackTagsOnWrite);\n  }\n\n  /**\n   * Load and validates the cloud assembly manifest from file.\n   *\n   * @param filePath - path to the manifest file.\n   */\n  public static loadAssemblyManifest(filePath: string): assembly.AssemblyManifest {\n    return Manifest.loadManifest(filePath, ASSEMBLY_SCHEMA, Manifest.patchStackTagsOnRead);\n  }\n\n  /**\n   * Validates and saves the asset manifest to file.\n   *\n   * @param manifest - manifest.\n   * @param filePath - output file path.\n   */\n  public static saveAssetManifest(manifest: assets.AssetManifest, filePath: string) {\n    Manifest.saveManifest(manifest, filePath, ASSETS_SCHEMA, Manifest.patchStackTagsOnRead);\n  }\n\n  /**\n   * Load and validates the asset manifest from file.\n   *\n   * @param filePath - path to the manifest file.\n   */\n  public static loadAssetManifest(filePath: string): assets.AssetManifest {\n    return this.loadManifest(filePath, ASSETS_SCHEMA);\n  }\n\n  /**\n   * Fetch the current schema version number.\n   */\n  public static version(): string {\n    return SCHEMA_VERSION;\n  }\n\n  /**\n   * Deprecated\n   * @deprecated use `saveAssemblyManifest()`\n   */\n  public static save(manifest: assembly.AssemblyManifest, filePath: string) { return this.saveAssemblyManifest(manifest, filePath); }\n\n  /**\n   * Deprecated\n   * @deprecated use `loadAssemblyManifest()`\n   */\n  public static load(filePath: string): assembly.AssemblyManifest { return this.loadAssemblyManifest(filePath); }\n\n  private static validate(manifest: { version: string }, schema: jsonschema.Schema) {\n\n    function parseVersion(version: string) {\n      const ver = semver.valid(version);\n      if (!ver) {\n        throw new Error(`Invalid semver string: \"${version}\"`);\n      }\n      return ver;\n    }\n\n    const maxSupported = parseVersion(Manifest.version());\n    const actual = parseVersion(manifest.version);\n\n    // first validate the version should be accepted.\n    if (semver.gt(actual, maxSupported)) {\n      // we use a well known error prefix so that the CLI can identify this specific error\n      // and print some more context to the user.\n      throw new Error(`${VERSION_MISMATCH}: Maximum schema version supported is ${maxSupported}, but found ${actual}`);\n    }\n\n    // now validate the format is good.\n    const validator = new jsonschema.Validator();\n    const result = validator.validate(manifest, schema, {\n\n      // does exist but is not in the TypeScript definitions\n      nestedErrors: true,\n\n      allowUnknownAttributes: false,\n\n    } as any);\n    if (!result.valid) {\n      throw new Error(`Invalid assembly manifest:\\n${result}`);\n    }\n\n  }\n\n  private static saveManifest(manifest: any, filePath: string, schema: jsonschema.Schema, preprocess?: (obj: any) => any) {\n    let withVersion = { ...manifest, version: Manifest.version() };\n    Manifest.validate(withVersion, schema);\n    if (preprocess) {\n      withVersion = preprocess(withVersion);\n    }\n    fs.writeFileSync(filePath, JSON.stringify(withVersion, undefined, 2));\n  }\n\n  private static loadManifest(filePath: string, schema: jsonschema.Schema, preprocess?: (obj: any) => any) {\n    let obj = JSON.parse(fs.readFileSync(filePath, { encoding: 'utf-8' }));\n    if (preprocess) {\n      obj = preprocess(obj);\n    }\n    Manifest.validate(obj, schema);\n    return obj;\n  }\n\n  /**\n   * This requires some explaining...\n   *\n   * We previously used `{ Key, Value }` for the object that represents a stack tag. (Notice the casing)\n   * @link https://github.com/aws/aws-cdk/blob/v1.27.0/packages/aws-cdk/lib/api/cxapp/stacks.ts#L427.\n   *\n   * When that object moved to this package, it had to be JSII compliant, which meant the property\n   * names must be `camelCased`, and not `PascalCased`. This meant it no longer matches the structure in the `manifest.json` file.\n   * In order to support current manifest files, we have to translate the `PascalCased` representation to the new `camelCased` one.\n   *\n   * Note that the serialization itself still writes `PascalCased` because it relates to how CloudFormation expects it.\n   *\n   * Ideally, we would start writing the `camelCased` and translate to how CloudFormation expects it when needed. But this requires nasty\n   * backwards-compatibility code and it just doesn't seem to be worth the effort.\n   */\n  private static patchStackTagsOnRead(manifest: assembly.AssemblyManifest) {\n    return Manifest.replaceStackTags(manifest, tags => tags.map((diskTag: any) => ({\n      key: diskTag.Key,\n      value: diskTag.Value,\n    })));\n  }\n\n  /**\n   * See explanation on `patchStackTagsOnRead`\n   *\n   * Translate stack tags metadata if it has the \"right\" casing.\n   */\n  private static patchStackTagsOnWrite(manifest: assembly.AssemblyManifest) {\n    return Manifest.replaceStackTags(manifest, tags => tags.map(memTag =>\n      // Might already be uppercased (because stack synthesis generates it in final form yet)\n      ('Key' in memTag ? memTag : { Key: memTag.key, Value: memTag.value }) as any,\n    ));\n  }\n\n  /**\n   * Recursively replace stack tags in the stack metadata\n   */\n  private static replaceStackTags(manifest: assembly.AssemblyManifest, fn: Endofunctor<assembly.StackTagsMetadataEntry>): assembly.AssemblyManifest {\n    // Need to add in the `noUndefined`s because otherwise jest snapshot tests are going to freak out\n    // about the keys with values that are `undefined` (even though they would never be JSON.stringified)\n    return noUndefined({\n      ...manifest,\n      artifacts: mapValues(manifest.artifacts, artifact => {\n        if (artifact.type !== assembly.ArtifactType.AWS_CLOUDFORMATION_STACK) { return artifact; }\n        return noUndefined({\n          ...artifact,\n          metadata: mapValues(artifact.metadata, metadataEntries => metadataEntries.map(metadataEntry => {\n            if (metadataEntry.type !== assembly.ArtifactMetadataEntryType.STACK_TAGS || !metadataEntry.data) { return metadataEntry; }\n            return {\n              ...metadataEntry,\n              data: fn(metadataEntry.data as assembly.StackTagsMetadataEntry),\n            };\n          })),\n        } as assembly.ArtifactManifest);\n      }),\n    });\n  }\n\n  private constructor() {}\n}\n\ntype Endofunctor<A> = (x: A) => A;\n\nfunction mapValues<A, B>(xs: Record<string, A> | undefined, fn: (x: A) => B): Record<string, B> | undefined {\n  if (!xs) { return undefined; }\n  const ret: Record<string, B> | undefined = {};\n  for (const [k, v] of Object.entries(xs)) {\n    ret[k] = fn(v);\n  }\n  return ret;\n}\n\nfunction noUndefined<A extends object>(xs: A): A {\n  const ret: any = {};\n  for (const [k, v] of Object.entries(xs)) {\n    if (v !== undefined) {\n      ret[k] = v;\n    }\n  }\n  return ret;\n}"],
  "mappings": "wOAAA,GAAA,QAAA,MACA,WAAA,QAAA,cACA,OAAA,QAAA,UAEA,SAAA,QAAA,oBAQa,QAAA,iBAA2B,yCAExC,KAAM,eAAgB,QAAQ,gCAExB,gBAAkB,QAAQ,wCAK1B,eAAiB,QAAQ,yCAAyC,QAKxE,cAAqB,CA0KnB,aAAA,QAnKc,sBAAqB,SAAqC,SAAgB,sFACtF,SAAS,aAAa,SAAU,SAAU,gBAAiB,SAAS,6BAQxD,sBAAqB,SAAgB,CACjD,MAAO,UAAS,aAAa,SAAU,gBAAiB,SAAS,4BASrD,mBAAkB,SAAgC,SAAgB,mFAC9E,SAAS,aAAa,SAAU,SAAU,cAAe,SAAS,4BAQtD,mBAAkB,SAAgB,CAC9C,MAAO,MAAK,aAAa,SAAU,qBAMvB,UAAO,CACnB,MAAO,sBAOK,MAAK,SAAqC,SAAgB,CAAI,MAAO,MAAK,qBAAqB,SAAU,gBAMzG,MAAK,SAAgB,CAA+B,MAAO,MAAK,qBAAqB,gBAEpF,UAAS,SAA+B,OAAyB,CAE9E,sBAAsB,QAAe,CACnC,KAAM,KAAM,OAAO,MAAM,SACzB,GAAI,CAAC,IACH,KAAM,IAAI,OAAM,2BAA2B,YAE7C,MAAO,KAGT,KAAM,cAAe,aAAa,SAAS,WACrC,OAAS,aAAa,SAAS,SAGrC,GAAI,OAAO,GAAG,OAAQ,cAGpB,KAAM,IAAI,OAAM,GAAG,QAAA,yDAAyD,2BAA2B,UAKzG,KAAM,QAAS,AADG,GAAI,YAAW,YACR,SAAS,SAAU,OAAQ,CAGlD,aAAc,GAEd,uBAAwB,KAG1B,GAAI,CAAC,OAAO,MACV,KAAM,IAAI,OAAM;EAA+B,gBAKpC,cAAa,SAAe,SAAkB,OAA2B,WAA8B,CACpH,GAAI,aAAc,IAAK,SAAU,QAAS,SAAS,WACnD,SAAS,SAAS,YAAa,QAC3B,YACF,aAAc,WAAW,cAE3B,GAAG,cAAc,SAAU,KAAK,UAAU,YAAa,OAAW,UAGrD,cAAa,SAAkB,OAA2B,WAA8B,CACrG,GAAI,KAAM,KAAK,MAAM,GAAG,aAAa,SAAU,CAAE,SAAU,WAC3D,MAAI,aACF,KAAM,WAAW,MAEnB,SAAS,SAAS,IAAK,QAChB,UAkBM,sBAAqB,SAAmC,CACrE,MAAO,UAAS,iBAAiB,SAAU,MAAQ,KAAK,IAAI,AAAC,SAAkB,EAC7E,IAAK,QAAQ,IACb,MAAO,QAAQ,gBASJ,uBAAsB,SAAmC,CACtE,MAAO,UAAS,iBAAiB,SAAU,MAAQ,KAAK,IAAI,QAEzD,OAAS,QAAS,OAAS,CAAE,IAAK,OAAO,IAAK,MAAO,OAAO,eAOlD,kBAAiB,SAAqC,GAAgD,CAGnH,MAAO,aAAY,IACd,SACH,UAAW,UAAU,SAAS,UAAW,UACnC,SAAS,OAAS,SAAS,aAAa,yBAAmC,SACxE,YAAY,IACd,SACH,SAAU,UAAU,SAAS,SAAU,iBAAmB,gBAAgB,IAAI,eACxE,cAAc,OAAS,SAAS,0BAA0B,YAAc,CAAC,cAAc,KAAe,cACnG,IACF,cACH,KAAM,GAAG,cAAc,eAlKrC,QAAA,SAAA,gHA+KA,mBAAyB,GAAmC,GAAe,CACzE,GAAI,CAAC,GAAM,OACX,KAAM,KAAqC,GAC3C,SAAW,CAAC,EAAG,IAAM,QAAO,QAAQ,IAClC,IAAI,GAAK,GAAG,GAEd,MAAO,KAGT,qBAAuC,GAAK,CAC1C,KAAM,KAAW,GACjB,SAAW,CAAC,EAAG,IAAM,QAAO,QAAQ,IAClC,AAAI,IAAM,QACR,KAAI,GAAK,GAGb,MAAO",
  "names": []
}
