{
  "version": 3,
  "sources": ["shared-interfaces.ts"],
  "sourcesContent": ["import * as cdk from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnVirtualGateway, CfnVirtualNode } from './appmesh.generated';\nimport { renderTlsClientPolicy } from './private/utils';\nimport { TlsClientPolicy } from './tls-client-policy';\nimport { IVirtualService } from './virtual-service';\n\n/**\n * Represents timeouts for HTTP protocols.\n */\nexport interface HttpTimeout {\n  /**\n   * Represents an idle timeout. The amount of time that a connection may be idle.\n   *\n   * @default - none\n   */\n  readonly idle?: cdk.Duration;\n\n  /**\n   * Represents per request timeout.\n   *\n   * @default - 15 s\n   */\n  readonly perRequest?: cdk.Duration;\n}\n\n/**\n * Represents timeouts for GRPC protocols.\n */\nexport interface GrpcTimeout {\n  /**\n   * Represents an idle timeout. The amount of time that a connection may be idle.\n   *\n   * @default - none\n   */\n  readonly idle?: cdk.Duration;\n\n  /**\n   * Represents per request timeout.\n   *\n   * @default - 15 s\n   */\n  readonly perRequest?: cdk.Duration;\n}\n\n/**\n * Represents timeouts for TCP protocols.\n */\nexport interface TcpTimeout {\n  /**\n   * Represents an idle timeout. The amount of time that a connection may be idle.\n   *\n   * @default - none\n   */\n  readonly idle?: cdk.Duration;\n}\n\n/**\n * Enum of supported AppMesh protocols\n *\n * @deprecated not for use outside package\n */\nexport enum Protocol {\n  HTTP = 'http',\n  TCP = 'tcp',\n  HTTP2 = 'http2',\n  GRPC = 'grpc',\n}\n\n/**\n * Represents the outlier detection for a listener.\n */\nexport interface OutlierDetection {\n  /**\n   * The base amount of time for which a host is ejected.\n   */\n  readonly baseEjectionDuration: cdk.Duration;\n\n  /**\n   * The time interval between ejection sweep analysis.\n   */\n  readonly interval: cdk.Duration;\n\n  /**\n   * Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at\n   * least one host regardless of the value.\n   */\n  readonly maxEjectionPercent: number;\n\n  /**\n   * Number of consecutive 5xx errors required for ejection.\n   */\n  readonly maxServerErrors: number;\n}\n\n/**\n * All Properties for Envoy Access logs for mesh endpoints\n */\nexport interface AccessLogConfig {\n\n  /**\n   * VirtualNode CFN configuration for Access Logging\n   *\n   * @default - no access logging\n   */\n  readonly virtualNodeAccessLog?: CfnVirtualNode.AccessLogProperty;\n\n  /**\n   * VirtualGateway CFN configuration for Access Logging\n   *\n   * @default - no access logging\n   */\n  readonly virtualGatewayAccessLog?: CfnVirtualGateway.VirtualGatewayAccessLogProperty;\n}\n\n/**\n * Configuration for Envoy Access logs for mesh endpoints\n */\nexport abstract class AccessLog {\n  /**\n   * Path to a file to write access logs to\n   *\n   * @default - no file based access logging\n   */\n  public static fromFilePath(filePath: string): AccessLog {\n    return new FileAccessLog(filePath);\n  }\n\n  /**\n   * Called when the AccessLog type is initialized. Can be used to enforce\n   * mutual exclusivity with future properties\n   */\n  public abstract bind(scope: Construct): AccessLogConfig;\n}\n\n/**\n * Configuration for Envoy Access logs for mesh endpoints\n */\nclass FileAccessLog extends AccessLog {\n  /**\n   * Path to a file to write access logs to\n   *\n   * @default - no file based access logging\n   */\n  public readonly filePath: string;\n\n  constructor(filePath: string) {\n    super();\n    this.filePath = filePath;\n  }\n\n  public bind(_scope: Construct): AccessLogConfig {\n    return {\n      virtualNodeAccessLog: {\n        file: {\n          path: this.filePath,\n        },\n      },\n      virtualGatewayAccessLog: {\n        file: {\n          path: this.filePath,\n        },\n      },\n    };\n  }\n}\n\n/**\n * Represents the properties needed to define backend defaults\n */\nexport interface BackendDefaults {\n  /**\n   * TLS properties for Client policy for backend defaults\n   *\n   * @default - none\n   */\n  readonly tlsClientPolicy?: TlsClientPolicy;\n}\n\n/**\n * Represents the properties needed to define a Virtual Service backend\n */\nexport interface VirtualServiceBackendOptions {\n\n  /**\n   * TLS properties for  Client policy for the backend\n   *\n   * @default - none\n   */\n  readonly tlsClientPolicy?: TlsClientPolicy;\n}\n\n/**\n * Properties for a backend\n */\nexport interface BackendConfig {\n  /**\n   * Config for a Virtual Service backend\n   */\n  readonly virtualServiceBackend: CfnVirtualNode.BackendProperty;\n}\n\n\n/**\n * Contains static factory methods to create backends\n */\nexport abstract class Backend {\n  /**\n   * Construct a Virtual Service backend\n   */\n  public static virtualService(virtualService: IVirtualService, props: VirtualServiceBackendOptions = {}): Backend {\n    return new VirtualServiceBackend(virtualService, props.tlsClientPolicy);\n  }\n\n  /**\n   * Return backend config\n   */\n  public abstract bind(_scope: Construct): BackendConfig;\n}\n\n/**\n * Represents the properties needed to define a Virtual Service backend\n */\nclass VirtualServiceBackend extends Backend {\n\n  constructor (private readonly virtualService: IVirtualService,\n    private readonly tlsClientPolicy: TlsClientPolicy | undefined) {\n    super();\n  }\n\n  /**\n   * Return config for a Virtual Service backend\n   */\n  public bind(scope: Construct): BackendConfig {\n    return {\n      virtualServiceBackend: {\n        virtualService: {\n          /**\n           * We want to use the name of the Virtual Service here directly instead of\n           * a `{ 'Fn::GetAtt' }` CFN expression. This avoids a circular dependency in\n           * the case where this Virtual Node is the Virtual Service's provider.\n           */\n          virtualServiceName: cdk.Token.isUnresolved(this.virtualService.virtualServiceName)\n            ? (this.virtualService as any).physicalName\n            : this.virtualService.virtualServiceName,\n          clientPolicy: this.tlsClientPolicy\n            ? {\n              tls: renderTlsClientPolicy(scope, this.tlsClientPolicy),\n            }\n            : undefined,\n        },\n      },\n    };\n  }\n}\n\n/**\n * Connection pool properties for HTTP listeners\n */\nexport interface HttpConnectionPool {\n  /**\n   * The maximum connections in the pool\n   *\n   * @default - none\n   */\n  readonly maxConnections: number;\n\n  /**\n   * The maximum pending requests in the pool\n   *\n   * @default - none\n   */\n  readonly maxPendingRequests: number;\n}\n\n/**\n * Connection pool properties for TCP listeners\n */\nexport interface TcpConnectionPool {\n  /**\n   * The maximum connections in the pool\n   *\n   * @default - none\n   */\n  readonly maxConnections: number;\n}\n\n/**\n * Connection pool properties for gRPC listeners\n */\nexport interface GrpcConnectionPool {\n  /**\n   * The maximum requests in the pool\n   *\n   * @default - none\n   */\n  readonly maxRequests: number;\n}\n\n/**\n * Connection pool properties for HTTP2 listeners\n */\nexport interface Http2ConnectionPool {\n  /**\n   * The maximum requests in the pool\n   *\n   * @default - none\n   */\n  readonly maxRequests: number;\n}"],
  "mappings": "oPAAA,IAAA,QAAA,cAGA,QAAA,QAAA,mBA2DA,GAAY,UAAZ,AAAA,UAAY,UAAQ,CAClB,UAAA,KAAA,OACA,UAAA,IAAA,MACA,UAAA,MAAA,QACA,UAAA,KAAA,SAJU,SAAA,QAAA,UAAA,SAAA,SAAQ,KAwDpB,eAA+B,OAMf,cAAa,SAAgB,CACzC,MAAO,IAAI,eAAc,WAP7B,QAAA,UAAA,yGAoBA,2BAA4B,UAAS,CAQnC,YAAY,SAAgB,CAC1B,QACA,KAAK,SAAW,SAGX,KAAK,OAAiB,CAC3B,MAAO,CACL,qBAAsB,CACpB,KAAM,CACJ,KAAM,KAAK,WAGf,wBAAyB,CACvB,KAAM,CACJ,KAAM,KAAK,aA8CrB,aAA6B,OAIb,gBAAe,eAAiC,MAAsC,GAAE,4KAC7F,GAAI,uBAAsB,eAAgB,MAAM,kBAL3D,QAAA,QAAA,mGAiBA,mCAAoC,QAAO,CAEzC,YAA8B,eACX,gBAA4C,CAC7D,QAF4B,KAAA,eAAA,eACX,KAAA,gBAAA,gBAOZ,KAAK,MAAgB,CAC1B,MAAO,CACL,sBAAuB,CACrB,eAAgB,CAMd,mBAAoB,IAAI,MAAM,aAAa,KAAK,eAAe,oBAC1D,KAAK,eAAuB,aAC7B,KAAK,eAAe,mBACxB,aAAc,KAAK,gBACf,CACA,IAAK,QAAA,sBAAsB,MAAO,KAAK,kBAEvC",
  "names": []
}
