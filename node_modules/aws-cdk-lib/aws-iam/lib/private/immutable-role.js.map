{
  "version": 3,
  "sources": ["immutable-role.ts"],
  "sourcesContent": ["import { Resource } from '../../../core';\nimport { Construct, Dependable, DependencyGroup } from 'constructs';\nimport { Grant } from '../grant';\nimport { IManagedPolicy } from '../managed-policy';\nimport { Policy } from '../policy';\nimport { PolicyStatement } from '../policy-statement';\nimport { AddToPrincipalPolicyResult, IPrincipal } from '../principals';\nimport { IRole } from '../role';\n\n/**\n * An immutable wrapper around an IRole\n *\n * This wrapper ignores all mutating operations, like attaching policies or\n * adding policy statements.\n *\n * Useful in cases where you want to turn off CDK's automatic permissions\n * management, and instead have full control over all permissions.\n *\n * Note: if you want to ignore all mutations for an externally defined role\n * which was imported into the CDK with {@link Role.fromRoleArn}, you don't have to use this class -\n * simply pass the property mutable = false when calling {@link Role.fromRoleArn}.\n */\nexport class ImmutableRole extends Resource implements IRole {\n  public readonly assumeRoleAction = this.role.assumeRoleAction;\n  public readonly policyFragment = this.role.policyFragment;\n  public readonly grantPrincipal = this;\n  public readonly principalAccount = this.role.principalAccount;\n  public readonly roleArn = this.role.roleArn;\n  public readonly roleName = this.role.roleName;\n  public readonly stack = this.role.stack;\n\n  constructor(scope: Construct, id: string, private readonly role: IRole, private readonly addGrantsToResources: boolean) {\n    super(scope, id, {\n      account: role.env.account,\n      region: role.env.region,\n    });\n\n    // implement IDependable privately\n    Dependable.implement(this, {\n      dependencyRoots: [role],\n    });\n  }\n\n  public attachInlinePolicy(_policy: Policy): void {\n    // do nothing\n  }\n\n  public addManagedPolicy(_policy: IManagedPolicy): void {\n    // do nothing\n  }\n\n  public addToPolicy(statement: PolicyStatement): boolean {\n    return this.addToPrincipalPolicy(statement).statementAdded;\n  }\n\n  public addToPrincipalPolicy(_statement: PolicyStatement): AddToPrincipalPolicyResult {\n    // If we return `false`, the grants will try to add the statement to the resource\n    // (if possible).\n    const pretendSuccess = !this.addGrantsToResources;\n    return { statementAdded: pretendSuccess, policyDependable: new DependencyGroup() };\n  }\n\n  public grant(grantee: IPrincipal, ...actions: string[]): Grant {\n    return this.role.grant(grantee, ...actions);\n  }\n\n  public grantPassRole(grantee: IPrincipal): Grant {\n    return this.role.grantPassRole(grantee);\n  }\n}\n"],
  "mappings": "iGAAA,KAAA,QAAA,QAAA,iBACA,aAAA,QAAA,cAqBA,2BAAmC,QAAA,QAAQ,CASzC,YAAY,MAAkB,GAA6B,KAA8B,qBAA6B,CACpH,MAAM,MAAO,GAAI,CACf,QAAS,KAAK,IAAI,QAClB,OAAQ,KAAK,IAAI,SAHsC,KAAA,KAAA,KAA8B,KAAA,qBAAA,qBARzE,KAAA,iBAAmB,KAAK,KAAK,iBAC7B,KAAA,eAAiB,KAAK,KAAK,eAC3B,KAAA,eAAiB,KACjB,KAAA,iBAAmB,KAAK,KAAK,iBAC7B,KAAA,QAAU,KAAK,KAAK,QACpB,KAAA,SAAW,KAAK,KAAK,SACrB,KAAA,MAAQ,KAAK,KAAK,MAShC,aAAA,WAAW,UAAU,KAAM,CACzB,gBAAiB,CAAC,QAIf,mBAAmB,QAAe,EAIlC,iBAAiB,QAAuB,EAIxC,YAAY,UAA0B,CAC3C,MAAO,MAAK,qBAAqB,WAAW,eAGvC,qBAAqB,WAA2B,CAIrD,MAAO,CAAE,eADc,CAAC,KAAK,qBACY,iBAAkB,GAAI,cAAA,iBAG1D,MAAM,WAAwB,QAAiB,CACpD,MAAO,MAAK,KAAK,MAAM,QAAS,GAAG,SAG9B,cAAc,QAAmB,CACtC,MAAO,MAAK,KAAK,cAAc,UA7CnC,QAAA,cAAA",
  "names": []
}
