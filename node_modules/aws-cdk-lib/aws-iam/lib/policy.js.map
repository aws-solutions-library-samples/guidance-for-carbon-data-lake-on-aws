{
  "version": 3,
  "sources": ["policy.ts"],
  "sourcesContent": ["import { IResource, Lazy, Resource } from '../../core';\nimport { Construct } from 'constructs';\nimport { IGroup } from './group';\nimport { CfnPolicy } from './iam.generated';\nimport { PolicyDocument } from './policy-document';\nimport { PolicyStatement } from './policy-statement';\nimport { IRole } from './role';\nimport { IUser } from './user';\nimport { generatePolicyName, undefinedIfEmpty } from './util';\n\n/**\n * Represents an IAM Policy\n *\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage.html\n */\nexport interface IPolicy extends IResource {\n  /**\n   * The name of this policy.\n   *\n   * @attribute\n   */\n  readonly policyName: string;\n}\n\n/**\n * Properties for defining an IAM inline policy document\n */\nexport interface PolicyProps {\n  /**\n   * The name of the policy. If you specify multiple policies for an entity,\n   * specify unique names. For example, if you specify a list of policies for\n   * an IAM role, each policy must have a unique name.\n   *\n   * @default - Uses the logical ID of the policy resource, which is ensured\n   * to be unique within the stack.\n   */\n  readonly policyName?: string;\n\n  /**\n   * Users to attach this policy to.\n   * You can also use `attachToUser(user)` to attach this policy to a user.\n   *\n   * @default - No users.\n   */\n  readonly users?: IUser[];\n\n  /**\n   * Roles to attach this policy to.\n   * You can also use `attachToRole(role)` to attach this policy to a role.\n   *\n   * @default - No roles.\n   */\n  readonly roles?: IRole[];\n\n  /**\n   * Groups to attach this policy to.\n   * You can also use `attachToGroup(group)` to attach this policy to a group.\n   *\n   * @default - No groups.\n   */\n  readonly groups?: IGroup[];\n\n  /**\n   * Initial set of permissions to add to this policy document.\n   * You can also use `addStatements(...statement)` to add permissions later.\n   *\n   * @default - No statements.\n   */\n  readonly statements?: PolicyStatement[];\n\n  /**\n   * Force creation of an `AWS::IAM::Policy`\n   *\n   * Unless set to `true`, this `Policy` construct will not materialize to an\n   * `AWS::IAM::Policy` CloudFormation resource in case it would have no effect\n   * (for example, if it remains unattached to an IAM identity or if it has no\n   * statements). This is generally desired behavior, since it prevents\n   * creating invalid--and hence undeployable--CloudFormation templates.\n   *\n   * In cases where you know the policy must be created and it is actually\n   * an error if no statements have been added to it, you can set this to `true`.\n   *\n   * @default false\n   */\n  readonly force?: boolean;\n\n  /**\n   * Initial PolicyDocument to use for this Policy. If omited, any\n   * `PolicyStatement` provided in the `statements` property will be applied\n   * against the empty default `PolicyDocument`.\n   *\n   * @default - An empty policy.\n   */\n  readonly document?: PolicyDocument;\n}\n\n/**\n * The AWS::IAM::Policy resource associates an IAM policy with IAM users, roles,\n * or groups. For more information about IAM policies, see [Overview of IAM\n * Policies](http://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html)\n * in the IAM User Guide guide.\n */\nexport class Policy extends Resource implements IPolicy {\n\n  /**\n   * Import a policy in this app based on its name\n   */\n  public static fromPolicyName(scope: Construct, id: string, policyName: string): IPolicy {\n    class Import extends Resource implements IPolicy {\n      public readonly policyName = policyName;\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * The policy document.\n   */\n  public readonly document = new PolicyDocument();\n\n  private readonly _policyName: string;\n  private readonly roles = new Array<IRole>();\n  private readonly users = new Array<IUser>();\n  private readonly groups = new Array<IGroup>();\n  private readonly force: boolean;\n  private referenceTaken = false;\n\n  constructor(scope: Construct, id: string, props: PolicyProps = {}) {\n    super(scope, id, {\n      physicalName: props.policyName ||\n        // generatePolicyName will take the last 128 characters of the logical id since\n        // policy names are limited to 128. the last 8 chars are a stack-unique hash, so\n        // that shouod be sufficient to ensure uniqueness within a principal.\n        Lazy.string({ produce: () => generatePolicyName(scope, resource.logicalId) }),\n    });\n\n    const self = this;\n\n    class CfnPolicyConditional extends CfnPolicy {\n      /**\n       * This function returns `true` if the CFN resource should be included in\n       * the cloudformation template unless `force` is `true`, if the policy\n       * document is empty, the resource will not be included.\n       */\n      protected shouldSynthesize() {\n        return self.force || self.referenceTaken || (!self.document.isEmpty && self.isAttached);\n      }\n    }\n\n    if (props.document) {\n      this.document = props.document;\n    }\n\n    const resource = new CfnPolicyConditional(this, 'Resource', {\n      policyDocument: this.document,\n      policyName: this.physicalName,\n      roles: undefinedIfEmpty(() => this.roles.map(r => r.roleName)),\n      users: undefinedIfEmpty(() => this.users.map(u => u.userName)),\n      groups: undefinedIfEmpty(() => this.groups.map(g => g.groupName)),\n    });\n\n    this._policyName = this.physicalName!;\n    this.force = props.force ?? false;\n\n    if (props.users) {\n      props.users.forEach(u => this.attachToUser(u));\n    }\n\n    if (props.groups) {\n      props.groups.forEach(g => this.attachToGroup(g));\n    }\n\n    if (props.roles) {\n      props.roles.forEach(r => this.attachToRole(r));\n    }\n\n    if (props.statements) {\n      props.statements.forEach(p => this.addStatements(p));\n    }\n\n    this.node.addValidation({ validate: () => this.validatePolicy() });\n  }\n\n  /**\n   * Adds a statement to the policy document.\n   */\n  public addStatements(...statement: PolicyStatement[]) {\n    this.document.addStatements(...statement);\n  }\n\n  /**\n   * Attaches this policy to a user.\n   */\n  public attachToUser(user: IUser) {\n    if (this.users.find(u => u === user)) { return; }\n    this.users.push(user);\n    user.attachInlinePolicy(this);\n  }\n\n  /**\n   * Attaches this policy to a role.\n   */\n  public attachToRole(role: IRole) {\n    if (this.roles.find(r => r === role)) { return; }\n    this.roles.push(role);\n    role.attachInlinePolicy(this);\n  }\n\n  /**\n   * Attaches this policy to a group.\n   */\n  public attachToGroup(group: IGroup) {\n    if (this.groups.find(g => g === group)) { return; }\n    this.groups.push(group);\n    group.attachInlinePolicy(this);\n  }\n\n  /**\n   * The name of this policy.\n   *\n   * @attribute\n   */\n  public get policyName(): string {\n    this.referenceTaken = true;\n    return this._policyName;\n  }\n\n  private validatePolicy(): string[] {\n    const result = new Array<string>();\n\n    // validate that the policy document is not empty\n    if (this.document.isEmpty) {\n      if (this.force) {\n        result.push('Policy created with force=true is empty. You must add statements to the policy');\n      }\n      if (!this.force && this.referenceTaken) {\n        result.push('This Policy has been referenced by a resource, so it must contain at least one statement.');\n      }\n    }\n\n    // validate that the policy is attached to at least one principal (role, user or group).\n    if (!this.isAttached) {\n      if (this.force) {\n        result.push('Policy created with force=true must be attached to at least one principal: user, group or role');\n      }\n      if (!this.force && this.referenceTaken) {\n        result.push('This Policy has been referenced by a resource, so it must be attached to at least one user, group or role.');\n      }\n    }\n\n    result.push(...this.document.validateForIdentityPolicy());\n\n    return result;\n  }\n\n  /**\n   * Whether the policy resource has been attached to any identity\n   */\n  private get isAttached() {\n    return this.groups.length + this.users.length + this.roles.length > 0;\n  }\n}\n"],
  "mappings": "6MAAA,OAAA,QAAA,cAGA,gBAAA,QAAA,mBACA,kBAAA,QAAA,qBAIA,OAAA,QAAA,UA8FA,oBAA4B,QAAA,QAAQ,CAyBlC,YAAY,MAAkB,GAAY,MAAqB,GAAE,QAC/D,MAAM,MAAO,GAAI,CACf,aAAc,MAAM,YAIlB,OAAA,KAAK,OAAO,CAAE,QAAS,IAAM,OAAA,mBAAmB,MAAO,SAAS,eAftD,KAAA,SAAW,GAAI,mBAAA,eAGd,KAAA,MAAQ,GAAI,OACZ,KAAA,MAAQ,GAAI,OACZ,KAAA,OAAS,GAAI,OAEtB,KAAA,eAAiB,kEAWvB,KAAM,MAAO,KAEb,kCAAmC,iBAAA,SAAS,CAMhC,kBAAgB,CACxB,MAAO,MAAK,OAAS,KAAK,gBAAmB,CAAC,KAAK,SAAS,SAAW,KAAK,YAIhF,AAAI,MAAM,UACR,MAAK,SAAW,MAAM,UAGxB,KAAM,UAAW,GAAI,sBAAqB,KAAM,WAAY,CAC1D,eAAgB,KAAK,SACrB,WAAY,KAAK,aACjB,MAAO,OAAA,iBAAiB,IAAM,KAAK,MAAM,IAAI,GAAK,EAAE,WACpD,MAAO,OAAA,iBAAiB,IAAM,KAAK,MAAM,IAAI,GAAK,EAAE,WACpD,OAAQ,OAAA,iBAAiB,IAAM,KAAK,OAAO,IAAI,GAAK,EAAE,cAGxD,KAAK,YAAc,KAAK,aACxB,KAAK,MAAK,IAAG,MAAM,SAAK,MAAA,KAAA,OAAA,GAAI,GAExB,MAAM,OACR,MAAM,MAAM,QAAQ,GAAK,KAAK,aAAa,IAGzC,MAAM,QACR,MAAM,OAAO,QAAQ,GAAK,KAAK,cAAc,IAG3C,MAAM,OACR,MAAM,MAAM,QAAQ,GAAK,KAAK,aAAa,IAGzC,MAAM,YACR,MAAM,WAAW,QAAQ,GAAK,KAAK,cAAc,IAGnD,KAAK,KAAK,cAAc,CAAE,SAAU,IAAM,KAAK,yBAzEnC,gBAAe,MAAkB,GAAY,WAAkB,CAC3E,oBAAqB,QAAA,QAAQ,CAA7B,aAAA,qBACkB,KAAA,WAAa,YAG/B,MAAO,IAAI,QAAO,MAAO,IA0EpB,iBAAiB,UAA4B,wEAClD,KAAK,SAAS,cAAc,GAAG,WAM1B,aAAa,KAAW,CAC7B,wDAAI,MAAK,MAAM,KAAK,GAAK,IAAM,OAC/B,MAAK,MAAM,KAAK,MAChB,KAAK,mBAAmB,OAMnB,aAAa,KAAW,CAC7B,wDAAI,MAAK,MAAM,KAAK,GAAK,IAAM,OAC/B,MAAK,MAAM,KAAK,MAChB,KAAK,mBAAmB,OAMnB,cAAc,MAAa,CAChC,0DAAI,MAAK,OAAO,KAAK,GAAK,IAAM,QAChC,MAAK,OAAO,KAAK,OACjB,MAAM,mBAAmB,UAQhB,aAAU,CACnB,YAAK,eAAiB,GACf,KAAK,YAGN,gBAAc,CACpB,KAAM,QAAS,GAAI,OAGnB,MAAI,MAAK,SAAS,SACZ,MAAK,OACP,OAAO,KAAK,kFAEV,CAAC,KAAK,OAAS,KAAK,gBACtB,OAAO,KAAK,8FAKX,KAAK,YACJ,MAAK,OACP,OAAO,KAAK,kGAEV,CAAC,KAAK,OAAS,KAAK,gBACtB,OAAO,KAAK,+GAIhB,OAAO,KAAK,GAAG,KAAK,SAAS,6BAEtB,UAMG,aAAU,CACpB,MAAO,MAAK,OAAO,OAAS,KAAK,MAAM,OAAS,KAAK,MAAM,OAAS,GA7JxE,QAAA,OAAA",
  "names": []
}
