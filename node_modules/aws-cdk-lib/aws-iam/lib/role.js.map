{
  "version": 3,
  "sources": ["role.ts"],
  "sourcesContent": ["import { ArnFormat, Duration, Resource, Stack, Token, TokenComparison } from '../../core';\nimport { Construct, Node } from 'constructs';\nimport { Grant } from './grant';\nimport { CfnRole } from './iam.generated';\nimport { IIdentity } from './identity-base';\nimport { IManagedPolicy } from './managed-policy';\nimport { Policy } from './policy';\nimport { PolicyDocument } from './policy-document';\nimport { PolicyStatement } from './policy-statement';\nimport { AddToPrincipalPolicyResult, ArnPrincipal, IPrincipal, PrincipalPolicyFragment } from './principals';\nimport { defaultAddPrincipalToAssumeRole } from './private/assume-role-policy';\nimport { ImmutableRole } from './private/immutable-role';\nimport { MutatingPolicyDocumentAdapter } from './private/policydoc-adapter';\nimport { AttachedPolicies, UniqueStringSet } from './util';\n\n/**\n * Properties for defining an IAM Role\n */\nexport interface RoleProps {\n  /**\n   * The IAM principal (i.e. `new ServicePrincipal('sns.amazonaws.com')`)\n   * which can assume this role.\n   *\n   * You can later modify the assume role policy document by accessing it via\n   * the `assumeRolePolicy` property.\n   */\n  readonly assumedBy: IPrincipal;\n\n  /**\n   * ID that the role assumer needs to provide when assuming this role\n   *\n   * If the configured and provided external IDs do not match, the\n   * AssumeRole operation will fail.\n   *\n   * @deprecated see {@link externalIds}\n   *\n   * @default No external ID required\n   */\n  readonly externalId?: string;\n\n  /**\n   * List of IDs that the role assumer needs to provide one of when assuming this role\n   *\n   * If the configured and provided external IDs do not match, the\n   * AssumeRole operation will fail.\n   *\n   * @default No external ID required\n   */\n  readonly externalIds?: string[];\n\n  /**\n   * A list of managed policies associated with this role.\n   *\n   * You can add managed policies later using\n   * `addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(policyName))`.\n   *\n   * @default - No managed policies.\n   */\n  readonly managedPolicies?: IManagedPolicy[];\n\n  /**\n   * A list of named policies to inline into this role. These policies will be\n   * created with the role, whereas those added by ``addToPolicy`` are added\n   * using a separate CloudFormation resource (allowing a way around circular\n   * dependencies that could otherwise be introduced).\n   *\n   * @default - No policy is inlined in the Role resource.\n   */\n  readonly inlinePolicies?: { [name: string]: PolicyDocument };\n\n  /**\n   * The path associated with this role. For information about IAM paths, see\n   * Friendly Names and Paths in IAM User Guide.\n   *\n   * @default /\n   */\n  readonly path?: string;\n\n  /**\n   * AWS supports permissions boundaries for IAM entities (users or roles).\n   * A permissions boundary is an advanced feature for using a managed policy\n   * to set the maximum permissions that an identity-based policy can grant to\n   * an IAM entity. An entity's permissions boundary allows it to perform only\n   * the actions that are allowed by both its identity-based policies and its\n   * permissions boundaries.\n   *\n   * @link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#cfn-iam-role-permissionsboundary\n   * @link https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html\n   *\n   * @default - No permissions boundary.\n   */\n  readonly permissionsBoundary?: IManagedPolicy;\n\n  /**\n   * A name for the IAM role. For valid values, see the RoleName parameter for\n   * the CreateRole action in the IAM API Reference.\n   *\n   * IMPORTANT: If you specify a name, you cannot perform updates that require\n   * replacement of this resource. You can perform updates that require no or\n   * some interruption. If you must replace the resource, specify a new name.\n   *\n   * If you specify a name, you must specify the CAPABILITY_NAMED_IAM value to\n   * acknowledge your template's capabilities. For more information, see\n   * Acknowledging IAM Resources in AWS CloudFormation Templates.\n   *\n   * @default - AWS CloudFormation generates a unique physical ID and uses that ID\n   * for the role name.\n   */\n  readonly roleName?: string;\n\n  /**\n   * The maximum session duration that you want to set for the specified role.\n   * This setting can have a value from 1 hour (3600sec) to 12 (43200sec) hours.\n   *\n   * Anyone who assumes the role from the AWS CLI or API can use the\n   * DurationSeconds API parameter or the duration-seconds CLI parameter to\n   * request a longer session. The MaxSessionDuration setting determines the\n   * maximum duration that can be requested using the DurationSeconds\n   * parameter.\n   *\n   * If users don't specify a value for the DurationSeconds parameter, their\n   * security credentials are valid for one hour by default. This applies when\n   * you use the AssumeRole* API operations or the assume-role* CLI operations\n   * but does not apply when you use those operations to create a console URL.\n   *\n   * @link https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html\n   *\n   * @default Duration.hours(1)\n   */\n  readonly maxSessionDuration?: Duration;\n\n  /**\n   * A description of the role. It can be up to 1000 characters long.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n}\n\n/**\n * Options allowing customizing the behavior of {@link Role.fromRoleArn}.\n */\nexport interface FromRoleArnOptions {\n  /**\n   * Whether the imported role can be modified by attaching policy resources to it.\n   *\n   * @default true\n   */\n  readonly mutable?: boolean;\n\n  /**\n   * For immutable roles: add grants to resources instead of dropping them\n   *\n   * If this is `false` or not specified, grant permissions added to this role are ignored.\n   * It is your own responsibility to make sure the role has the required permissions.\n   *\n   * If this is `true`, any grant permissions will be added to the resource instead.\n   *\n   * @default false\n   */\n  readonly addGrantsToResources?: boolean;\n}\n\n/**\n * IAM Role\n *\n * Defines an IAM role. The role is created with an assume policy document associated with\n * the specified AWS service principal defined in `serviceAssumeRole`.\n */\nexport class Role extends Resource implements IRole {\n  /**\n   * Import an external role by ARN.\n   *\n   * If the imported Role ARN is a Token (such as a\n   * `CfnParameter.valueAsString` or a `Fn.importValue()`) *and* the referenced\n   * role has a `path` (like `arn:...:role/AdminRoles/Alice`), the\n   * `roleName` property will not resolve to the correct value. Instead it\n   * will resolve to the first path component. We unfortunately cannot express\n   * the correct calculation of the full path name as a CloudFormation\n   * expression. In this scenario the Role ARN should be supplied without the\n   * `path` in order to resolve the correct role resource.\n   *\n   * @param scope construct scope\n   * @param id construct id\n   * @param roleArn the ARN of the role to import\n   * @param options allow customizing the behavior of the returned role\n   */\n  public static fromRoleArn(scope: Construct, id: string, roleArn: string, options: FromRoleArnOptions = {}): IRole {\n    const scopeStack = Stack.of(scope);\n    const parsedArn = scopeStack.splitArn(roleArn, ArnFormat.SLASH_RESOURCE_NAME);\n    const resourceName = parsedArn.resourceName!;\n    const roleAccount = parsedArn.account;\n    // service roles have an ARN like 'arn:aws:iam::<account>:role/service-role/<roleName>'\n    // or 'arn:aws:iam::<account>:role/service-role/servicename.amazonaws.com/service-role/<roleName>'\n    // we want to support these as well, so we just use the element after the last slash as role name\n    const roleName = resourceName.split('/').pop()!;\n\n    class Import extends Resource implements IRole {\n      public readonly grantPrincipal: IPrincipal = this;\n      public readonly principalAccount = roleAccount;\n      public readonly assumeRoleAction: string = 'sts:AssumeRole';\n      public readonly policyFragment = new ArnPrincipal(roleArn).policyFragment;\n      public readonly roleArn = roleArn;\n      public readonly roleName = roleName;\n      private readonly attachedPolicies = new AttachedPolicies();\n      private defaultPolicy?: Policy;\n\n      constructor(_scope: Construct, _id: string) {\n        super(_scope, _id, {\n          account: roleAccount,\n        });\n      }\n\n      public addToPolicy(statement: PolicyStatement): boolean {\n        return this.addToPrincipalPolicy(statement).statementAdded;\n      }\n\n      public addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult {\n        if (!this.defaultPolicy) {\n          this.defaultPolicy = new Policy(this, 'Policy');\n          this.attachInlinePolicy(this.defaultPolicy);\n        }\n        this.defaultPolicy.addStatements(statement);\n        return { statementAdded: true, policyDependable: this.defaultPolicy };\n      }\n\n      public attachInlinePolicy(policy: Policy): void {\n        const thisAndPolicyAccountComparison = Token.compareStrings(this.env.account, policy.env.account);\n        const equalOrAnyUnresolved = thisAndPolicyAccountComparison === TokenComparison.SAME ||\n          thisAndPolicyAccountComparison === TokenComparison.BOTH_UNRESOLVED ||\n          thisAndPolicyAccountComparison === TokenComparison.ONE_UNRESOLVED;\n        if (equalOrAnyUnresolved) {\n          this.attachedPolicies.attach(policy);\n          policy.attachToRole(this);\n        }\n      }\n\n      public addManagedPolicy(_policy: IManagedPolicy): void {\n        // FIXME: Add warning that we're ignoring this\n      }\n\n      /**\n       * Grant permissions to the given principal to pass this role.\n       */\n      public grantPassRole(identity: IPrincipal): Grant {\n        return this.grant(identity, 'iam:PassRole');\n      }\n\n      /**\n       * Grant the actions defined in actions to the identity Principal on this resource.\n       */\n      public grant(grantee: IPrincipal, ...actions: string[]): Grant {\n        return Grant.addToPrincipal({\n          grantee,\n          actions,\n          resourceArns: [this.roleArn],\n          scope: this,\n        });\n      }\n    }\n\n    if (options.addGrantsToResources !== undefined && options.mutable !== false) {\n      throw new Error('\\'addGrantsToResources\\' can only be passed if \\'mutable: false\\'');\n    }\n\n    const importedRole = new Import(scope, id);\n    const roleArnAndScopeStackAccountComparison = Token.compareStrings(importedRole.env.account, scopeStack.account);\n    const equalOrAnyUnresolved = roleArnAndScopeStackAccountComparison === TokenComparison.SAME ||\n      roleArnAndScopeStackAccountComparison === TokenComparison.BOTH_UNRESOLVED ||\n      roleArnAndScopeStackAccountComparison === TokenComparison.ONE_UNRESOLVED;\n    // we only return an immutable Role if both accounts were explicitly provided, and different\n    return options.mutable !== false && equalOrAnyUnresolved\n      ? importedRole\n      : new ImmutableRole(scope, `ImmutableRole${id}`, importedRole, options.addGrantsToResources ?? false);\n  }\n\n  /**\n   * Import an external role by name.\n   *\n   * The imported role is assumed to exist in the same account as the account\n   * the scope's containing Stack is being deployed to.\n   */\n  public static fromRoleName(scope: Construct, id: string, roleName: string) {\n    return Role.fromRoleArn(scope, id, Stack.of(scope).formatArn({\n      region: '',\n      service: 'iam',\n      resource: 'role',\n      resourceName: roleName,\n    }));\n  }\n\n  public readonly grantPrincipal: IPrincipal = this;\n  public readonly principalAccount: string | undefined = this.env.account;\n\n  public readonly assumeRoleAction: string = 'sts:AssumeRole';\n\n  /**\n   * The assume role policy document associated with this role.\n   */\n  public readonly assumeRolePolicy?: PolicyDocument;\n\n  /**\n   * Returns the ARN of this role.\n   */\n  public readonly roleArn: string;\n\n  /**\n   * Returns the stable and unique string identifying the role. For example,\n   * AIDAJQABLZS4A3QDU576Q.\n   *\n   * @attribute\n   */\n  public readonly roleId: string;\n\n  /**\n   * Returns the name of the role.\n   */\n  public readonly roleName: string;\n\n  /**\n   * Returns the role.\n   */\n  public readonly policyFragment: PrincipalPolicyFragment;\n\n  /**\n   * Returns the permissions boundary attached to this role\n   */\n  public readonly permissionsBoundary?: IManagedPolicy;\n\n  private defaultPolicy?: Policy;\n  private readonly managedPolicies: IManagedPolicy[] = [];\n  private readonly attachedPolicies = new AttachedPolicies();\n  private readonly inlinePolicies: { [name: string]: PolicyDocument };\n  private immutableRole?: IRole;\n\n  constructor(scope: Construct, id: string, props: RoleProps) {\n    super(scope, id, {\n      physicalName: props.roleName,\n    });\n\n    const externalIds = props.externalIds || [];\n    if (props.externalId) {\n      externalIds.push(props.externalId);\n    }\n\n    this.assumeRolePolicy = createAssumeRolePolicy(props.assumedBy, externalIds);\n    this.managedPolicies.push(...props.managedPolicies || []);\n    this.inlinePolicies = props.inlinePolicies || {};\n    this.permissionsBoundary = props.permissionsBoundary;\n    const maxSessionDuration = props.maxSessionDuration && props.maxSessionDuration.toSeconds();\n    validateMaxSessionDuration(maxSessionDuration);\n    const description = (props.description && props.description?.length > 0) ? props.description : undefined;\n\n    if (description && description.length > 1000) {\n      throw new Error('Role description must be no longer than 1000 characters.');\n    }\n\n    const role = new CfnRole(this, 'Resource', {\n      assumeRolePolicyDocument: this.assumeRolePolicy as any,\n      managedPolicyArns: UniqueStringSet.from(() => this.managedPolicies.map(p => p.managedPolicyArn)),\n      policies: _flatten(this.inlinePolicies),\n      path: props.path,\n      permissionsBoundary: this.permissionsBoundary ? this.permissionsBoundary.managedPolicyArn : undefined,\n      roleName: this.physicalName,\n      maxSessionDuration,\n      description,\n    });\n\n    this.roleId = role.attrRoleId;\n    this.roleArn = this.getResourceArnAttribute(role.attrArn, {\n      region: '', // IAM is global in each partition\n      service: 'iam',\n      resource: 'role',\n      resourceName: this.physicalName,\n    });\n    this.roleName = this.getResourceNameAttribute(role.ref);\n    this.policyFragment = new ArnPrincipal(this.roleArn).policyFragment;\n\n    function _flatten(policies?: { [name: string]: PolicyDocument }) {\n      if (policies == null || Object.keys(policies).length === 0) {\n        return undefined;\n      }\n      const result = new Array<CfnRole.PolicyProperty>();\n      for (const policyName of Object.keys(policies)) {\n        const policyDocument = policies[policyName];\n        result.push({ policyName, policyDocument });\n      }\n      return result;\n    }\n\n    this.node.addValidation({ validate: () => this.validateRole() });\n  }\n\n  /**\n   * Adds a permission to the role's default policy document.\n   * If there is no default policy attached to this role, it will be created.\n   * @param statement The permission statement to add to the policy document\n   */\n  public addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult {\n    if (!this.defaultPolicy) {\n      this.defaultPolicy = new Policy(this, 'DefaultPolicy');\n      this.attachInlinePolicy(this.defaultPolicy);\n    }\n    this.defaultPolicy.addStatements(statement);\n    return { statementAdded: true, policyDependable: this.defaultPolicy };\n  }\n\n  public addToPolicy(statement: PolicyStatement): boolean {\n    return this.addToPrincipalPolicy(statement).statementAdded;\n  }\n\n  /**\n   * Attaches a managed policy to this role.\n   * @param policy The the managed policy to attach.\n   */\n  public addManagedPolicy(policy: IManagedPolicy) {\n    if (this.managedPolicies.find(mp => mp === policy)) { return; }\n    this.managedPolicies.push(policy);\n  }\n\n  /**\n   * Attaches a policy to this role.\n   * @param policy The policy to attach\n   */\n  public attachInlinePolicy(policy: Policy) {\n    this.attachedPolicies.attach(policy);\n    policy.attachToRole(this);\n  }\n\n  /**\n   * Grant the actions defined in actions to the identity Principal on this resource.\n   */\n  public grant(grantee: IPrincipal, ...actions: string[]) {\n    return Grant.addToPrincipal({\n      grantee,\n      actions,\n      resourceArns: [this.roleArn],\n      scope: this,\n    });\n  }\n\n  /**\n   * Grant permissions to the given principal to pass this role.\n   */\n  public grantPassRole(identity: IPrincipal) {\n    return this.grant(identity, 'iam:PassRole');\n  }\n\n  /**\n   * Return a copy of this Role object whose Policies will not be updated\n   *\n   * Use the object returned by this method if you want this Role to be used by\n   * a construct without it automatically updating the Role's Policies.\n   *\n   * If you do, you are responsible for adding the correct statements to the\n   * Role's policies yourself.\n   */\n  public withoutPolicyUpdates(options: WithoutPolicyUpdatesOptions = {}): IRole {\n    if (!this.immutableRole) {\n      this.immutableRole = new ImmutableRole(Node.of(this).scope as Construct, `ImmutableRole${this.node.id}`, this, options.addGrantsToResources ?? false);\n    }\n\n    return this.immutableRole;\n  }\n\n  private validateRole(): string[] {\n    const errors = new Array<string>();\n    errors.push(...this.assumeRolePolicy?.validateForResourcePolicy() ?? []);\n    for (const policy of Object.values(this.inlinePolicies)) {\n      errors.push(...policy.validateForIdentityPolicy());\n    }\n    return errors;\n  }\n}\n\n/**\n * A Role object\n */\nexport interface IRole extends IIdentity {\n  /**\n   * Returns the ARN of this role.\n   *\n   * @attribute\n   */\n  readonly roleArn: string;\n\n  /**\n   * Returns the name of this role.\n   *\n   * @attribute\n   */\n  readonly roleName: string;\n\n  /**\n   * Grant the actions defined in actions to the identity Principal on this resource.\n   */\n  grant(grantee: IPrincipal, ...actions: string[]): Grant;\n\n  /**\n   * Grant permissions to the given principal to pass this role.\n   */\n  grantPassRole(grantee: IPrincipal): Grant;\n}\n\nfunction createAssumeRolePolicy(principal: IPrincipal, externalIds: string[]) {\n  const actualDoc = new PolicyDocument();\n\n  // If requested, add externalIds to every statement added to this doc\n  const addDoc = externalIds.length === 0\n    ? actualDoc\n    : new MutatingPolicyDocumentAdapter(actualDoc, (statement) => {\n      statement.addCondition('StringEquals', {\n        'sts:ExternalId': externalIds.length === 1 ? externalIds[0] : externalIds,\n      });\n      return statement;\n    });\n\n  defaultAddPrincipalToAssumeRole(principal, addDoc);\n\n  return actualDoc;\n}\n\nfunction validateMaxSessionDuration(duration?: number) {\n  if (duration === undefined) {\n    return;\n  }\n\n  if (duration < 3600 || duration > 43200) {\n    throw new Error(`maxSessionDuration is set to ${duration}, but must be >= 3600sec (1hr) and <= 43200sec (12hrs)`);\n  }\n}\n\n/**\n * Options for the `withoutPolicyUpdates()` modifier of a Role\n */\nexport interface WithoutPolicyUpdatesOptions {\n  /**\n   * Add grants to resources instead of dropping them\n   *\n   * If this is `false` or not specified, grant permissions added to this role are ignored.\n   * It is your own responsibility to make sure the role has the required permissions.\n   *\n   * If this is `true`, any grant permissions will be added to the resource instead.\n   *\n   * @default false\n   */\n  readonly addGrantsToResources?: boolean;\n}"],
  "mappings": "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",
  "names": []
}
