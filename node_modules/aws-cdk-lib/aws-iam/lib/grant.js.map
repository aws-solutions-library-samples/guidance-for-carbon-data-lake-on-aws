{
  "version": 3,
  "sources": ["grant.ts"],
  "sourcesContent": ["import * as cdk from '../../core';\nimport { Dependable, IConstruct, IDependable } from 'constructs';\nimport { PolicyStatement } from './policy-statement';\nimport { IGrantable, IPrincipal } from './principals';\n\n/**\n * Basic options for a grant operation\n *\n */\nexport interface CommonGrantOptions {\n  /**\n   * The principal to grant to\n   *\n   * @default if principal is undefined, no work is done.\n   */\n  readonly grantee: IGrantable;\n\n  /**\n   * The actions to grant\n   */\n  readonly actions: string[];\n\n  /**\n   * The resource ARNs to grant to\n   */\n  readonly resourceArns: string[];\n}\n\n/**\n * Options for a grant operation\n *\n */\nexport interface GrantWithResourceOptions extends CommonGrantOptions {\n  /**\n   * The resource with a resource policy\n   *\n   * The statement will be added to the resource policy if it couldn't be\n   * added to the principal policy.\n   */\n  readonly resource: IResourceWithPolicy;\n\n  /**\n   * When referring to the resource in a resource policy, use this as ARN.\n   *\n   * (Depending on the resource type, this needs to be '*' in a resource policy).\n   *\n   * @default Same as regular resource ARNs\n   */\n  readonly resourceSelfArns?: string[];\n}\n\n/**\n * Options for a grant operation that only applies to principals\n *\n */\nexport interface GrantOnPrincipalOptions extends CommonGrantOptions {\n  /**\n   * Construct to report warnings on in case grant could not be registered\n   *\n   * @default - the construct in which this construct is defined\n   */\n  readonly scope?: IConstruct;\n}\n\n/**\n * Options for a grant operation to both identity and resource\n *\n */\nexport interface GrantOnPrincipalAndResourceOptions extends CommonGrantOptions {\n  /**\n   * The resource with a resource policy\n   *\n   * The statement will always be added to the resource policy.\n   */\n  readonly resource: IResourceWithPolicy;\n\n  /**\n   * When referring to the resource in a resource policy, use this as ARN.\n   *\n   * (Depending on the resource type, this needs to be '*' in a resource policy).\n   *\n   * @default Same as regular resource ARNs\n   */\n  readonly resourceSelfArns?: string[];\n\n  /**\n   * The principal to use in the statement for the resource policy.\n   *\n   * @default - the principal of the grantee will be used\n   */\n  readonly resourcePolicyPrincipal?: IPrincipal;\n}\n\n/**\n * Result of a grant() operation\n *\n * This class is not instantiable by consumers on purpose, so that they will be\n * required to call the Grant factory functions.\n */\nexport class Grant implements IDependable {\n  /**\n   * Grant the given permissions to the principal\n   *\n   * The permissions will be added to the principal policy primarily, falling\n   * back to the resource policy if necessary. The permissions must be granted\n   * somewhere.\n   *\n   * - Trying to grant permissions to a principal that does not admit adding to\n   *   the principal policy while not providing a resource with a resource policy\n   *   is an error.\n   * - Trying to grant permissions to an absent principal (possible in the\n   *   case of imported resources) leads to a warning being added to the\n   *   resource construct.\n   */\n  public static addToPrincipalOrResource(options: GrantWithResourceOptions): Grant {\n    const result = Grant.addToPrincipal({\n      ...options,\n      scope: options.resource,\n    });\n\n    const resourceAndPrincipalAccountComparison = options.grantee.grantPrincipal.principalAccount\n      ? cdk.Token.compareStrings(options.resource.env.account, options.grantee.grantPrincipal.principalAccount)\n      : undefined;\n    // if both accounts are tokens, we assume here they are the same\n    const equalOrBothUnresolved = resourceAndPrincipalAccountComparison === cdk.TokenComparison.SAME\n      || resourceAndPrincipalAccountComparison == cdk.TokenComparison.BOTH_UNRESOLVED;\n    const sameAccount: boolean = resourceAndPrincipalAccountComparison\n      ? equalOrBothUnresolved\n      // if the principal doesn't have an account (for example, a service principal),\n      // we should modify the resource's trust policy\n      : false;\n    // If we added to the principal AND we're in the same account, then we're done.\n    // If not, it's a different account and we must also add a trust policy on the resource.\n    if (result.success && sameAccount) {\n      return result;\n    }\n\n    const statement = new PolicyStatement({\n      actions: options.actions,\n      resources: (options.resourceSelfArns || options.resourceArns),\n      principals: [options.grantee!.grantPrincipal],\n    });\n\n    const resourceResult = options.resource.addToResourcePolicy(statement);\n\n    return new Grant({\n      resourceStatement: statement,\n      options,\n      policyDependable: resourceResult.statementAdded ? resourceResult.policyDependable ?? options.resource : undefined,\n    });\n  }\n\n  /**\n   * Try to grant the given permissions to the given principal\n   *\n   * Absence of a principal leads to a warning, but failing to add\n   * the permissions to a present principal is not an error.\n   */\n  public static addToPrincipal(options: GrantOnPrincipalOptions): Grant {\n    const statement = new PolicyStatement({\n      actions: options.actions,\n      resources: options.resourceArns,\n    });\n\n    const addedToPrincipal = options.grantee.grantPrincipal.addToPrincipalPolicy(statement);\n    if (!addedToPrincipal.statementAdded) {\n      return new Grant({ principalStatement: undefined, options });\n    }\n\n    if (!addedToPrincipal.policyDependable) {\n      throw new Error('Contract violation: when Principal returns statementAdded=true, it should return a dependable');\n    }\n\n    return new Grant({ principalStatement: statement, options, policyDependable: addedToPrincipal.policyDependable });\n  }\n\n  /**\n   * Add a grant both on the principal and on the resource\n   *\n   * As long as any principal is given, granting on the principal may fail (in\n   * case of a non-identity principal), but granting on the resource will\n   * never fail.\n   *\n   * Statement will be the resource statement.\n   */\n  public static addToPrincipalAndResource(options: GrantOnPrincipalAndResourceOptions): Grant {\n    const result = Grant.addToPrincipal({\n      ...options,\n      scope: options.resource,\n    });\n\n    const statement = new PolicyStatement({\n      actions: options.actions,\n      resources: (options.resourceSelfArns || options.resourceArns),\n      principals: [options.resourcePolicyPrincipal || options.grantee!.grantPrincipal],\n    });\n\n    const resourceResult = options.resource.addToResourcePolicy(statement);\n    const resourceDependable = resourceResult.statementAdded ? resourceResult.policyDependable ?? options.resource : undefined;\n\n    return new Grant({\n      principalStatement: statement,\n      resourceStatement: result.resourceStatement,\n      options,\n      policyDependable: resourceDependable ? new CompositeDependable(result, resourceDependable) : result,\n    });\n  }\n\n  /**\n   * Returns a \"no-op\" `Grant` object which represents a \"dropped grant\".\n   *\n   * This can be used for e.g. imported resources where you may not be able to modify\n   * the resource's policy or some underlying policy which you don't know about.\n   *\n   * @param grantee The intended grantee\n   * @param _intent The user's intent (will be ignored at the moment)\n   */\n  public static drop(grantee: IGrantable, _intent: string): Grant {\n    return new Grant({\n      options: { grantee, actions: [], resourceArns: [] },\n    });\n  }\n\n  /**\n   * The statement that was added to the principal's policy\n   *\n   * Can be accessed to (e.g.) add additional conditions to the statement.\n   */\n  public readonly principalStatement?: PolicyStatement;\n\n  /**\n   * The statement that was added to the resource policy\n   *\n   * Can be accessed to (e.g.) add additional conditions to the statement.\n   */\n  public readonly resourceStatement?: PolicyStatement;\n\n  /**\n   * The options originally used to set this result\n   *\n   * Private member doubles as a way to make it impossible for an object literal to\n   * be structurally the same as this class.\n   */\n  private readonly options: CommonGrantOptions;\n\n  private constructor(props: GrantProps) {\n    this.options = props.options;\n    this.principalStatement = props.principalStatement;\n    this.resourceStatement = props.resourceStatement;\n\n    Dependable.implement(this, {\n      get dependencyRoots() {\n        return props.policyDependable ? Dependable.of(props.policyDependable).dependencyRoots : [];\n      },\n    });\n  }\n\n  /**\n   * Whether the grant operation was successful\n   */\n  public get success(): boolean {\n    return this.principalStatement !== undefined || this.resourceStatement !== undefined;\n  }\n\n  /**\n   * Throw an error if this grant wasn't successful\n   */\n  public assertSuccess(): void {\n    if (!this.success) {\n      // eslint-disable-next-line max-len\n      throw new Error(`${describeGrant(this.options)} could not be added on either identity or resource policy.`);\n    }\n  }\n\n  /**\n   * Make sure this grant is applied before the given constructs are deployed\n   *\n   * The same as construct.node.addDependency(grant), but slightly nicer to read.\n   */\n  public applyBefore(...constructs: IConstruct[]) {\n    for (const construct of constructs) {\n      construct.node.addDependency(this);\n    }\n  }\n}\n\nfunction describeGrant(options: CommonGrantOptions) {\n  return `Permissions for '${options.grantee}' to call '${options.actions}' on '${options.resourceArns}'`;\n}\n\ninterface GrantProps {\n  readonly options: CommonGrantOptions;\n  readonly principalStatement?: PolicyStatement;\n  readonly resourceStatement?: PolicyStatement;\n\n  /**\n   * Constructs whose deployment applies the grant\n   *\n   * Used to add dependencies on grants\n   */\n  readonly policyDependable?: IDependable;\n}\n\n/**\n * A resource with a resource policy that can be added to\n */\nexport interface IResourceWithPolicy extends cdk.IResource {\n  /**\n   * Add a statement to the resource's resource policy\n   */\n  addToResourcePolicy(statement: PolicyStatement): AddToResourcePolicyResult;\n}\n\n/**\n * Result of calling addToResourcePolicy\n */\nexport interface AddToResourcePolicyResult {\n  /**\n   * Whether the statement was added\n   */\n  readonly statementAdded: boolean;\n\n  /**\n   * Dependable which allows depending on the policy change being applied\n   *\n   * @default - If `statementAdded` is true, the resource object itself.\n   * Otherwise, no dependable.\n   */\n  readonly policyDependable?: IDependable;\n}\n\n/**\n * Composite dependable\n *\n * Not as simple as eagerly getting the dependency roots from the\n * inner dependables, as they may be mutable so we need to defer\n * the query.\n */\nexport class CompositeDependable implements IDependable {\n  constructor(...dependables: IDependable[]) {\n    Dependable.implement(this, {\n      get dependencyRoots(): IConstruct[] {\n        return Array.prototype.concat.apply([], dependables.map(d => Dependable.of(d).dependencyRoots));\n      },\n    });\n  }\n}\n"],
  "mappings": "2OAAA,IAAA,QAAA,cACA,aAAA,QAAA,cACA,mBAAA,QAAA,sBAiGA,WAAkB,CAkJhB,YAAoB,MAAiB,CACnC,KAAK,QAAU,MAAM,QACrB,KAAK,mBAAqB,MAAM,mBAChC,KAAK,kBAAoB,MAAM,kBAE/B,aAAA,WAAW,UAAU,KAAM,IACrB,kBAAe,CACjB,MAAO,OAAM,iBAAmB,aAAA,WAAW,GAAG,MAAM,kBAAkB,gBAAkB,YA1IhF,0BAAyB,QAAiC,sFACtE,KAAM,QAAS,MAAM,eAAe,IAC/B,QACH,MAAO,QAAQ,WAGX,sCAAwC,QAAQ,QAAQ,eAAe,iBACzE,IAAI,MAAM,eAAe,QAAQ,SAAS,IAAI,QAAS,QAAQ,QAAQ,eAAe,kBACtF,OAEE,sBAAwB,wCAA0C,IAAI,gBAAgB,MACvF,uCAAyC,IAAI,gBAAgB,gBAC5D,YAAuB,sCACzB,sBAGA,GAGJ,GAAI,OAAO,SAAW,YACpB,MAAO,QAGT,KAAM,WAAY,GAAI,oBAAA,gBAAgB,CACpC,QAAS,QAAQ,QACjB,UAAY,QAAQ,kBAAoB,QAAQ,aAChD,WAAY,CAAC,QAAQ,QAAS,kBAG1B,eAAiB,QAAQ,SAAS,oBAAoB,WAE5D,MAAO,IAAI,OAAM,CACf,kBAAmB,UACnB,QACA,iBAAkB,eAAe,eAAgB,IAAC,eAAe,oBAAgB,MAAA,KAAA,OAAA,GAAI,QAAQ,SAAW,eAU9F,gBAAe,QAAgC,8EAC3D,KAAM,WAAY,GAAI,oBAAA,gBAAgB,CACpC,QAAS,QAAQ,QACjB,UAAW,QAAQ,eAGf,iBAAmB,QAAQ,QAAQ,eAAe,qBAAqB,WAC7E,GAAI,CAAC,iBAAiB,eACpB,MAAO,IAAI,OAAM,CAAE,mBAAoB,OAAW,UAGpD,GAAI,CAAC,iBAAiB,iBACpB,KAAM,IAAI,OAAM,iGAGlB,MAAO,IAAI,OAAM,CAAE,mBAAoB,UAAW,QAAS,iBAAkB,iBAAiB,yBAYlF,2BAA0B,QAA2C,gGACjF,KAAM,QAAS,MAAM,eAAe,IAC/B,QACH,MAAO,QAAQ,WAGX,UAAY,GAAI,oBAAA,gBAAgB,CACpC,QAAS,QAAQ,QACjB,UAAY,QAAQ,kBAAoB,QAAQ,aAChD,WAAY,CAAC,QAAQ,yBAA2B,QAAQ,QAAS,kBAG7D,eAAiB,QAAQ,SAAS,oBAAoB,WACtD,mBAAqB,eAAe,eAAgB,IAAC,eAAe,oBAAgB,MAAA,KAAA,OAAA,GAAI,QAAQ,SAAW,OAEjH,MAAO,IAAI,OAAM,CACf,mBAAoB,UACpB,kBAAmB,OAAO,kBAC1B,QACA,iBAAkB,mBAAqB,GAAI,qBAAoB,OAAQ,oBAAsB,eAanF,MAAK,QAAqB,QAAe,wEAC9C,GAAI,OAAM,CACf,QAAS,CAAE,QAAS,QAAS,GAAI,aAAc,SAyCxC,UAAO,CAChB,MAAO,MAAK,qBAAuB,QAAa,KAAK,oBAAsB,OAMtE,eAAa,CAClB,GAAI,CAAC,KAAK,QAER,KAAM,IAAI,OAAM,GAAG,cAAc,KAAK,sEASnC,eAAe,WAAwB,CAC5C,SAAW,aAAa,YACtB,UAAU,KAAK,cAAc,OAtLnC,QAAA,MAAA,yFA2LA,uBAAuB,QAA2B,CAChD,MAAO,oBAAoB,QAAQ,qBAAqB,QAAQ,gBAAgB,QAAQ,gBAmD1F,yBAAgC,CAC9B,eAAe,YAA0B,CACvC,aAAA,WAAW,UAAU,KAAM,IACrB,kBAAe,CACjB,MAAO,OAAM,UAAU,OAAO,MAAM,GAAI,YAAY,IAAI,GAAK,aAAA,WAAW,GAAG,GAAG,sBAJtF,QAAA,oBAAA",
  "names": []
}
