{
  "version": 3,
  "sources": ["cloud-assembly.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as cxschema from '../../cloud-assembly-schema';\nimport { CloudFormationStackArtifact } from './artifacts/cloudformation-artifact';\nimport { NestedCloudAssemblyArtifact } from './artifacts/nested-cloud-assembly-artifact';\nimport { TreeCloudArtifact } from './artifacts/tree-cloud-artifact';\nimport { CloudArtifact } from './cloud-artifact';\nimport { topologicalSort } from './toposort';\n\n/**\n * The name of the root manifest file of the assembly.\n */\nconst MANIFEST_FILE = 'manifest.json';\n\n/**\n * Represents a deployable cloud application.\n */\nexport class CloudAssembly {\n  /**\n   * The root directory of the cloud assembly.\n   */\n  public readonly directory: string;\n\n  /**\n   * The schema version of the assembly manifest.\n   */\n  public readonly version: string;\n\n  /**\n   * All artifacts included in this assembly.\n   */\n  public readonly artifacts: CloudArtifact[];\n\n  /**\n   * Runtime information such as module versions used to synthesize this assembly.\n   */\n  public readonly runtime: cxschema.RuntimeInfo;\n\n  /**\n   * The raw assembly manifest.\n   */\n  public readonly manifest: cxschema.AssemblyManifest;\n\n  /**\n   * Reads a cloud assembly from the specified directory.\n   * @param directory The root directory of the assembly.\n   */\n  constructor(directory: string) {\n    this.directory = directory;\n\n    this.manifest = cxschema.Manifest.loadAssemblyManifest(path.join(directory, MANIFEST_FILE));\n    this.version = this.manifest.version;\n    this.artifacts = this.renderArtifacts();\n    this.runtime = this.manifest.runtime || { libraries: { } };\n\n    // force validation of deps by accessing 'depends' on all artifacts\n    this.validateDeps();\n  }\n\n  /**\n   * Attempts to find an artifact with a specific identity.\n   * @returns A `CloudArtifact` object or `undefined` if the artifact does not exist in this assembly.\n   * @param id The artifact ID\n   */\n  public tryGetArtifact(id: string): CloudArtifact | undefined {\n    return this.artifacts.find(a => a.id === id);\n  }\n\n  /**\n   * Returns a CloudFormation stack artifact from this assembly.\n   *\n   * Will only search the current assembly.\n   *\n   * @param stackName the name of the CloudFormation stack.\n   * @throws if there is no stack artifact by that name\n   * @throws if there is more than one stack with the same stack name. You can\n   * use `getStackArtifact(stack.artifactId)` instead.\n   * @returns a `CloudFormationStackArtifact` object.\n   */\n  public getStackByName(stackName: string): CloudFormationStackArtifact {\n    const artifacts = this.artifacts.filter(a => a instanceof CloudFormationStackArtifact && a.stackName === stackName);\n    if (!artifacts || artifacts.length === 0) {\n      throw new Error(`Unable to find stack with stack name \"${stackName}\"`);\n    }\n\n    if (artifacts.length > 1) {\n      // eslint-disable-next-line max-len\n      throw new Error(`There are multiple stacks with the stack name \"${stackName}\" (${artifacts.map(a => a.id).join(',')}). Use \"getStackArtifact(id)\" instead`);\n    }\n\n    return artifacts[0] as CloudFormationStackArtifact;\n  }\n\n  /**\n   * Returns a CloudFormation stack artifact by name from this assembly.\n   * @deprecated renamed to `getStackByName` (or `getStackArtifact(id)`)\n   */\n  public getStack(stackName: string) {\n    return this.getStackByName(stackName);\n  }\n\n  /**\n   * Returns a CloudFormation stack artifact from this assembly.\n   *\n   * @param artifactId the artifact id of the stack (can be obtained through `stack.artifactId`).\n   * @throws if there is no stack artifact with that id\n   * @returns a `CloudFormationStackArtifact` object.\n   */\n  public getStackArtifact(artifactId: string): CloudFormationStackArtifact {\n    const artifact = this.tryGetArtifactRecursively(artifactId);\n\n    if (!artifact) {\n      throw new Error(`Unable to find artifact with id \"${artifactId}\"`);\n    }\n\n    if (!(artifact instanceof CloudFormationStackArtifact)) {\n      throw new Error(`Artifact ${artifactId} is not a CloudFormation stack`);\n    }\n\n    return artifact;\n  }\n\n  private tryGetArtifactRecursively(artifactId: string): CloudArtifact | undefined {\n    return this.stacksRecursively.find(a => a.id === artifactId);\n  }\n\n  /**\n   * Returns all the stacks, including the ones in nested assemblies\n   */\n  public get stacksRecursively(): CloudFormationStackArtifact[] {\n    function search(stackArtifacts: CloudFormationStackArtifact[], assemblies: CloudAssembly[]): CloudFormationStackArtifact[] {\n      if (assemblies.length === 0) {\n        return stackArtifacts;\n      }\n\n      const [head, ...tail] = assemblies;\n      const nestedAssemblies = head.nestedAssemblies.map(asm => asm.nestedAssembly);\n      return search(stackArtifacts.concat(head.stacks), tail.concat(nestedAssemblies));\n    };\n\n    return search([], [this]);\n  }\n\n  /**\n   * Returns a nested assembly artifact.\n   *\n   * @param artifactId The artifact ID of the nested assembly\n   */\n  public getNestedAssemblyArtifact(artifactId: string): NestedCloudAssemblyArtifact {\n    const artifact = this.tryGetArtifact(artifactId);\n    if (!artifact) {\n      throw new Error(`Unable to find artifact with id \"${artifactId}\"`);\n    }\n\n    if (!(artifact instanceof NestedCloudAssemblyArtifact)) {\n      throw new Error(`Found artifact '${artifactId}' but it's not a nested cloud assembly`);\n    }\n\n    return artifact;\n  }\n\n  /**\n   * Returns a nested assembly.\n   *\n   * @param artifactId The artifact ID of the nested assembly\n   */\n  public getNestedAssembly(artifactId: string): CloudAssembly {\n    return this.getNestedAssemblyArtifact(artifactId).nestedAssembly;\n  }\n\n  /**\n   * Returns the tree metadata artifact from this assembly.\n   * @throws if there is no metadata artifact by that name\n   * @returns a `TreeCloudArtifact` object if there is one defined in the manifest, `undefined` otherwise.\n   */\n  public tree(): TreeCloudArtifact | undefined {\n    const trees = this.artifacts.filter(a => a.manifest.type === cxschema.ArtifactType.CDK_TREE);\n    if (trees.length === 0) {\n      return undefined;\n    } else if (trees.length > 1) {\n      throw new Error(`Multiple artifacts of type ${cxschema.ArtifactType.CDK_TREE} found in manifest`);\n    }\n    const tree = trees[0];\n\n    if (!(tree instanceof TreeCloudArtifact)) {\n      throw new Error('\"Tree\" artifact is not of expected type');\n    }\n\n    return tree;\n  }\n\n  /**\n   * @returns all the CloudFormation stack artifacts that are included in this assembly.\n   */\n  public get stacks(): CloudFormationStackArtifact[] {\n    return this.artifacts.filter(isCloudFormationStackArtifact);\n\n    function isCloudFormationStackArtifact(x: any): x is CloudFormationStackArtifact {\n      return x instanceof CloudFormationStackArtifact;\n    }\n  }\n\n  /**\n   * The nested assembly artifacts in this assembly\n   */\n  public get nestedAssemblies(): NestedCloudAssemblyArtifact[] {\n    return this.artifacts.filter(isNestedCloudAssemblyArtifact);\n\n    function isNestedCloudAssemblyArtifact(x: any): x is NestedCloudAssemblyArtifact {\n      return x instanceof NestedCloudAssemblyArtifact;\n    }\n  }\n\n  private validateDeps() {\n    for (const artifact of this.artifacts) {\n      ignore(artifact.dependencies);\n    }\n  }\n\n  private renderArtifacts() {\n    const result = new Array<CloudArtifact>();\n    for (const [name, artifact] of Object.entries(this.manifest.artifacts || { })) {\n      const cloudartifact = CloudArtifact.fromManifest(this, name, artifact);\n      if (cloudartifact) {\n        result.push(cloudartifact);\n      }\n    }\n\n    return topologicalSort(result, x => x.id, x => x._dependencyIDs);\n  }\n}\n\n/**\n * Construction properties for CloudAssemblyBuilder\n */\nexport interface CloudAssemblyBuilderProps {\n  /**\n   * Use the given asset output directory\n   *\n   * @default - Same as the manifest outdir\n   */\n  readonly assetOutdir?: string;\n\n  /**\n   * If this builder is for a nested assembly, the parent assembly builder\n   *\n   * @default - This is a root assembly\n   */\n  readonly parentBuilder?: CloudAssemblyBuilder;\n}\n\n/**\n * Can be used to build a cloud assembly.\n */\nexport class CloudAssemblyBuilder {\n  /**\n   * The root directory of the resulting cloud assembly.\n   */\n  public readonly outdir: string;\n\n  /**\n   * The directory where assets of this Cloud Assembly should be stored\n   */\n  public readonly assetOutdir: string;\n\n  private readonly artifacts: { [id: string]: cxschema.ArtifactManifest } = { };\n  private readonly missing = new Array<cxschema.MissingContext>();\n  private readonly parentBuilder?: CloudAssemblyBuilder;\n\n  /**\n   * Initializes a cloud assembly builder.\n   * @param outdir The output directory, uses temporary directory if undefined\n   */\n  constructor(outdir?: string, props: CloudAssemblyBuilderProps = {}) {\n    this.outdir = determineOutputDirectory(outdir);\n    this.assetOutdir = props.assetOutdir ?? this.outdir;\n    this.parentBuilder = props.parentBuilder;\n\n    // we leverage the fact that outdir is long-lived to avoid staging assets into it\n    // that were already staged (copying can be expensive). this is achieved by the fact\n    // that assets use a source hash as their name. other artifacts, and the manifest itself,\n    // will overwrite existing files as needed.\n    ensureDirSync(this.outdir);\n  }\n\n  /**\n   * Adds an artifact into the cloud assembly.\n   * @param id The ID of the artifact.\n   * @param manifest The artifact manifest\n   */\n  public addArtifact(id: string, manifest: cxschema.ArtifactManifest) {\n    this.artifacts[id] = filterUndefined(manifest);\n  }\n\n  /**\n   * Reports that some context is missing in order for this cloud assembly to be fully synthesized.\n   * @param missing Missing context information.\n   */\n  public addMissing(missing: cxschema.MissingContext) {\n    if (this.missing.every(m => m.key !== missing.key)) {\n      this.missing.push(missing);\n    }\n    // Also report in parent\n    this.parentBuilder?.addMissing(missing);\n  }\n\n  /**\n   * Finalizes the cloud assembly into the output directory returns a\n   * `CloudAssembly` object that can be used to inspect the assembly.\n   * @param options\n   */\n  public buildAssembly(options: AssemblyBuildOptions = { }): CloudAssembly {\n\n    // explicitly initializing this type will help us detect\n    // breaking changes. (For example adding a required property will break compilation).\n    let manifest: cxschema.AssemblyManifest = {\n      version: cxschema.Manifest.version(),\n      artifacts: this.artifacts,\n      runtime: options.runtimeInfo,\n      missing: this.missing.length > 0 ? this.missing : undefined,\n    };\n\n    // now we can filter\n    manifest = filterUndefined(manifest);\n\n    const manifestFilePath = path.join(this.outdir, MANIFEST_FILE);\n    cxschema.Manifest.saveAssemblyManifest(manifest, manifestFilePath);\n\n    // \"backwards compatibility\": in order for the old CLI to tell the user they\n    // need a new version, we'll emit the legacy manifest with only \"version\".\n    // this will result in an error \"CDK Toolkit >= CLOUD_ASSEMBLY_VERSION is required in order to interact with this program.\"\n    fs.writeFileSync(path.join(this.outdir, 'cdk.out'), JSON.stringify({ version: manifest.version }));\n\n    return new CloudAssembly(this.outdir);\n  }\n\n  /**\n   * Creates a nested cloud assembly\n   */\n  public createNestedAssembly(artifactId: string, displayName: string) {\n    const directoryName = artifactId;\n    const innerAsmDir = path.join(this.outdir, directoryName);\n\n    this.addArtifact(artifactId, {\n      type: cxschema.ArtifactType.NESTED_CLOUD_ASSEMBLY,\n      properties: {\n        directoryName,\n        displayName,\n      } as cxschema.NestedCloudAssemblyProperties,\n    });\n\n    return new CloudAssemblyBuilder(innerAsmDir, {\n      // Reuse the same asset output directory as the current Casm builder\n      assetOutdir: this.assetOutdir,\n      parentBuilder: this,\n    });\n  }\n}\n\n/**\n * Backwards compatibility for when `RuntimeInfo`\n * was defined here. This is necessary because its used as an input in the stable\n * @aws-cdk/core library.\n *\n * @deprecated moved to package 'cloud-assembly-schema'\n * @see core.ConstructNode.synth\n */\nexport interface RuntimeInfo extends cxschema.RuntimeInfo {\n\n}\n\n/**\n * Backwards compatibility for when `MetadataEntry`\n * was defined here. This is necessary because its used as an input in the stable\n * @aws-cdk/core library.\n *\n * @deprecated moved to package 'cloud-assembly-schema'\n * @see core.ConstructNode.metadata\n */\nexport interface MetadataEntry extends cxschema.MetadataEntry {\n\n}\n\n/**\n * Backwards compatibility for when `MissingContext`\n * was defined here. This is necessary because its used as an input in the stable\n * @aws-cdk/core library.\n *\n * @deprecated moved to package 'cloud-assembly-schema'\n * @see core.Stack.reportMissingContext\n */\nexport interface MissingContext {\n  /**\n   * The missing context key.\n   */\n  readonly key: string;\n\n  /**\n   * The provider from which we expect this context key to be obtained.\n   *\n   * (This is the old untyped definition, which is necessary for backwards compatibility.\n   * See cxschema for a type definition.)\n   */\n  readonly provider: string;\n\n  /**\n   * A set of provider-specific options.\n   *\n   * (This is the old untyped definition, which is necessary for backwards compatibility.\n   * See cxschema for a type definition.)\n   */\n  readonly props: Record<string, any>;\n}\n\nexport interface AssemblyBuildOptions {\n  /**\n   * Include the specified runtime information (module versions) in manifest.\n   * @default - if this option is not specified, runtime info will not be included\n   * @deprecated All template modifications that should result from this should\n   * have already been inserted into the template.\n   */\n  readonly runtimeInfo?: RuntimeInfo;\n}\n\n/**\n * Returns a copy of `obj` without undefined values in maps or arrays.\n */\nfunction filterUndefined(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.filter(x => x !== undefined).map(x => filterUndefined(x));\n  }\n\n  if (typeof(obj) === 'object') {\n    const ret: any = { };\n    for (const [key, value] of Object.entries(obj)) {\n      if (value === undefined) {\n        continue;\n      }\n      ret[key] = filterUndefined(value);\n    }\n    return ret;\n  }\n\n  return obj;\n}\n\nfunction ignore(_x: any) {\n  return;\n}\n\n/**\n * Turn the given optional output directory into a fixed output directory\n */\nfunction determineOutputDirectory(outdir?: string) {\n  return outdir ?? fs.mkdtempSync(path.join(fs.realpathSync(os.tmpdir()), 'cdk.out'));\n}\n\nfunction ensureDirSync(dir: string) {\n  if (fs.existsSync(dir)) {\n    if (!fs.statSync(dir).isDirectory()) {\n      throw new Error(`${dir} must be a directory`);\n    }\n  } else {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n}"],
  "mappings": "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",
  "names": []
}
