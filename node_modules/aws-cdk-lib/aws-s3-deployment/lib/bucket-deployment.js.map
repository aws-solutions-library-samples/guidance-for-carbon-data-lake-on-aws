{
  "version": 3,
  "sources": ["bucket-deployment.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport * as cloudfront from '../../aws-cloudfront';\nimport * as ec2 from '../../aws-ec2';\nimport * as efs from '../../aws-efs';\nimport * as iam from '../../aws-iam';\nimport * as lambda from '../../aws-lambda';\nimport * as logs from '../../aws-logs';\nimport * as s3 from '../../aws-s3';\nimport * as cdk from '../../core';\nimport { AwsCliLayer } from '../../lambda-layer-awscli';\nimport { kebab as toKebabCase } from 'case';\nimport { Construct } from 'constructs';\nimport { ISource, SourceConfig } from './source';\n\n// tag key has a limit of 128 characters\nconst CUSTOM_RESOURCE_OWNER_TAG = 'aws-cdk:cr-owned';\n\n/**\n * Properties for `BucketDeployment`.\n */\nexport interface BucketDeploymentProps {\n  /**\n   * The sources from which to deploy the contents of this bucket.\n   */\n  readonly sources: ISource[];\n\n  /**\n   * The S3 bucket to sync the contents of the zip file to.\n   */\n  readonly destinationBucket: s3.IBucket;\n\n  /**\n   * Key prefix in the destination bucket.\n   *\n   * Must be <=104 characters\n   *\n   * @default \"/\" (unzip to root of the destination bucket)\n   */\n  readonly destinationKeyPrefix?: string;\n\n  /**\n   * If this is set, matching files or objects will be excluded from the deployment's sync\n   * command. This can be used to exclude a file from being pruned in the destination bucket.\n   *\n   * If you want to just exclude files from the deployment package (which excludes these files\n   * evaluated when invalidating the asset), you should leverage the `exclude` property of\n   * `AssetOptions` when defining your source.\n   *\n   * @default - No exclude filters are used\n   * @see https://docs.aws.amazon.com/cli/latest/reference/s3/index.html#use-of-exclude-and-include-filters\n   */\n  readonly exclude?: string[]\n\n  /**\n   * If this is set, matching files or objects will be included with the deployment's sync\n   * command. Since all files from the deployment package are included by default, this property\n   * is usually leveraged alongside an `exclude` filter.\n   *\n   * @default - No include filters are used and all files are included with the sync command\n   * @see https://docs.aws.amazon.com/cli/latest/reference/s3/index.html#use-of-exclude-and-include-filters\n   */\n  readonly include?: string[]\n\n  /**\n   * If this is set to false, files in the destination bucket that\n   * do not exist in the asset, will NOT be deleted during deployment (create/update).\n   *\n   * @see https://docs.aws.amazon.com/cli/latest/reference/s3/sync.html\n   *\n   * @default true\n   */\n  readonly prune?: boolean\n\n  /**\n   * If this is set to \"false\", the destination files will be deleted when the\n   * resource is deleted or the destination is updated.\n   *\n   * NOTICE: Configuring this to \"false\" might have operational implications. Please\n   * visit to the package documentation referred below to make sure you fully understand those implications.\n   *\n   * @see https://github.com/aws/aws-cdk/tree/master/packages/%40aws-cdk/aws-s3-deployment#retain-on-delete\n   * @default true - when resource is deleted/updated, files are retained\n   */\n  readonly retainOnDelete?: boolean;\n\n  /**\n   * The CloudFront distribution using the destination bucket as an origin.\n   * Files in the distribution's edge caches will be invalidated after\n   * files are uploaded to the destination bucket.\n   *\n   * @default - No invalidation occurs\n   */\n  readonly distribution?: cloudfront.IDistribution;\n\n  /**\n   * The file paths to invalidate in the CloudFront distribution.\n   *\n   * @default - All files under the destination bucket key prefix will be invalidated.\n   */\n  readonly distributionPaths?: string[];\n\n\n  /**\n   * The number of days that the lambda function's log events are kept in CloudWatch Logs.\n   *\n   * @default logs.RetentionDays.INFINITE\n   */\n  readonly logRetention?: logs.RetentionDays;\n\n  /**\n   * The amount of memory (in MiB) to allocate to the AWS Lambda function which\n   * replicates the files from the CDK bucket to the destination bucket.\n   *\n   * If you are deploying large files, you will need to increase this number\n   * accordingly.\n   *\n   * @default 128\n   */\n  readonly memoryLimit?: number;\n\n  /**\n   *  Mount an EFS file system. Enable this if your assets are large and you encounter disk space errors.\n   *  Enabling this option will require a VPC to be specified.\n   *\n   * @default - No EFS. Lambda has access only to 512MB of disk space.\n   */\n  readonly useEfs?: boolean\n\n  /**\n   * Execution role associated with this function\n   *\n   * @default - A role is automatically created\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * User-defined object metadata to be set on all objects in the deployment\n   * @default - No user metadata is set\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata\n   */\n  readonly metadata?: UserDefinedObjectMetadata;\n\n  /**\n   * System-defined cache-control metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly cacheControl?: CacheControl[];\n  /**\n   * System-defined cache-disposition metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly contentDisposition?: string;\n  /**\n   * System-defined content-encoding metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly contentEncoding?: string;\n  /**\n   * System-defined content-language metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly contentLanguage?: string;\n  /**\n   * System-defined content-type metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly contentType?: string;\n  /**\n   * System-defined expires metadata to be set on all objects in the deployment.\n   * @default - The objects in the distribution will not expire.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly expires?: cdk.Expiration;\n  /**\n   * System-defined x-amz-server-side-encryption metadata to be set on all objects in the deployment.\n   * @default - Server side encryption is not used.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly serverSideEncryption?: ServerSideEncryption;\n  /**\n   * System-defined x-amz-storage-class metadata to be set on all objects in the deployment.\n   * @default - Default storage-class for the bucket is used.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly storageClass?: StorageClass;\n  /**\n   * System-defined x-amz-website-redirect-location metadata to be set on all objects in the deployment.\n   * @default - No website redirection.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly websiteRedirectLocation?: string;\n  /**\n   * System-defined x-amz-server-side-encryption-aws-kms-key-id metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n   */\n  readonly serverSideEncryptionAwsKmsKeyId?: string;\n  /**\n   * System-defined x-amz-server-side-encryption-customer-algorithm metadata to be set on all objects in the deployment.\n   * Warning: This is not a useful parameter until this bug is fixed: https://github.com/aws/aws-cdk/issues/6080\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html#sse-c-how-to-programmatically-intro\n   */\n  readonly serverSideEncryptionCustomerAlgorithm?: string;\n  /**\n   * System-defined x-amz-acl metadata to be set on all objects in the deployment.\n   * @default - Not set.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl\n   */\n  readonly accessControl?: s3.BucketAccessControl;\n\n  /**\n   * The VPC network to place the deployment lambda handler in.\n   * This is required if `useEfs` is set.\n   *\n   * @default None\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * Where in the VPC to place the deployment lambda handler.\n   * Only used if 'vpc' is supplied.\n   *\n   * @default - the Vpc default strategy if not specified\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n}\n\n/**\n * `BucketDeployment` populates an S3 bucket with the contents of .zip files from\n * other S3 buckets or from local disk\n */\nexport class BucketDeployment extends Construct {\n  private readonly cr: cdk.CustomResource;\n  private _deployedBucket?: s3.IBucket;\n  private requestDestinationArn: boolean = false;\n\n  constructor(scope: Construct, id: string, props: BucketDeploymentProps) {\n    super(scope, id);\n\n    if (props.distributionPaths) {\n      if (!props.distribution) {\n        throw new Error('Distribution must be specified if distribution paths are specified');\n      }\n      if (!cdk.Token.isUnresolved(props.distributionPaths)) {\n        if (!props.distributionPaths.every(distributionPath => cdk.Token.isUnresolved(distributionPath) || distributionPath.startsWith('/'))) {\n          throw new Error('Distribution paths must start with \"/\"');\n        }\n      }\n    }\n\n    if (props.useEfs && !props.vpc) {\n      throw new Error('Vpc must be specified if useEfs is set');\n    }\n\n    const accessPointPath = '/lambda';\n    let accessPoint;\n    if (props.useEfs && props.vpc) {\n      const accessMode = '0777';\n      const fileSystem = this.getOrCreateEfsFileSystem(scope, {\n        vpc: props.vpc,\n        removalPolicy: cdk.RemovalPolicy.DESTROY,\n      });\n      accessPoint = fileSystem.addAccessPoint('AccessPoint', {\n        path: accessPointPath,\n        createAcl: {\n          ownerUid: '1001',\n          ownerGid: '1001',\n          permissions: accessMode,\n        },\n        posixUser: {\n          uid: '1001',\n          gid: '1001',\n        },\n      });\n      accessPoint.node.addDependency(fileSystem.mountTargetsAvailable);\n    }\n\n    // Making VPC dependent on BucketDeployment so that CFN stack deletion is smooth.\n    // Refer comments on https://github.com/aws/aws-cdk/pull/15220 for more details.\n    if (props.vpc) {\n      this.node.addDependency(props.vpc);\n    }\n\n    const mountPath = `/mnt${accessPointPath}`;\n    const handler = new lambda.SingletonFunction(this, 'CustomResourceHandler', {\n      uuid: this.renderSingletonUuid(props.memoryLimit, props.vpc),\n      code: lambda.Code.fromAsset(path.join(__dirname, 'lambda')),\n      layers: [new AwsCliLayer(this, 'AwsCliLayer')],\n      runtime: lambda.Runtime.PYTHON_3_7,\n      environment: props.useEfs ? {\n        MOUNT_PATH: mountPath,\n      } : undefined,\n      handler: 'index.handler',\n      lambdaPurpose: 'Custom::CDKBucketDeployment',\n      timeout: cdk.Duration.minutes(15),\n      role: props.role,\n      memorySize: props.memoryLimit,\n      vpc: props.vpc,\n      vpcSubnets: props.vpcSubnets,\n      filesystem: accessPoint ? lambda.FileSystem.fromEfsAccessPoint(\n        accessPoint,\n        mountPath,\n      ) : undefined,\n      logRetention: props.logRetention,\n    });\n\n    const handlerRole = handler.role;\n    if (!handlerRole) { throw new Error('lambda.SingletonFunction should have created a Role'); }\n\n    const sources: SourceConfig[] = props.sources.map((source: ISource) => source.bind(this, { handlerRole }));\n\n    props.destinationBucket.grantReadWrite(handler);\n    if (props.distribution) {\n      handler.addToRolePolicy(new iam.PolicyStatement({\n        effect: iam.Effect.ALLOW,\n        actions: ['cloudfront:GetInvalidation', 'cloudfront:CreateInvalidation'],\n        resources: ['*'],\n      }));\n    }\n\n    // to avoid redundant stack updates, only include \"SourceMarkers\" if one of\n    // the sources actually has markers.\n    const hasMarkers = sources.some(source => source.markers);\n\n    const crUniqueId = `CustomResource${this.renderUniqueId(props.memoryLimit, props.vpc)}`;\n    this.cr = new cdk.CustomResource(this, crUniqueId, {\n      serviceToken: handler.functionArn,\n      resourceType: 'Custom::CDKBucketDeployment',\n      properties: {\n        SourceBucketNames: sources.map(source => source.bucket.bucketName),\n        SourceObjectKeys: sources.map(source => source.zipObjectKey),\n        SourceMarkers: hasMarkers ? sources.map(source => source.markers ?? {}) : undefined,\n        DestinationBucketName: props.destinationBucket.bucketName,\n        DestinationBucketKeyPrefix: props.destinationKeyPrefix,\n        RetainOnDelete: props.retainOnDelete,\n        Prune: props.prune ?? true,\n        Exclude: props.exclude,\n        Include: props.include,\n        UserMetadata: props.metadata ? mapUserMetadata(props.metadata) : undefined,\n        SystemMetadata: mapSystemMetadata(props),\n        DistributionId: props.distribution?.distributionId,\n        DistributionPaths: props.distributionPaths,\n        // Passing through the ARN sequences dependencees on the deployment\n        DestinationBucketArn: cdk.Lazy.string({ produce: () => this.requestDestinationArn ? props.destinationBucket.bucketArn : undefined }),\n      },\n    });\n\n    let prefix: string = props.destinationKeyPrefix ?\n      `:${props.destinationKeyPrefix}` :\n      '';\n    prefix += `:${this.cr.node.addr.substr(-8)}`;\n    const tagKey = CUSTOM_RESOURCE_OWNER_TAG + prefix;\n\n    // destinationKeyPrefix can be 104 characters before we hit\n    // the tag key limit of 128\n    // '/this/is/a/random/key/prefix/that/is/a/lot/of/characters/do/we/think/that/it/will/ever/be/this/long?????'\n    // better to throw an error here than wait for CloudFormation to fail\n    if (tagKey.length > 128) {\n      throw new Error('The BucketDeployment construct requires that the \"destinationKeyPrefix\" be <=104 characters');\n    }\n\n    /*\n     * This will add a tag to the deployment bucket in the format of\n     * `aws-cdk:cr-owned:{keyPrefix}:{uniqueHash}`\n     *\n     * For example:\n     * {\n     *   Key: 'aws-cdk:cr-owned:deploy/here/:240D17B3',\n     *   Value: 'true',\n     * }\n     *\n     * This will allow for scenarios where there is a single S3 Bucket that has multiple\n     * BucketDeployment resources deploying to it. Each bucket + keyPrefix can be \"owned\" by\n     * 1 or more BucketDeployment resources. Since there are some scenarios where multiple BucketDeployment\n     * resources can deploy to the same bucket and key prefix (e.g. using include/exclude) we\n     * also append part of the id to make the key unique.\n     *\n     * As long as a bucket + keyPrefix is \"owned\" by a BucketDeployment resource, another CR\n     * cannot delete data. There are a couple of scenarios where this comes into play.\n     *\n     * 1. If the LogicalResourceId of the CustomResource changes (e.g. the crUniqueId changes)\n     * CloudFormation will first issue a 'Create' to create the new CustomResource and will\n     * update the Tag on the bucket. CloudFormation will then issue a 'Delete' on the old CustomResource\n     * and since the new CR \"owns\" the Bucket+keyPrefix it will not delete the contents of the bucket\n     *\n     * 2. If the BucketDeployment resource is deleted _and_ it is the only CR for that bucket+keyPrefix\n     * then CloudFormation will first remove the tag from the bucket and then issue a \"Delete\" to the\n     * CR. Since there are no tags indicating that this bucket+keyPrefix is \"owned\" then it will delete\n     * the contents.\n     *\n     * 3. If the BucketDeployment resource is deleted _and_ it is *not* the only CR for that bucket:keyPrefix\n     * then CloudFormation will first remove the tag from the bucket and then issue a \"Delete\" to the CR.\n     * Since there are other CRs that also \"own\" that bucket+keyPrefix there will still be a tag on the bucket\n     * and the contents will not be removed.\n     *\n     * 4. If the BucketDeployment resource _and_ the S3 Bucket are both removed, then CloudFormation will first\n     * issue a \"Delete\" to the CR and since there is a tag on the bucket the contents will not be removed. If you\n     * want the contents of the bucket to be removed on bucket deletion, then `autoDeleteObjects` property should\n     * be set to true on the Bucket.\n     */\n    cdk.Tags.of(props.destinationBucket).add(tagKey, 'true');\n\n  }\n\n  /**\n   * The bucket after the deployment\n   *\n   * If you want to reference the destination bucket in another construct and make sure the\n   * bucket deployment has happened before the next operation is started, pass the other construct\n   * a reference to `deployment.deployedBucket`.\n   *\n   * Doing this replaces calling `otherResource.node.addDependency(deployment)`.\n   */\n  public get deployedBucket(): s3.IBucket {\n    this.requestDestinationArn = true;\n    this._deployedBucket = this._deployedBucket ?? s3.Bucket.fromBucketArn(this, 'DestinationBucket', cdk.Token.asString(this.cr.getAtt('DestinationBucketArn')));\n    return this._deployedBucket;\n  }\n\n  private renderUniqueId(memoryLimit?: number, vpc?: ec2.IVpc) {\n    let uuid = '';\n\n    // if user specify a custom memory limit, define another singleton handler\n    // with this configuration. otherwise, it won't be possible to use multiple\n    // configurations since we have a singleton.\n    if (memoryLimit) {\n      if (cdk.Token.isUnresolved(memoryLimit)) {\n        throw new Error('Can\\'t use tokens when specifying \"memoryLimit\" since we use it to identify the singleton custom resource handler');\n      }\n\n      uuid += `-${memoryLimit.toString()}MiB`;\n    }\n\n    // if user specify to use VPC, define another singleton handler\n    // with this configuration. otherwise, it won't be possible to use multiple\n    // configurations since we have a singleton.\n    // A VPC is a must if EFS storage is used and that's why we are only using VPC in uuid.\n    if (vpc) {\n      uuid += `-${vpc.node.addr}`;\n    }\n\n    return uuid;\n  }\n\n  private renderSingletonUuid(memoryLimit?: number, vpc?: ec2.IVpc) {\n    let uuid = '8693BB64-9689-44B6-9AAF-B0CC9EB8756C';\n\n    uuid += this.renderUniqueId(memoryLimit, vpc);\n\n    return uuid;\n  }\n\n  /**\n   * Function to get/create a stack singleton instance of EFS FileSystem per vpc.\n   *\n   * @param scope Construct\n   * @param fileSystemProps EFS FileSystemProps\n   */\n  private getOrCreateEfsFileSystem(scope: Construct, fileSystemProps: efs.FileSystemProps): efs.FileSystem {\n    const stack = cdk.Stack.of(scope);\n    const uuid = `BucketDeploymentEFS-VPC-${fileSystemProps.vpc.node.addr}`;\n    return stack.node.tryFindChild(uuid) as efs.FileSystem ?? new efs.FileSystem(scope, uuid, fileSystemProps);\n  }\n}\n\n/**\n * Metadata\n */\n\nfunction mapUserMetadata(metadata: UserDefinedObjectMetadata) {\n  const mapKey = (key: string) => key.toLowerCase();\n\n  return Object.keys(metadata).reduce((o, key) => ({ ...o, [mapKey(key)]: metadata[key] }), {});\n}\n\nfunction mapSystemMetadata(metadata: BucketDeploymentProps) {\n  const res: { [key: string]: string } = {};\n\n  if (metadata.cacheControl) { res['cache-control'] = metadata.cacheControl.map(c => c.value).join(', '); }\n  if (metadata.expires) { res.expires = metadata.expires.date.toUTCString(); }\n  if (metadata.contentDisposition) { res['content-disposition'] = metadata.contentDisposition; }\n  if (metadata.contentEncoding) { res['content-encoding'] = metadata.contentEncoding; }\n  if (metadata.contentLanguage) { res['content-language'] = metadata.contentLanguage; }\n  if (metadata.contentType) { res['content-type'] = metadata.contentType; }\n  if (metadata.serverSideEncryption) { res.sse = metadata.serverSideEncryption; }\n  if (metadata.storageClass) { res['storage-class'] = metadata.storageClass; }\n  if (metadata.websiteRedirectLocation) { res['website-redirect'] = metadata.websiteRedirectLocation; }\n  if (metadata.serverSideEncryptionAwsKmsKeyId) { res['sse-kms-key-id'] = metadata.serverSideEncryptionAwsKmsKeyId; }\n  if (metadata.serverSideEncryptionCustomerAlgorithm) { res['sse-c-copy-source'] = metadata.serverSideEncryptionCustomerAlgorithm; }\n  if (metadata.accessControl) { res.acl = toKebabCase(metadata.accessControl.toString()); }\n\n  return Object.keys(res).length === 0 ? undefined : res;\n}\n\n/**\n * Used for HTTP cache-control header, which influences downstream caches.\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n */\nexport class CacheControl {\n\n  /**\n   * Sets 'must-revalidate'.\n   */\n  public static mustRevalidate() { return new CacheControl('must-revalidate'); }\n\n  /**\n   * Sets 'no-cache'.\n   */\n  public static noCache() { return new CacheControl('no-cache'); }\n\n  /**\n   * Sets 'no-transform'.\n   */\n  public static noTransform() { return new CacheControl('no-transform'); }\n\n  /**\n   * Sets 'public'.\n   */\n  public static setPublic() { return new CacheControl('public'); }\n\n  /**\n   * Sets 'private'.\n   */\n  public static setPrivate() { return new CacheControl('private'); }\n\n  /**\n   * Sets 'proxy-revalidate'.\n   */\n  public static proxyRevalidate() { return new CacheControl('proxy-revalidate'); }\n\n  /**\n   * Sets 'max-age=<duration-in-seconds>'.\n   */\n  public static maxAge(t: cdk.Duration) { return new CacheControl(`max-age=${t.toSeconds()}`); }\n\n  /**\n   * Sets 's-maxage=<duration-in-seconds>'.\n   */\n  public static sMaxAge(t: cdk.Duration) { return new CacheControl(`s-maxage=${t.toSeconds()}`); }\n\n  /**\n   * Constructs a custom cache control key from the literal value.\n   */\n  public static fromString(s: string) { return new CacheControl(s); }\n\n  private constructor(\n    /**\n     * The raw cache control setting.\n     */\n    public readonly value: any,\n  ) { }\n}\n\n/**\n * Indicates whether server-side encryption is enabled for the object, and whether that encryption is\n * from the AWS Key Management Service (AWS KMS) or from Amazon S3 managed encryption (SSE-S3).\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n */\nexport enum ServerSideEncryption {\n\n  /**\n   * 'AES256'\n   */\n  AES_256 = 'AES256',\n\n  /**\n   * 'aws:kms'\n   */\n  AWS_KMS = 'aws:kms'\n}\n\n/**\n * Storage class used for storing the object.\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n */\nexport enum StorageClass {\n\n  /**\n   * 'STANDARD'\n   */\n  STANDARD = 'STANDARD',\n\n  /**\n   * 'REDUCED_REDUNDANCY'\n   */\n  REDUCED_REDUNDANCY = 'REDUCED_REDUNDANCY',\n\n  /**\n   * 'STANDARD_IA'\n   */\n  STANDARD_IA = 'STANDARD_IA',\n\n  /**\n   * 'ONEZONE_IA'\n   */\n  ONEZONE_IA = 'ONEZONE_IA',\n\n  /**\n   * 'INTELLIGENT_TIERING'\n   */\n  INTELLIGENT_TIERING = 'INTELLIGENT_TIERING',\n\n  /**\n   * 'GLACIER'\n   */\n  GLACIER = 'GLACIER',\n\n  /**\n   * 'DEEP_ARCHIVE'\n   */\n  DEEP_ARCHIVE = 'DEEP_ARCHIVE'\n}\n\n/**\n * Used for HTTP expires header, which influences downstream caches. Does NOT influence deletion of the object.\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n *\n * @deprecated use core.Expiration\n */\nexport class Expires {\n  /**\n   * Expire at the specified date\n   * @param d date to expire at\n   */\n  public static atDate(d: Date) { return new Expires(d.toUTCString()); }\n\n  /**\n   * Expire at the specified timestamp\n   * @param t timestamp in unix milliseconds\n   */\n  public static atTimestamp(t: number) { return Expires.atDate(new Date(t)); }\n\n  /**\n   * Expire once the specified duration has passed since deployment time\n   * @param t the duration to wait before expiring\n   */\n  public static after(t: cdk.Duration) { return Expires.atDate(new Date(Date.now() + t.toMilliseconds())); }\n\n  /**\n   * Create an expiration date from a raw date string.\n   */\n  public static fromString(s: string) { return new Expires(s); }\n\n  private constructor(\n    /**\n     * The raw expiration date expression.\n     */\n    public readonly value: any,\n  ) { }\n}\n\n/**\n * Custom user defined metadata.\n */\nexport interface UserDefinedObjectMetadata {\n  /**\n   * Arbitrary metadata key-values\n   * The `x-amz-meta-` prefix will automatically be added to keys.\n   * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#UserMetadata\n   */\n  readonly [key: string]: string;\n}\n"],
  "mappings": "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",
  "names": []
}
