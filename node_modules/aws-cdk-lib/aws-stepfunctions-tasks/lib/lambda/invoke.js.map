{
  "version": 3,
  "sources": ["invoke.ts"],
  "sourcesContent": ["import * as iam from '../../../aws-iam';\nimport * as lambda from '../../../aws-lambda';\nimport * as sfn from '../../../aws-stepfunctions';\nimport * as cdk from '../../../core';\nimport { Construct } from 'constructs';\nimport { integrationResourceArn, validatePatternSupported } from '../private/task-utils';\n\n/**\n * Properties for invoking a Lambda function with LambdaInvoke\n */\nexport interface LambdaInvokeProps extends sfn.TaskStateBaseProps {\n\n  /**\n   * Lambda function to invoke\n   */\n  readonly lambdaFunction: lambda.IFunction;\n\n  /**\n   * The JSON that will be supplied as input to the Lambda function\n   *\n   * @default - The state input (JSON path '$')\n   */\n  readonly payload?: sfn.TaskInput;\n\n  /**\n   * Invocation type of the Lambda function\n   *\n   * @default InvocationType.REQUEST_RESPONSE\n   */\n  readonly invocationType?: LambdaInvocationType;\n\n  /**\n   * Up to 3583 bytes of base64-encoded data about the invoking client\n   * to pass to the function.\n   *\n   * @default - No context\n   */\n  readonly clientContext?: string;\n\n  /**\n   * Version or alias to invoke a published version of the function\n   *\n   * You only need to supply this if you want the version of the Lambda Function to depend\n   * on data in the state machine state. If not, you can pass the appropriate Alias or Version object\n   * directly as the `lambdaFunction` argument.\n   *\n   * @default - Version or alias inherent to the `lambdaFunction` object.\n   */\n  readonly qualifier?: string;\n\n  /**\n   * Invoke the Lambda in a way that only returns the payload response without additional metadata.\n   *\n   * The `payloadResponseOnly` property cannot be used if `integrationPattern`, `invocationType`,\n   * `clientContext`, or `qualifier` are specified.\n   * It always uses the REQUEST_RESPONSE behavior.\n   *\n   * @default false\n   */\n  readonly payloadResponseOnly?: boolean;\n\n  /**\n   * Whether to retry on Lambda service exceptions.\n   *\n   * This handles `Lambda.ServiceException`, `Lambda.AWSLambdaException` and\n   * `Lambda.SdkClientException` with an interval of 2 seconds, a back-off rate\n   * of 2 and 6 maximum attempts.\n   *\n   * @see https://docs.aws.amazon.com/step-functions/latest/dg/bp-lambda-serviceexception.html\n   *\n   * @default true\n   */\n  readonly retryOnServiceExceptions?: boolean;\n}\n\n/**\n * Invoke a Lambda function as a Task\n *\n * @see https://docs.aws.amazon.com/step-functions/latest/dg/connect-lambda.html\n */\nexport class LambdaInvoke extends sfn.TaskStateBase {\n\n  private static readonly SUPPORTED_INTEGRATION_PATTERNS: sfn.IntegrationPattern[] = [\n    sfn.IntegrationPattern.REQUEST_RESPONSE,\n    sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,\n  ];\n\n  protected readonly taskMetrics?: sfn.TaskMetricsConfig;\n  protected readonly taskPolicies?: iam.PolicyStatement[];\n\n  private readonly integrationPattern: sfn.IntegrationPattern;\n\n  constructor(scope: Construct, id: string, private readonly props: LambdaInvokeProps) {\n    super(scope, id, props);\n    this.integrationPattern = props.integrationPattern ?? sfn.IntegrationPattern.REQUEST_RESPONSE;\n\n    validatePatternSupported(this.integrationPattern, LambdaInvoke.SUPPORTED_INTEGRATION_PATTERNS);\n\n    if (this.integrationPattern === sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN\n      && !sfn.FieldUtils.containsTaskToken(props.payload)) {\n      throw new Error('Task Token is required in `payload` for callback. Use JsonPath.taskToken to set the token.');\n    }\n\n    if (props.payloadResponseOnly &&\n      (props.integrationPattern || props.invocationType || props.clientContext || props.qualifier)) {\n      throw new Error(\n        \"The 'payloadResponseOnly' property cannot be used if 'integrationPattern', 'invocationType', 'clientContext', or 'qualifier' are specified.\",\n      );\n    }\n\n    this.taskMetrics = {\n      metricPrefixSingular: 'LambdaFunction',\n      metricPrefixPlural: 'LambdaFunctions',\n      metricDimensions: {\n        LambdaFunctionArn: this.props.lambdaFunction.functionArn,\n        ...(this.props.qualifier && { Qualifier: this.props.qualifier }),\n      },\n    };\n\n    this.taskPolicies = [\n      new iam.PolicyStatement({\n        resources: [this.props.lambdaFunction.functionArn],\n        actions: ['lambda:InvokeFunction'],\n      }),\n    ];\n\n    if (props.retryOnServiceExceptions ?? true) {\n      // Best practice from https://docs.aws.amazon.com/step-functions/latest/dg/bp-lambda-serviceexception.html\n      this.addRetry({\n        errors: ['Lambda.ServiceException', 'Lambda.AWSLambdaException', 'Lambda.SdkClientException'],\n        interval: cdk.Duration.seconds(2),\n        maxAttempts: 6,\n        backoffRate: 2,\n      });\n    }\n  }\n\n  /**\n   * Provides the Lambda Invoke service integration task configuration\n   */\n  /**\n   * @internal\n   */\n  protected _renderTask(): any {\n    if (this.props.payloadResponseOnly) {\n      return {\n        Resource: this.props.lambdaFunction.functionArn,\n        ...this.props.payload && { Parameters: sfn.FieldUtils.renderObject(this.props.payload.value) },\n      };\n    } else {\n      return {\n        Resource: integrationResourceArn('lambda', 'invoke', this.integrationPattern),\n        Parameters: sfn.FieldUtils.renderObject({\n          FunctionName: this.props.lambdaFunction.functionArn,\n          Payload: this.props.payload ? this.props.payload.value : sfn.TaskInput.fromJsonPathAt('$').value,\n          InvocationType: this.props.invocationType,\n          ClientContext: this.props.clientContext,\n          Qualifier: this.props.qualifier,\n        }),\n      };\n    }\n  }\n}\n\n/**\n * Invocation type of a Lambda\n */\nexport enum LambdaInvocationType {\n  /**\n   * Invoke the function synchronously.\n   *\n   * Keep the connection open until the function returns a response or times out.\n   * The API response includes the function response and additional data.\n   */\n  REQUEST_RESPONSE = 'RequestResponse',\n\n  /**\n   * Invoke the function asynchronously.\n   *\n   * Send events that fail multiple times to the function's dead-letter queue (if it's configured).\n   * The API response only includes a status code.\n   */\n  EVENT = 'Event',\n\n  /**\n   * Validate parameter values and verify that the user or role has permission to invoke the function.\n   */\n  DRY_RUN = 'DryRun'\n}\n"],
  "mappings": "mPAAA,IAAA,QAAA,oBAEA,IAAA,QAAA,8BACA,IAAA,QAAA,iBAEA,aAAA,QAAA,yBA2EA,0BAAkC,KAAI,aAAa,CAYjD,YAAY,MAAkB,GAA6B,MAAwB,WACjF,MAAM,MAAO,GAAI,OAKjB,GANyD,KAAA,MAAA,2FAEzD,KAAK,mBAAkB,IAAG,MAAM,sBAAkB,MAAA,KAAA,OAAA,GAAI,IAAI,mBAAmB,iBAE7E,aAAA,yBAAyB,KAAK,mBAAoB,aAAa,gCAE3D,KAAK,qBAAuB,IAAI,mBAAmB,qBAClD,CAAC,IAAI,WAAW,kBAAkB,MAAM,SAC3C,KAAM,IAAI,OAAM,8FAGlB,GAAI,MAAM,qBACP,OAAM,oBAAsB,MAAM,gBAAkB,MAAM,eAAiB,MAAM,WAClF,KAAM,IAAI,OACR,+IAIJ,KAAK,YAAc,CACjB,qBAAsB,iBACtB,mBAAoB,kBACpB,iBAAkB,CAChB,kBAAmB,KAAK,MAAM,eAAe,eACzC,KAAK,MAAM,WAAa,CAAE,UAAW,KAAK,MAAM,aAIxD,KAAK,aAAe,CAClB,GAAI,KAAI,gBAAgB,CACtB,UAAW,CAAC,KAAK,MAAM,eAAe,aACtC,QAAS,CAAC,4BAId,KAAI,MAAM,4BAAwB,MAAA,KAAA,OAAA,GAAI,KAEpC,KAAK,SAAS,CACZ,OAAQ,CAAC,0BAA2B,4BAA6B,6BACjE,SAAU,IAAI,SAAS,QAAQ,GAC/B,YAAa,EACb,YAAa,IAWT,aAAW,CACnB,MAAI,MAAK,MAAM,oBACN,CACL,SAAU,KAAK,MAAM,eAAe,eACjC,KAAK,MAAM,SAAW,CAAE,WAAY,IAAI,WAAW,aAAa,KAAK,MAAM,QAAQ,SAGjF,CACL,SAAU,aAAA,uBAAuB,SAAU,SAAU,KAAK,oBAC1D,WAAY,IAAI,WAAW,aAAa,CACtC,aAAc,KAAK,MAAM,eAAe,YACxC,QAAS,KAAK,MAAM,QAAU,KAAK,MAAM,QAAQ,MAAQ,IAAI,UAAU,eAAe,KAAK,MAC3F,eAAgB,KAAK,MAAM,eAC3B,cAAe,KAAK,MAAM,cAC1B,UAAW,KAAK,MAAM,cA7EhC,QAAA,aAAA,8HAE0B,aAAA,+BAA2D,CACjF,IAAI,mBAAmB,iBACvB,IAAI,mBAAmB,qBAmF3B,GAAY,sBAAZ,AAAA,UAAY,sBAAoB,CAO9B,sBAAA,iBAAA,kBAQA,sBAAA,MAAA,QAKA,sBAAA,QAAA,WApBU,qBAAA,QAAA,sBAAA,SAAA,qBAAoB",
  "names": []
}
