{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { ArnFormat, Stack, Token } from '../../core';\nimport { IConstruct } from 'constructs';\n\nexport const AUTOGEN_MARKER = '$$autogen$$';\n\nexport interface ArnForParameterNameOptions {\n  readonly physicalName?: string;\n  readonly simpleName?: boolean;\n}\n\n/**\n * Renders an ARN for an SSM parameter given a parameter name.\n * @param scope definition scope\n * @param parameterName the parameter name to include in the ARN\n * @param physicalName optional physical name specified by the user (to auto-detect separator)\n */\nexport function arnForParameterName(scope: IConstruct, parameterName: string, options: ArnForParameterNameOptions = { }): string {\n  const physicalName = options.physicalName;\n  const nameToValidate = physicalName || parameterName;\n\n  if (!Token.isUnresolved(nameToValidate) && nameToValidate.includes('/') && !nameToValidate.startsWith('/')) {\n    throw new Error(`Parameter names must be fully qualified (if they include \"/\" they must also begin with a \"/\"): ${nameToValidate}`);\n  }\n\n  if (isSimpleName()) {\n    return Stack.of(scope).formatArn({\n      service: 'ssm',\n      resource: 'parameter',\n      arnFormat: ArnFormat.SLASH_RESOURCE_NAME,\n      resourceName: parameterName,\n    });\n  } else {\n    return Stack.of(scope).formatArn({\n      service: 'ssm',\n      resource: `parameter${parameterName}`,\n    });\n  }\n\n  /**\n   * Determines the ARN separator for this parameter: if we have a concrete\n   * parameter name (or explicitly defined physical name), we will parse them\n   * and decide whether a \"/\" is needed or not. Otherwise, users will have to\n   * explicitly specify `simpleName` when they import the ARN.\n   */\n  function isSimpleName(): boolean {\n    // look for a concrete name as a hint for determining the separator\n    const concreteName = !Token.isUnresolved(parameterName) ? parameterName : physicalName;\n    if (!concreteName || Token.isUnresolved(concreteName)) {\n\n      if (options.simpleName === undefined) {\n        throw new Error('Unable to determine ARN separator for SSM parameter since the parameter name is an unresolved token. Use \"fromAttributes\" and specify \"simpleName\" explicitly');\n      }\n\n      return options.simpleName;\n    }\n\n    const result = !concreteName.startsWith('/');\n\n    // if users explicitly specify the separator and it conflicts with the one we need, it's an error.\n    if (options.simpleName !== undefined && options.simpleName !== result) {\n\n      if (concreteName === AUTOGEN_MARKER) {\n        throw new Error('If \"parameterName\" is not explicitly defined, \"simpleName\" must be \"true\" or undefined since auto-generated parameter names always have simple names');\n      }\n\n      throw new Error(`Parameter name \"${concreteName}\" is ${result ? 'a simple name' : 'not a simple name'}, but \"simpleName\" was explicitly set to ${options.simpleName}. Either omit it or set it to ${result}`);\n    }\n\n    return result;\n  }\n}\n"],
  "mappings": "8HAAA,KAAA,QAAA,QAAA,cAGa,QAAA,eAAiB,cAa9B,6BAAoC,MAAmB,cAAuB,QAAsC,GAAG,CACrH,KAAM,cAAe,QAAQ,aACvB,eAAiB,cAAgB,cAEvC,GAAI,CAAC,OAAA,MAAM,aAAa,iBAAmB,eAAe,SAAS,MAAQ,CAAC,eAAe,WAAW,KACpG,KAAM,IAAI,OAAM,kGAAkG,kBAGpH,GAAI,eACF,MAAO,QAAA,MAAM,GAAG,OAAO,UAAU,CAC/B,QAAS,MACT,SAAU,YACV,UAAW,OAAA,UAAU,oBACrB,aAAc,gBAGhB,MAAO,QAAA,MAAM,GAAG,OAAO,UAAU,CAC/B,QAAS,MACT,SAAU,YAAY,kBAU1B,uBAAqB,CAEnB,KAAM,cAAe,AAAC,OAAA,MAAM,aAAa,eAAiC,aAAhB,cAC1D,GAAI,CAAC,cAAgB,OAAA,MAAM,aAAa,cAAe,CAErD,GAAI,QAAQ,aAAe,OACzB,KAAM,IAAI,OAAM,iKAGlB,MAAO,SAAQ,WAGjB,KAAM,QAAS,CAAC,aAAa,WAAW,KAGxC,GAAI,QAAQ,aAAe,QAAa,QAAQ,aAAe,OAE7D,KAAI,gBAAiB,QAAA,eACb,GAAI,OAAM,wJAGZ,GAAI,OAAM,mBAAmB,oBAAoB,OAAS,gBAAkB,+DAA+D,QAAQ,2CAA2C,UAGtM,MAAO,SApDX,QAAA,oBAAA",
  "names": []
}
