{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import * as cxschema from '../../../cloud-assembly-schema';\nimport { ApplicationProtocol, Protocol } from './enums';\n\nexport type Attributes = { [key: string]: string | undefined };\n\n/**\n * Render an attribute dict to a list of { key, value } pairs\n */\nexport function renderAttributes(attributes: Attributes) {\n  const ret: any[] = [];\n  for (const [key, value] of Object.entries(attributes)) {\n    if (value !== undefined) {\n      ret.push({ key, value });\n    }\n  }\n  return ret;\n}\n\n/**\n * Return the appropriate default port for a given protocol\n */\nexport function defaultPortForProtocol(proto: ApplicationProtocol): number {\n  switch (proto) {\n    case ApplicationProtocol.HTTP: return 80;\n    case ApplicationProtocol.HTTPS: return 443;\n    default:\n      throw new Error(`Unrecognized protocol: ${proto}`);\n  }\n}\n\n/**\n * Return the appropriate default protocol for a given port\n */\nexport function defaultProtocolForPort(port: number): ApplicationProtocol {\n  switch (port) {\n    case 80:\n    case 8000:\n    case 8008:\n    case 8080:\n      return ApplicationProtocol.HTTP;\n\n    case 443:\n    case 8443:\n      return ApplicationProtocol.HTTPS;\n\n    default:\n      throw new Error(`Don't know default protocol for port: ${port}; please supply a protocol`);\n  }\n}\n\n/**\n * Given a protocol and a port, try to guess the other one if it's undefined\n */\n// eslint-disable-next-line max-len\nexport function determineProtocolAndPort(protocol: ApplicationProtocol | undefined, port: number | undefined): [ApplicationProtocol | undefined, number | undefined] {\n  if (protocol === undefined && port === undefined) {\n    return [undefined, undefined];\n  }\n\n  if (protocol === undefined) { protocol = defaultProtocolForPort(port!); }\n  if (port === undefined) { port = defaultPortForProtocol(protocol!); }\n\n  return [protocol, port];\n}\n\n/**\n * Helper function to default undefined input props\n */\nexport function ifUndefined<T>(x: T | undefined, def: T) {\n  return x ?? def;\n}\n\n/**\n * Helper function for ensuring network listeners and target groups only accept valid\n * protocols.\n */\nexport function validateNetworkProtocol(protocol: Protocol) {\n  const NLB_PROTOCOLS = [Protocol.TCP, Protocol.TLS, Protocol.UDP, Protocol.TCP_UDP];\n\n  if (NLB_PROTOCOLS.indexOf(protocol) === -1) {\n    throw new Error(`The protocol must be one of ${NLB_PROTOCOLS.join(', ')}. Found ${protocol}`);\n  }\n}\n\n/**\n * Helper to map a map of tags to cxschema tag format.\n * @internal\n */\nexport function mapTagMapToCxschema(tagMap: Record<string, string>): cxschema.Tag[] {\n  return Object.entries(tagMap)\n    .map(([key, value]) => ({ key, value }));\n}\n"],
  "mappings": "mRACA,KAAA,SAAA,QAAA,WAOA,0BAAiC,WAAsB,CACrD,KAAM,KAAa,GACnB,SAAW,CAAC,IAAK,QAAU,QAAO,QAAQ,YACxC,AAAI,QAAU,QACZ,IAAI,KAAK,CAAE,IAAK,QAGpB,MAAO,KAPT,QAAA,iBAAA,iBAaA,gCAAuC,MAA0B,CAC/D,OAAQ,WACD,SAAA,oBAAoB,KAAM,MAAO,QACjC,SAAA,oBAAoB,MAAO,MAAO,aAErC,KAAM,IAAI,OAAM,0BAA0B,UALhD,QAAA,uBAAA,uBAYA,gCAAuC,KAAY,CACjD,OAAQ,UACD,QACA,SACA,UACA,MACH,MAAO,SAAA,oBAAoB,SAExB,SACA,MACH,MAAO,SAAA,oBAAoB,cAG3B,KAAM,IAAI,OAAM,yCAAyC,mCAb/D,QAAA,uBAAA,uBAqBA,kCAAyC,SAA2C,KAAwB,CAC1G,MAAI,YAAa,QAAa,OAAS,OAC9B,CAAC,OAAW,QAGjB,YAAa,QAAa,UAAW,uBAAuB,OAC5D,OAAS,QAAa,MAAO,uBAAuB,WAEjD,CAAC,SAAU,OARpB,QAAA,yBAAA,yBAcA,qBAA+B,EAAkB,IAAM,CACrD,MAAO,IAAC,KAAD,EAAK,IADd,QAAA,YAAA,YAQA,iCAAwC,SAAkB,CACxD,KAAM,eAAgB,CAAC,QAAA,SAAS,IAAK,QAAA,SAAS,IAAK,QAAA,SAAS,IAAK,QAAA,SAAS,SAE1E,GAAI,cAAc,QAAQ,YAAc,GACtC,KAAM,IAAI,OAAM,+BAA+B,cAAc,KAAK,gBAAgB,YAJtF,QAAA,wBAAA,wBAYA,6BAAoC,OAA8B,CAChE,MAAO,QAAO,QAAQ,QACnB,IAAI,CAAC,CAAC,IAAK,SAAY,EAAE,IAAK,SAFnC,QAAA,oBAAA",
  "names": []
}
