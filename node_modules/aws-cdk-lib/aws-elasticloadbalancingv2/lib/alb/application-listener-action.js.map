{
  "version": 3,
  "sources": ["application-listener-action.ts"],
  "sourcesContent": ["import { Duration, SecretValue, Tokenization } from '../../../core';\nimport { IConstruct } from 'constructs';\nimport { CfnListener } from '../elasticloadbalancingv2.generated';\nimport { IListenerAction } from '../shared/listener-action';\nimport { IApplicationListener } from './application-listener';\nimport { IApplicationTargetGroup } from './application-target-group';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n/**\n * What to do when a client makes a request to a listener\n *\n * Some actions can be combined with other ones (specifically,\n * you can perform authentication before serving the request).\n *\n * Multiple actions form a linked chain; the chain must always terminate in a\n * *(weighted)forward*, *fixedResponse* or *redirect* action.\n *\n * If an action supports chaining, the next action can be indicated\n * by passing it in the `next` property.\n *\n * (Called `ListenerAction` instead of the more strictly correct\n * `ListenerAction` because this is the class most users interact\n * with, and we want to make it not too visually overwhelming).\n */\nexport class ListenerAction implements IListenerAction {\n  /**\n   * Authenticate using an identity provider (IdP) that is compliant with OpenID Connect (OIDC)\n   *\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/listener-authenticate-users.html#oidc-requirements\n   */\n  public static authenticateOidc(options: AuthenticateOidcOptions): ListenerAction {\n    return new ListenerAction({\n      type: 'authenticate-oidc',\n      authenticateOidcConfig: {\n        authorizationEndpoint: options.authorizationEndpoint,\n        clientId: options.clientId,\n        clientSecret: options.clientSecret.toString(),\n        issuer: options.issuer,\n        tokenEndpoint: options.tokenEndpoint,\n        userInfoEndpoint: options.userInfoEndpoint,\n        authenticationRequestExtraParams: options.authenticationRequestExtraParams,\n        onUnauthenticatedRequest: options.onUnauthenticatedRequest,\n        scope: options.scope,\n        sessionCookieName: options.sessionCookieName,\n        sessionTimeout: options.sessionTimeout?.toSeconds().toString(),\n      },\n    }, options.next);\n  }\n\n  /**\n   * Forward to one or more Target Groups\n   *\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#forward-actions\n   */\n  public static forward(targetGroups: IApplicationTargetGroup[], options: ForwardOptions = {}): ListenerAction {\n    if (targetGroups.length === 0) {\n      throw new Error('Need at least one targetGroup in a ListenerAction.forward()');\n    }\n    if (targetGroups.length === 1 && options.stickinessDuration === undefined) {\n      // Render a \"simple\" action for backwards compatibility with old templates\n      return new TargetGroupListenerAction(targetGroups, {\n        type: 'forward',\n        targetGroupArn: targetGroups[0].targetGroupArn,\n      });\n    }\n\n    return new TargetGroupListenerAction(targetGroups, {\n      type: 'forward',\n      forwardConfig: {\n        targetGroups: targetGroups.map(g => ({ targetGroupArn: g.targetGroupArn })),\n        targetGroupStickinessConfig: options.stickinessDuration ? {\n          durationSeconds: options.stickinessDuration.toSeconds(),\n          enabled: true,\n        } : undefined,\n      },\n    });\n  }\n\n  /**\n   * Forward to one or more Target Groups which are weighted differently\n   *\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#forward-actions\n   */\n  public static weightedForward(targetGroups: WeightedTargetGroup[], options: ForwardOptions = {}): ListenerAction {\n    if (targetGroups.length === 0) {\n      throw new Error('Need at least one targetGroup in a ListenerAction.weightedForward()');\n    }\n\n    return new TargetGroupListenerAction(targetGroups.map(g => g.targetGroup), {\n      type: 'forward',\n      forwardConfig: {\n        targetGroups: targetGroups.map(g => ({ targetGroupArn: g.targetGroup.targetGroupArn, weight: g.weight })),\n        targetGroupStickinessConfig: options.stickinessDuration ? {\n          durationSeconds: options.stickinessDuration.toSeconds(),\n          enabled: true,\n        } : undefined,\n      },\n    });\n  }\n\n  /**\n   * Return a fixed response\n   *\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#fixed-response-actions\n   */\n  public static fixedResponse(statusCode: number, options: FixedResponseOptions = {}): ListenerAction {\n    return new ListenerAction({\n      type: 'fixed-response',\n      fixedResponseConfig: {\n        statusCode: Tokenization.stringifyNumber(statusCode),\n        contentType: options.contentType,\n        messageBody: options.messageBody,\n      },\n    });\n  }\n\n  /**\n   * Redirect to a different URI\n   *\n   * A URI consists of the following components:\n   * protocol://hostname:port/path?query. You must modify at least one of the\n   * following components to avoid a redirect loop: protocol, hostname, port, or\n   * path. Any components that you do not modify retain their original values.\n   *\n   * You can reuse URI components using the following reserved keywords:\n   *\n   * - `#{protocol}`\n   * - `#{host}`\n   * - `#{port}`\n   * - `#{path}` (the leading \"/\" is removed)\n   * - `#{query}`\n   *\n   * For example, you can change the path to \"/new/#{path}\", the hostname to\n   * \"example.#{host}\", or the query to \"#{query}&value=xyz\".\n   *\n   * @see https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#redirect-actions\n   */\n  public static redirect(options: RedirectOptions): ListenerAction {\n    if ([options.host, options.path, options.port, options.protocol, options.query].findIndex(x => x !== undefined) === -1) {\n      throw new Error('To prevent redirect loops, set at least one of \\'protocol\\', \\'host\\', \\'port\\', \\'path\\', or \\'query\\'.');\n    }\n\n    return new ListenerAction({\n      type: 'redirect',\n      redirectConfig: {\n        statusCode: options.permanent ? 'HTTP_301' : 'HTTP_302',\n        host: options.host,\n        path: options.path,\n        port: options.port,\n        protocol: options.protocol,\n        query: options.query,\n      },\n    });\n  }\n\n  /**\n   * Create an instance of ListenerAction\n   *\n   * The default class should be good enough for most cases and\n   * should be created by using one of the static factory functions,\n   * but allow overriding to make sure we allow flexibility for the future.\n   */\n  protected constructor(private readonly actionJson: CfnListener.ActionProperty, protected readonly next?: ListenerAction) {\n  }\n\n  /**\n   * Render the actions in this chain\n   */\n  public renderActions(): CfnListener.ActionProperty[] {\n    return this.renumber([this.actionJson, ...this.next?.renderActions() ?? []]);\n  }\n\n  /**\n   * Called when the action is being used in a listener\n   */\n  public bind(scope: Construct, listener: IApplicationListener, associatingConstruct?: IConstruct) {\n    // Empty on purpose\n    Array.isArray(scope);\n    Array.isArray(listener);\n    Array.isArray(associatingConstruct);\n  }\n\n  /**\n   * Renumber the \"order\" fields in the actions array.\n   *\n   * We don't number for 0 or 1 elements, but otherwise number them 1...#actions\n   * so ELB knows about the right order.\n   *\n   * Do this in `ListenerAction` instead of in `Listener` so that we give\n   * users the opportunity to override by subclassing and overriding `renderActions`.\n   */\n  protected renumber(actions: CfnListener.ActionProperty[]): CfnListener.ActionProperty[] {\n    if (actions.length < 2) { return actions; }\n\n    return actions.map((action, i) => ({ ...action, order: i + 1 }));\n  }\n}\n\n/**\n * Options for `ListenerAction.forward()`\n */\nexport interface ForwardOptions {\n  /**\n   * For how long clients should be directed to the same target group\n   *\n   * Range between 1 second and 7 days.\n   *\n   * @default - No stickiness\n   */\n  readonly stickinessDuration?: Duration;\n}\n\n/**\n * A Target Group and weight combination\n */\nexport interface WeightedTargetGroup {\n  /**\n   * The target group\n   */\n  readonly targetGroup: IApplicationTargetGroup;\n\n  /**\n   * The target group's weight\n   *\n   * Range is [0..1000).\n   *\n   * @default 1\n   */\n  readonly weight?: number;\n}\n\n/**\n * Options for `ListenerAction.fixedResponse()`\n */\nexport interface FixedResponseOptions {\n  /**\n   * Content Type of the response\n   *\n   * Valid Values: text/plain | text/css | text/html | application/javascript | application/json\n   *\n   * @default - Automatically determined\n   */\n  readonly contentType?: string;\n\n  /**\n   * The response body\n   *\n   * @default - No body\n   */\n  readonly messageBody?: string;\n}\n\n/**\n * Options for `ListenerAction.redirect()`\n *\n * A URI consists of the following components:\n * protocol://hostname:port/path?query. You must modify at least one of the\n * following components to avoid a redirect loop: protocol, hostname, port, or\n * path. Any components that you do not modify retain their original values.\n *\n * You can reuse URI components using the following reserved keywords:\n *\n * - `#{protocol}`\n * - `#{host}`\n * - `#{port}`\n * - `#{path}` (the leading \"/\" is removed)\n * - `#{query}`\n *\n * For example, you can change the path to \"/new/#{path}\", the hostname to\n * \"example.#{host}\", or the query to \"#{query}&value=xyz\".\n */\nexport interface RedirectOptions {\n  /**\n   * The hostname.\n   *\n   * This component is not percent-encoded. The hostname can contain #{host}.\n   *\n   * @default - No change\n   */\n  readonly host?: string;\n\n  /**\n   * The absolute path, starting with the leading \"/\".\n   *\n   * This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}.\n   *\n   * @default - No change\n   */\n  readonly path?: string;\n\n  /**\n   * The port.\n   *\n   * You can specify a value from 1 to 65535 or #{port}.\n   *\n   * @default - No change\n   */\n  readonly port?: string;\n\n  /**\n   * The protocol.\n   *\n   * You can specify HTTP, HTTPS, or #{protocol}. You can redirect HTTP to HTTP, HTTP to HTTPS, and HTTPS to HTTPS. You cannot redirect HTTPS to HTTP.\n   *\n   * @default - No change\n   */\n  readonly protocol?: string;\n\n  /**\n   * The query parameters, URL-encoded when necessary, but not percent-encoded.\n   *\n   * Do not include the leading \"?\", as it is automatically added. You can specify any of the reserved keywords.\n   *\n   * @default - No change\n   */\n  readonly query?: string;\n\n  /**\n   * The HTTP redirect code.\n   *\n   * The redirect is either permanent (HTTP 301) or temporary (HTTP 302).\n   *\n   * @default false\n   */\n  readonly permanent?: boolean;\n}\n\n/**\n * Options for `ListenerAction.authenciateOidc()`\n */\nexport interface AuthenticateOidcOptions {\n  /**\n   * What action to execute next\n   */\n  readonly next: ListenerAction;\n\n  /**\n   * The query parameters (up to 10) to include in the redirect request to the authorization endpoint.\n   *\n   * @default - No extra parameters\n   */\n  readonly authenticationRequestExtraParams?: Record<string, string>;\n\n  /**\n   * The authorization endpoint of the IdP.\n   *\n   * This must be a full URL, including the HTTPS protocol, the domain, and the path.\n   */\n  readonly authorizationEndpoint: string;\n\n  /**\n   * The OAuth 2.0 client identifier.\n   */\n  readonly clientId: string;\n\n  /**\n   * The OAuth 2.0 client secret.\n   */\n  readonly clientSecret: SecretValue;\n\n  /**\n   * The OIDC issuer identifier of the IdP.\n   *\n   * This must be a full URL, including the HTTPS protocol, the domain, and the path.\n   */\n  readonly issuer: string;\n\n  /**\n   * The behavior if the user is not authenticated.\n   *\n   * @default UnauthenticatedAction.AUTHENTICATE\n   */\n  readonly onUnauthenticatedRequest?: UnauthenticatedAction;\n\n  /**\n   * The set of user claims to be requested from the IdP.\n   *\n   * To verify which scope values your IdP supports and how to separate multiple values, see the documentation for your IdP.\n   *\n   * @default \"openid\"\n   */\n  readonly scope?: string;\n\n  /**\n   * The name of the cookie used to maintain session information.\n   *\n   * @default \"AWSELBAuthSessionCookie\"\n   */\n  readonly sessionCookieName?: string;\n\n  /**\n   * The maximum duration of the authentication session.\n   *\n   * @default Duration.days(7)\n   */\n  readonly sessionTimeout?: Duration;\n\n  /**\n   * The token endpoint of the IdP.\n   *\n   * This must be a full URL, including the HTTPS protocol, the domain, and the path.\n   */\n  readonly tokenEndpoint: string;\n\n  /**\n   * The user info endpoint of the IdP.\n   *\n   * This must be a full URL, including the HTTPS protocol, the domain, and the path.\n   */\n  readonly userInfoEndpoint: string;\n}\n\n/**\n * What to do with unauthenticated requests\n */\nexport enum UnauthenticatedAction {\n  /**\n   * Return an HTTP 401 Unauthorized error.\n   */\n  DENY = 'deny',\n\n  /**\n   * Allow the request to be forwarded to the target.\n   */\n  ALLOW = 'allow',\n\n  /**\n   * Redirect the request to the IdP authorization endpoint.\n   */\n  AUTHENTICATE = 'authenticate',\n}\n\n/**\n * Listener Action that calls \"registerListener\" on TargetGroups\n */\nclass TargetGroupListenerAction extends ListenerAction {\n  constructor(private readonly targetGroups: IApplicationTargetGroup[], actionJson: CfnListener.ActionProperty) {\n    super(actionJson);\n  }\n\n  public bind(_scope: Construct, listener: IApplicationListener, associatingConstruct?: IConstruct) {\n    for (const tg of this.targetGroups) {\n      tg.registerListener(listener, associatingConstruct);\n    }\n  }\n}\n"],
  "mappings": "sPAAA,OAAA,QAAA,iBA2BA,oBAA2B,CA0IzB,YAAuC,WAA2D,KAAqB,CAAhF,KAAA,WAAA,WAA2D,KAAA,KAAA,qMApIpF,kBAAiB,QAAgC,+GACtD,GAAI,gBAAe,CACxB,KAAM,oBACN,uBAAwB,CACtB,sBAAuB,QAAQ,sBAC/B,SAAU,QAAQ,SAClB,aAAc,QAAQ,aAAa,WACnC,OAAQ,QAAQ,OAChB,cAAe,QAAQ,cACvB,iBAAkB,QAAQ,iBAC1B,iCAAkC,QAAQ,iCAC1C,yBAA0B,QAAQ,yBAClC,MAAO,QAAQ,MACf,kBAAmB,QAAQ,kBAC3B,eAAc,IAAE,QAAQ,kBAAc,MAAA,KAAA,OAAA,OAAA,GAAE,YAAY,aAErD,QAAQ,YAQC,SAAQ,aAAyC,QAA0B,GAAE,CACzF,0FAAI,aAAa,SAAW,EAC1B,KAAM,IAAI,OAAM,+DAElB,MAAI,cAAa,SAAW,GAAK,QAAQ,qBAAuB,OAEvD,GAAI,2BAA0B,aAAc,CACjD,KAAM,UACN,eAAgB,aAAa,GAAG,iBAI7B,GAAI,2BAA0B,aAAc,CACjD,KAAM,UACN,cAAe,CACb,aAAc,aAAa,IAAI,GAAM,EAAE,eAAgB,EAAE,kBACzD,4BAA6B,QAAQ,mBAAqB,CACxD,gBAAiB,QAAQ,mBAAmB,YAC5C,QAAS,IACP,gBAUI,iBAAgB,aAAqC,QAA0B,GAAE,CAC7F,0FAAI,aAAa,SAAW,EAC1B,KAAM,IAAI,OAAM,uEAGlB,MAAO,IAAI,2BAA0B,aAAa,IAAI,GAAK,EAAE,aAAc,CACzE,KAAM,UACN,cAAe,CACb,aAAc,aAAa,IAAI,GAAM,EAAE,eAAgB,EAAE,YAAY,eAAgB,OAAQ,EAAE,UAC/F,4BAA6B,QAAQ,mBAAqB,CACxD,gBAAiB,QAAQ,mBAAmB,YAC5C,QAAS,IACP,gBAUI,eAAc,WAAoB,QAAgC,GAAE,qGACzE,GAAI,gBAAe,CACxB,KAAM,iBACN,oBAAqB,CACnB,WAAY,OAAA,aAAa,gBAAgB,YACzC,YAAa,QAAQ,YACrB,YAAa,QAAQ,qBA0Bb,UAAS,QAAwB,CAC7C,2FAAI,CAAC,QAAQ,KAAM,QAAQ,KAAM,QAAQ,KAAM,QAAQ,SAAU,QAAQ,OAAO,UAAU,GAAK,IAAM,UAAe,GAClH,KAAM,IAAI,OAAM,kGAGlB,MAAO,IAAI,gBAAe,CACxB,KAAM,WACN,eAAgB,CACd,WAAY,QAAQ,UAAY,WAAa,WAC7C,KAAM,QAAQ,KACd,KAAM,QAAQ,KACd,KAAM,QAAQ,KACd,SAAU,QAAQ,SAClB,MAAO,QAAQ,SAkBd,eAAa,WAClB,MAAO,MAAK,SAAS,CAAC,KAAK,WAAY,GAAA,IAAA,IAAG,KAAK,QAAI,MAAA,KAAA,OAAA,OAAA,GAAE,mBAAa,MAAA,KAAA,OAAA,GAAM,KAMnE,KAAK,MAAkB,SAAgC,qBAAiC,+FAE7F,MAAM,QAAQ,OACd,MAAM,QAAQ,UACd,MAAM,QAAQ,sBAYN,SAAS,QAAqC,CACtD,MAAI,SAAQ,OAAS,EAAY,QAE1B,QAAQ,IAAI,CAAC,OAAQ,IAAO,KAAK,OAAQ,MAAO,EAAI,MA1K/D,QAAA,eAAA,uIAuYA,GAAY,uBAAZ,AAAA,UAAY,uBAAqB,CAI/B,uBAAA,KAAA,OAKA,uBAAA,MAAA,QAKA,uBAAA,aAAA,iBAdU,sBAAA,QAAA,uBAAA,SAAA,sBAAqB,KAoBjC,uCAAwC,eAAc,CACpD,YAA6B,aAAyC,WAAsC,CAC1G,MAAM,YADqB,KAAA,aAAA,aAItB,KAAK,OAAmB,SAAgC,qBAAiC,CAC9F,SAAW,MAAM,MAAK,aACpB,GAAG,iBAAiB,SAAU",
  "names": []
}
