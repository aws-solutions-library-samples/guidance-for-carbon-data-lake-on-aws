{
  "version": 3,
  "sources": ["load-balancer.ts"],
  "sourcesContent": ["import {\n  Connections, IConnectable, ISecurityGroup, IVpc, Peer, Port,\n  SecurityGroup, SelectedSubnets, SubnetSelection, SubnetType,\n} from '../../aws-ec2';\nimport { Duration, Lazy, Resource } from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnLoadBalancer } from './elasticloadbalancing.generated';\n\n/**\n * Construction properties for a LoadBalancer\n */\nexport interface LoadBalancerProps {\n  /**\n   * VPC network of the fleet instances\n   */\n  readonly vpc: IVpc;\n\n  /**\n   * Whether this is an internet-facing Load Balancer\n   *\n   * This controls whether the LB has a public IP address assigned. It does\n   * not open up the Load Balancer's security groups to public internet access.\n   *\n   * @default false\n   */\n  readonly internetFacing?: boolean;\n\n  /**\n   * What listeners to set up for the load balancer.\n   *\n   * Can also be added by .addListener()\n   *\n   * @default -\n   */\n  readonly listeners?: LoadBalancerListener[];\n\n  /**\n   * What targets to load balance to.\n   *\n   * Can also be added by .addTarget()\n   *\n   * @default - None.\n   */\n  readonly targets?: ILoadBalancerTarget[];\n\n  /**\n   * Health check settings for the load balancing targets.\n   *\n   * Not required but recommended.\n   *\n   * @default - None.\n   */\n  readonly healthCheck?: HealthCheck;\n\n  /**\n   * Whether cross zone load balancing is enabled\n   *\n   * This controls whether the load balancer evenly distributes requests\n   * across each availability zone\n   *\n   * @default true\n   */\n  readonly crossZone?: boolean;\n\n  /**\n   * Which subnets to deploy the load balancer\n   *\n   * Can be used to define a specific set of subnets to deploy the load balancer to.\n   * Useful multiple public or private subnets are covering the same availability zone.\n   *\n   * @default - Public subnets if internetFacing, Private subnets otherwise\n   */\n  readonly subnetSelection?: SubnetSelection;\n\n  /**\n   * Enable Loadbalancer access logs\n   * Can be used to avoid manual work as aws console\n   * Required S3 bucket name , enabled flag\n   * Can add interval for pushing log\n   * Can set bucket prefix in order to provide folder name inside bucket\n   * @default - disabled\n   */\n  readonly accessLoggingPolicy?: CfnLoadBalancer.AccessLoggingPolicyProperty;\n\n}\n\n/**\n * Describe the health check to a load balancer\n */\nexport interface HealthCheck {\n  /**\n   * What port number to health check on\n   */\n  readonly port: number;\n\n  /**\n   * What protocol to use for health checking\n   *\n   * The protocol is automatically determined from the port if it's not supplied.\n   *\n   * @default Automatic\n   */\n  readonly protocol?: LoadBalancingProtocol;\n\n  /**\n   * What path to use for HTTP or HTTPS health check (must return 200)\n   *\n   * For SSL and TCP health checks, accepting connections is enough to be considered\n   * healthy.\n   *\n   * @default \"/\"\n   */\n  readonly path?: string;\n\n  /**\n   * After how many successful checks is an instance considered healthy\n   *\n   * @default 2\n   */\n  readonly healthyThreshold?: number;\n\n  /**\n   * After how many unsuccessful checks is an instance considered unhealthy\n   *\n   * @default 5\n   */\n  readonly unhealthyThreshold?: number;\n\n  /**\n   * Number of seconds between health checks\n   *\n   * @default Duration.seconds(30)\n   */\n  readonly interval?: Duration;\n\n  /**\n   * Health check timeout\n   *\n   * @default Duration.seconds(5)\n   */\n  readonly timeout?: Duration;\n}\n\n/**\n * Interface that is going to be implemented by constructs that you can load balance to\n */\nexport interface ILoadBalancerTarget extends IConnectable {\n  /**\n   * Attach load-balanced target to a classic ELB\n   * @param loadBalancer [disable-awslint:ref-via-interface] The load balancer to attach the target to\n   */\n  attachToClassicLB(loadBalancer: LoadBalancer): void;\n}\n\n/**\n * Add a backend to the load balancer\n */\nexport interface LoadBalancerListener {\n  /**\n   * External listening port\n   */\n  readonly externalPort: number;\n\n  /**\n   * What public protocol to use for load balancing\n   *\n   * Either 'tcp', 'ssl', 'http' or 'https'.\n   *\n   * May be omitted if the external port is either 80 or 443.\n   */\n  readonly externalProtocol?: LoadBalancingProtocol;\n\n  /**\n   * Instance listening port\n   *\n   * Same as the externalPort if not specified.\n   *\n   * @default externalPort\n   */\n  readonly internalPort?: number;\n\n  /**\n   * What public protocol to use for load balancing\n   *\n   * Either 'tcp', 'ssl', 'http' or 'https'.\n   *\n   * May be omitted if the internal port is either 80 or 443.\n   *\n   * The instance protocol is 'tcp' if the front-end protocol\n   * is 'tcp' or 'ssl', the instance protocol is 'http' if the\n   * front-end protocol is 'https'.\n   */\n  readonly internalProtocol?: LoadBalancingProtocol;\n\n  /**\n   * SSL policy names\n   */\n  readonly policyNames?: string[];\n\n  /**\n   * the ARN of the SSL certificate\n   * @deprecated - use sslCertificateArn instead\n   */\n  readonly sslCertificateId?: string;\n\n  /**\n   * the ARN of the SSL certificate\n   *\n   * @default - none\n   */\n  readonly sslCertificateArn?: string;\n\n  /**\n   * Allow connections to the load balancer from the given set of connection peers\n   *\n   * By default, connections will be allowed from anywhere. Set this to an empty list\n   * to deny connections, or supply a custom list of peers to allow connections from\n   * (IP ranges or security groups).\n   *\n   * @default Anywhere\n   */\n  readonly allowConnectionsFrom?: IConnectable[];\n}\n\nexport enum LoadBalancingProtocol {\n  TCP = 'tcp',\n  SSL = 'ssl',\n  HTTP = 'http',\n  HTTPS = 'https'\n}\n\n/**\n * A load balancer with a single listener\n *\n * Routes to a fleet of of instances in a VPC.\n */\nexport class LoadBalancer extends Resource implements IConnectable {\n  /**\n   * Control all connections from and to this load balancer\n   */\n  public readonly connections: Connections;\n\n  /**\n   * An object controlling specifically the connections for each listener added to this load balancer\n   */\n  public readonly listenerPorts: ListenerPort[] = [];\n\n  private readonly elb: CfnLoadBalancer;\n  private readonly securityGroup: SecurityGroup;\n  private readonly listeners: CfnLoadBalancer.ListenersProperty[] = [];\n\n  private readonly instancePorts: number[] = [];\n  private readonly targets: ILoadBalancerTarget[] = [];\n\n  constructor(scope: Construct, id: string, props: LoadBalancerProps) {\n    super(scope, id);\n\n    this.securityGroup = new SecurityGroup(this, 'SecurityGroup', { vpc: props.vpc, allowAllOutbound: false });\n    this.connections = new Connections({ securityGroups: [this.securityGroup] });\n\n    // Depending on whether the ELB has public or internal IPs, pick the right backend subnets\n    const selectedSubnets: SelectedSubnets = loadBalancerSubnets(props);\n\n    this.elb = new CfnLoadBalancer(this, 'Resource', {\n      securityGroups: [this.securityGroup.securityGroupId],\n      subnets: selectedSubnets.subnetIds,\n      listeners: Lazy.any({ produce: () => this.listeners }),\n      scheme: props.internetFacing ? 'internet-facing' : 'internal',\n      healthCheck: props.healthCheck && healthCheckToJSON(props.healthCheck),\n      crossZone: props.crossZone ?? true,\n    });\n    if (props.internetFacing) {\n      this.elb.node.addDependency(selectedSubnets.internetConnectivityEstablished);\n    }\n\n    if (props.accessLoggingPolicy !== undefined) {\n      this.elb.accessLoggingPolicy = props.accessLoggingPolicy;\n    }\n\n    ifUndefined(props.listeners, []).forEach(b => this.addListener(b));\n    ifUndefined(props.targets, []).forEach(t => this.addTarget(t));\n  }\n\n  /**\n   * Add a backend to the load balancer\n   *\n   * @returns A ListenerPort object that controls connections to the listener port\n   */\n  public addListener(listener: LoadBalancerListener): ListenerPort {\n    if (listener.sslCertificateArn && listener.sslCertificateId) {\n      throw new Error('\"sslCertificateId\" is deprecated, please use \"sslCertificateArn\" only.');\n    }\n    const protocol = ifUndefinedLazy(listener.externalProtocol, () => wellKnownProtocol(listener.externalPort));\n    const instancePort = listener.internalPort || listener.externalPort;\n    const sslCertificateArn = listener.sslCertificateArn || listener.sslCertificateId;\n    const instanceProtocol = ifUndefined(listener.internalProtocol,\n      ifUndefined(tryWellKnownProtocol(instancePort),\n        isHttpProtocol(protocol) ? LoadBalancingProtocol.HTTP : LoadBalancingProtocol.TCP));\n\n    this.listeners.push({\n      loadBalancerPort: listener.externalPort.toString(),\n      protocol,\n      instancePort: instancePort.toString(),\n      instanceProtocol,\n      sslCertificateId: sslCertificateArn,\n      policyNames: listener.policyNames,\n    });\n\n    const port = new ListenerPort(this.securityGroup, Port.tcp(listener.externalPort));\n\n    // Allow connections on the public port for all supplied peers (default: everyone)\n    ifUndefined(listener.allowConnectionsFrom, [Peer.anyIpv4()]).forEach(peer => {\n      port.connections.allowDefaultPortFrom(peer, `Default rule allow on ${listener.externalPort}`);\n    });\n\n    this.newInstancePort(instancePort);\n\n    // Keep track using array so user can get to them even if they were all supplied in the constructor\n    this.listenerPorts.push(port);\n\n    return port;\n  }\n\n  public addTarget(target: ILoadBalancerTarget) {\n    target.attachToClassicLB(this);\n\n    this.newTarget(target);\n  }\n\n  /**\n   * @attribute\n   */\n  public get loadBalancerName() {\n    return this.elb.ref;\n  }\n\n  /**\n   * @attribute\n   */\n  public get loadBalancerCanonicalHostedZoneNameId() {\n    return this.elb.attrCanonicalHostedZoneNameId;\n  }\n\n  /**\n   * @attribute\n   */\n  public get loadBalancerCanonicalHostedZoneName() {\n    return this.elb.attrCanonicalHostedZoneName;\n  }\n\n  /**\n   * @attribute\n   */\n  public get loadBalancerDnsName() {\n    return this.elb.attrDnsName;\n  }\n\n  /**\n   * @attribute\n   */\n  public get loadBalancerSourceSecurityGroupGroupName() {\n    return this.elb.attrSourceSecurityGroupGroupName;\n  }\n\n  /**\n   * @attribute\n   */\n  public get loadBalancerSourceSecurityGroupOwnerAlias() {\n    return this.elb.attrSourceSecurityGroupOwnerAlias;\n  }\n\n  /**\n   * Allow connections to all existing targets on new instance port\n   */\n  private newInstancePort(instancePort: number) {\n    this.targets.forEach(t => this.allowTargetConnection(instancePort, t));\n\n    // Keep track of port for future targets\n    this.instancePorts.push(instancePort);\n  }\n\n  /**\n   * Allow connections to target on all existing instance ports\n   */\n  private newTarget(target: ILoadBalancerTarget) {\n    this.instancePorts.forEach(p => this.allowTargetConnection(p, target));\n\n    // Keep track of target for future listeners.\n    this.targets.push(target);\n  }\n\n  /**\n   * Allow connections for a single (port, target) pair\n   */\n  private allowTargetConnection(instancePort: number, target: ILoadBalancerTarget) {\n    this.connections.allowTo(\n      target,\n      Port.tcp(instancePort),\n      `Port ${instancePort} LB to fleet`);\n  }\n}\n\n/**\n * Reference to a listener's port just created.\n *\n * This implements IConnectable with a default port (the port that an ELB\n * listener was just created on) for a given security group so that it can be\n * conveniently used just like any Connectable. E.g:\n *\n *    const listener = elb.addListener(...);\n *\n *    listener.connections.allowDefaultPortFromAnyIPv4();\n *    // or\n *    instance.connections.allowToDefaultPort(listener);\n */\nexport class ListenerPort implements IConnectable {\n  public readonly connections: Connections;\n\n  constructor(securityGroup: ISecurityGroup, defaultPort: Port) {\n    this.connections = new Connections({ securityGroups: [securityGroup], defaultPort });\n  }\n}\n\nfunction wellKnownProtocol(port: number): LoadBalancingProtocol {\n  const proto = tryWellKnownProtocol(port);\n  if (!proto) {\n    throw new Error(`Please supply protocol to go with port ${port}`);\n  }\n  return proto;\n}\n\nfunction tryWellKnownProtocol(port: number): LoadBalancingProtocol | undefined {\n  if (port === 80) { return LoadBalancingProtocol.HTTP; }\n  if (port === 443) { return LoadBalancingProtocol.HTTPS; }\n  return undefined;\n}\n\nfunction isHttpProtocol(proto: LoadBalancingProtocol): boolean {\n  return proto === LoadBalancingProtocol.HTTPS || proto === LoadBalancingProtocol.HTTP;\n}\n\nfunction ifUndefined<T>(x: T | undefined, def: T): T {\n  return x != null ? x : def;\n}\n\nfunction ifUndefinedLazy<T>(x: T | undefined, def: () => T): T {\n  return x != null ? x : def();\n}\n\n/**\n * Turn health check parameters into a parameter blob for the LB\n */\nfunction healthCheckToJSON(healthCheck: HealthCheck): CfnLoadBalancer.HealthCheckProperty {\n  const protocol = ifUndefined(healthCheck.protocol,\n    ifUndefined(tryWellKnownProtocol(healthCheck.port),\n      LoadBalancingProtocol.TCP));\n\n  const path = protocol === LoadBalancingProtocol.HTTP || protocol === LoadBalancingProtocol.HTTPS ? ifUndefined(healthCheck.path, '/') : '';\n\n  const target = `${protocol.toUpperCase()}:${healthCheck.port}${path}`;\n\n  return {\n    healthyThreshold: ifUndefined(healthCheck.healthyThreshold, 2).toString(),\n    interval: (healthCheck.interval || Duration.seconds(30)).toSeconds().toString(),\n    target,\n    timeout: (healthCheck.timeout || Duration.seconds(5)).toSeconds().toString(),\n    unhealthyThreshold: ifUndefined(healthCheck.unhealthyThreshold, 5).toString(),\n  };\n}\n\nfunction loadBalancerSubnets(props: LoadBalancerProps): SelectedSubnets {\n  if (props.subnetSelection !== undefined) {\n    return props.vpc.selectSubnets(props.subnetSelection);\n  } else if (props.internetFacing) {\n    return props.vpc.selectSubnets({\n      subnetType: SubnetType.PUBLIC,\n    });\n  } else {\n    return props.vpc.selectSubnets({\n      subnetType: SubnetType.PRIVATE,\n    });\n  }\n}"],
  "mappings": "yQAAA,UAAA,QAAA,iBAIA,OAAA,QAAA,cAEA,iCAAA,QAAA,oCA0NA,GAAY,uBAAZ,AAAA,UAAY,uBAAqB,CAC/B,uBAAA,IAAA,MACA,uBAAA,IAAA,MACA,uBAAA,KAAA,OACA,uBAAA,MAAA,UAJU,sBAAA,QAAA,uBAAA,SAAA,sBAAqB,KAYjC,0BAAkC,QAAA,QAAQ,CAkBxC,YAAY,MAAkB,GAAY,MAAwB,QAChE,MAAM,MAAO,IAVC,KAAA,cAAgC,GAI/B,KAAA,UAAiD,GAEjD,KAAA,cAA0B,GAC1B,KAAA,QAAiC,yFAKhD,KAAK,cAAgB,GAAI,WAAA,cAAc,KAAM,gBAAiB,CAAE,IAAK,MAAM,IAAK,iBAAkB,KAClG,KAAK,YAAc,GAAI,WAAA,YAAY,CAAE,eAAgB,CAAC,KAAK,iBAG3D,KAAM,iBAAmC,oBAAoB,OAE7D,KAAK,IAAM,GAAI,kCAAA,gBAAgB,KAAM,WAAY,CAC/C,eAAgB,CAAC,KAAK,cAAc,iBACpC,QAAS,gBAAgB,UACzB,UAAW,OAAA,KAAK,IAAI,CAAE,QAAS,IAAM,KAAK,YAC1C,OAAQ,MAAM,eAAiB,kBAAoB,WACnD,YAAa,MAAM,aAAe,kBAAkB,MAAM,aAC1D,UAAS,IAAE,MAAM,aAAS,MAAA,KAAA,OAAA,GAAI,KAE5B,MAAM,gBACR,KAAK,IAAI,KAAK,cAAc,gBAAgB,iCAG1C,MAAM,sBAAwB,QAChC,MAAK,IAAI,oBAAsB,MAAM,qBAGvC,YAAY,MAAM,UAAW,IAAI,QAAQ,GAAK,KAAK,YAAY,IAC/D,YAAY,MAAM,QAAS,IAAI,QAAQ,GAAK,KAAK,UAAU,IAQtD,YAAY,SAA8B,CAC/C,+FAAI,SAAS,mBAAqB,SAAS,iBACzC,KAAM,IAAI,OAAM,0EAElB,KAAM,UAAW,gBAAgB,SAAS,iBAAkB,IAAM,kBAAkB,SAAS,eACvF,aAAe,SAAS,cAAgB,SAAS,aACjD,kBAAoB,SAAS,mBAAqB,SAAS,iBAC3D,iBAAmB,YAAY,SAAS,iBAC5C,YAAY,qBAAqB,cAC/B,eAAe,UAAY,sBAAsB,KAAO,sBAAsB,MAElF,KAAK,UAAU,KAAK,CAClB,iBAAkB,SAAS,aAAa,WACxC,SACA,aAAc,aAAa,WAC3B,iBACA,iBAAkB,kBAClB,YAAa,SAAS,cAGxB,KAAM,MAAO,GAAI,cAAa,KAAK,cAAe,UAAA,KAAK,IAAI,SAAS,eAGpE,mBAAY,SAAS,qBAAsB,CAAC,UAAA,KAAK,YAAY,QAAQ,MAAO,CAC1E,KAAK,YAAY,qBAAqB,KAAM,yBAAyB,SAAS,kBAGhF,KAAK,gBAAgB,cAGrB,KAAK,cAAc,KAAK,MAEjB,KAGF,UAAU,OAA2B,0FAC1C,OAAO,kBAAkB,MAEzB,KAAK,UAAU,WAMN,mBAAgB,CACzB,MAAO,MAAK,IAAI,OAMP,wCAAqC,CAC9C,MAAO,MAAK,IAAI,iCAMP,sCAAmC,CAC5C,MAAO,MAAK,IAAI,+BAMP,sBAAmB,CAC5B,MAAO,MAAK,IAAI,eAMP,2CAAwC,CACjD,MAAO,MAAK,IAAI,oCAMP,4CAAyC,CAClD,MAAO,MAAK,IAAI,kCAMV,gBAAgB,aAAoB,CAC1C,KAAK,QAAQ,QAAQ,GAAK,KAAK,sBAAsB,aAAc,IAGnE,KAAK,cAAc,KAAK,cAMlB,UAAU,OAA2B,CAC3C,KAAK,cAAc,QAAQ,GAAK,KAAK,sBAAsB,EAAG,SAG9D,KAAK,QAAQ,KAAK,QAMZ,sBAAsB,aAAsB,OAA2B,CAC7E,KAAK,YAAY,QACf,OACA,UAAA,KAAK,IAAI,cACT,QAAQ,6BAlKd,QAAA,aAAA,+HAmLA,kBAAyB,CAGvB,YAAY,cAA+B,YAAiB,yIAC1D,KAAK,YAAc,GAAI,WAAA,YAAY,CAAE,eAAgB,CAAC,eAAgB,eAJ1E,QAAA,aAAA,+HAQA,2BAA2B,KAAY,CACrC,KAAM,OAAQ,qBAAqB,MACnC,GAAI,CAAC,MACH,KAAM,IAAI,OAAM,0CAA0C,QAE5D,MAAO,OAGT,8BAA8B,KAAY,CACxC,GAAI,OAAS,GAAM,MAAO,uBAAsB,KAChD,GAAI,OAAS,IAAO,MAAO,uBAAsB,MAInD,wBAAwB,MAA4B,CAClD,MAAO,SAAU,sBAAsB,OAAS,QAAU,sBAAsB,KAGlF,qBAAwB,EAAkB,IAAM,CAC9C,MAAO,IAAK,KAAO,EAAI,IAGzB,yBAA4B,EAAkB,IAAY,CACxD,MAAO,IAAK,KAAO,EAAI,MAMzB,2BAA2B,YAAwB,CACjD,KAAM,UAAW,YAAY,YAAY,SACvC,YAAY,qBAAqB,YAAY,MAC3C,sBAAsB,MAEpB,KAAO,WAAa,sBAAsB,MAAQ,WAAa,sBAAsB,MAAQ,YAAY,YAAY,KAAM,KAAO,GAElI,OAAS,GAAG,SAAS,iBAAiB,YAAY,OAAO,OAE/D,MAAO,CACL,iBAAkB,YAAY,YAAY,iBAAkB,GAAG,WAC/D,SAAW,aAAY,UAAY,OAAA,SAAS,QAAQ,KAAK,YAAY,WACrE,OACA,QAAU,aAAY,SAAW,OAAA,SAAS,QAAQ,IAAI,YAAY,WAClE,mBAAoB,YAAY,YAAY,mBAAoB,GAAG,YAIvE,6BAA6B,MAAwB,CACnD,MAAI,OAAM,kBAAoB,OACrB,MAAM,IAAI,cAAc,MAAM,iBAC5B,MAAM,eACR,MAAM,IAAI,cAAc,CAC7B,WAAY,UAAA,WAAW,SAGlB,MAAM,IAAI,cAAc,CAC7B,WAAY,UAAA,WAAW",
  "names": []
}
