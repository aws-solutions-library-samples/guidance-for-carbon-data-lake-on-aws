{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import * as events from '../../aws-events';\nimport * as iam from '../../aws-iam';\nimport * as lambda from '../../aws-lambda';\nimport * as sqs from '../../aws-sqs';\nimport { Annotations, Names, Token, TokenComparison, Duration, PhysicalName } from '../../core';\nimport { Construct, IConstruct, Node } from 'constructs';\n\n/**\n * The generic properties for an RuleTarget\n */\nexport interface TargetBaseProps {\n  /**\n   * The SQS queue to be used as deadLetterQueue.\n   * Check out the [considerations for using a dead-letter queue](https://docs.aws.amazon.com/eventbridge/latest/userguide/rule-dlq.html#dlq-considerations).\n   *\n   * The events not successfully delivered are automatically retried for a specified period of time,\n   * depending on the retry policy of the target.\n   * If an event is not delivered before all retry attempts are exhausted, it will be sent to the dead letter queue.\n   *\n   * @default - no dead-letter queue\n   */\n  readonly deadLetterQueue?: sqs.IQueue;\n  /**\n   * The maximum age of a request that Lambda sends to a function for\n   * processing.\n   *\n   * Minimum value of 60.\n   * Maximum value of 86400.\n   *\n   * @default Duration.hours(24)\n   */\n  readonly maxEventAge?: Duration;\n\n  /**\n   * The maximum number of times to retry when the function returns an error.\n   *\n   * Minimum value of 0.\n   * Maximum value of 185.\n   *\n   * @default 185\n   */\n  readonly retryAttempts?: number;\n}\n\n/**\n * Bind props to base rule target config.\n * @internal\n */\nexport function bindBaseTargetConfig(props: TargetBaseProps) {\n  let { deadLetterQueue, retryAttempts, maxEventAge } = props;\n\n  return {\n    deadLetterConfig: deadLetterQueue ? { arn: deadLetterQueue?.queueArn } : undefined,\n    retryPolicy: retryAttempts || maxEventAge\n      ? {\n        maximumRetryAttempts: retryAttempts,\n        maximumEventAgeInSeconds: maxEventAge?.toSeconds({ integral: true }),\n      }\n      : undefined,\n  };\n}\n\n\n/**\n * Obtain the Role for the EventBridge event\n *\n * If a role already exists, it will be returned. This ensures that if multiple\n * events have the same target, they will share a role.\n * @internal\n */\nexport function singletonEventRole(scope: IConstruct, policyStatements: iam.PolicyStatement[]): iam.IRole {\n  const id = 'EventsRole';\n  const existing = scope.node.tryFindChild(id) as iam.IRole;\n  if (existing) { return existing; }\n\n  const role = new iam.Role(scope as Construct, id, {\n    roleName: PhysicalName.GENERATE_IF_NEEDED,\n    assumedBy: new iam.ServicePrincipal('events.amazonaws.com'),\n  });\n\n  policyStatements.forEach(role.addToPolicy.bind(role));\n\n  return role;\n}\n\n/**\n * Allows a Lambda function to be called from a rule\n * @internal\n */\nexport function addLambdaPermission(rule: events.IRule, handler: lambda.IFunction): void {\n  let scope: Construct | undefined;\n  let node: Node = handler.permissionsNode;\n  let permissionId = `AllowEventRule${Names.nodeUniqueId(rule.node)}`;\n  if (rule instanceof Construct) {\n    // Place the Permission resource in the same stack as Rule rather than the Function\n    // This is to reduce circular dependency when the lambda handler and the rule are across stacks.\n    scope = rule;\n    node = rule.node;\n    permissionId = `AllowEventRule${Names.nodeUniqueId(handler.node)}`;\n  }\n  if (!node.tryFindChild(permissionId)) {\n    handler.addPermission(permissionId, {\n      scope,\n      action: 'lambda:InvokeFunction',\n      principal: new iam.ServicePrincipal('events.amazonaws.com'),\n      sourceArn: rule.ruleArn,\n    });\n  }\n}\n\n/**\n * Allow a rule to send events with failed invocation to an Amazon SQS queue.\n * @internal\n */\nexport function addToDeadLetterQueueResourcePolicy(rule: events.IRule, queue: sqs.IQueue) {\n  if (!sameEnvDimension(rule.env.region, queue.env.region)) {\n    throw new Error(`Cannot assign Dead Letter Queue in region ${queue.env.region} to the rule ${Names.nodeUniqueId(rule.node)} in region ${rule.env.region}. Both the queue and the rule must be in the same region.`);\n  }\n\n  // Skip Resource Policy creation if the Queue is not in the same account.\n  // There is no way to add a target onto an imported rule, so we can assume we will run the following code only\n  // in the account where the rule is created.\n  if (sameEnvDimension(rule.env.account, queue.env.account)) {\n    const policyStatementId = `AllowEventRule${Names.nodeUniqueId(rule.node)}`;\n\n    queue.addToResourcePolicy(new iam.PolicyStatement({\n      sid: policyStatementId,\n      principals: [new iam.ServicePrincipal('events.amazonaws.com')],\n      effect: iam.Effect.ALLOW,\n      actions: ['sqs:SendMessage'],\n      resources: [queue.queueArn],\n      conditions: {\n        ArnEquals: {\n          'aws:SourceArn': rule.ruleArn,\n        },\n      },\n    }));\n  } else {\n    Annotations.of(rule).addWarning(`Cannot add a resource policy to your dead letter queue associated with rule ${rule.ruleName} because the queue is in a different account. You must add the resource policy manually to the dead letter queue in account ${queue.env.account}.`);\n  }\n}\n\n\n/**\n * Whether two string probably contain the same environment dimension (region or account)\n *\n * Used to compare either accounts or regions, and also returns true if both\n * are unresolved (in which case both are expted to be \"current region\" or \"current account\").\n * @internal\n */\nfunction sameEnvDimension(dim1: string, dim2: string) {\n  return [TokenComparison.SAME, TokenComparison.BOTH_UNRESOLVED].includes(Token.compareStrings(dim1, dim2));\n}\n"],
  "mappings": "0MACA,KAAA,KAAA,QAAA,iBAGA,OAAA,QAAA,cACA,aAAA,QAAA,cA2CA,8BAAqC,MAAsB,CACzD,GAAI,CAAE,gBAAiB,cAAe,aAAgB,MAEtD,MAAO,CACL,iBAAkB,gBAAkB,CAAE,IAAK,iBAAe,KAAA,OAAf,gBAAiB,UAAa,OACzE,YAAa,eAAiB,YAC1B,CACA,qBAAsB,cACtB,yBAA0B,aAAW,KAAA,OAAX,YAAa,UAAU,CAAE,SAAU,MAE7D,QAVR,QAAA,qBAAA,qBAsBA,4BAAmC,MAAmB,iBAAuC,CAC3F,KAAM,IAAK,aACL,SAAW,MAAM,KAAK,aAAa,IACzC,GAAI,SAAY,MAAO,UAEvB,KAAM,MAAO,GAAI,KAAI,KAAK,MAAoB,GAAI,CAChD,SAAU,OAAA,aAAa,mBACvB,UAAW,GAAI,KAAI,iBAAiB,0BAGtC,wBAAiB,QAAQ,KAAK,YAAY,KAAK,OAExC,KAZT,QAAA,mBAAA,mBAmBA,6BAAoC,KAAoB,QAAyB,CAC/E,GAAI,OACA,KAAa,QAAQ,gBACrB,aAAe,iBAAiB,OAAA,MAAM,aAAa,KAAK,QAC5D,AAAI,eAAgB,cAAA,WAGlB,OAAQ,KACR,KAAO,KAAK,KACZ,aAAe,iBAAiB,OAAA,MAAM,aAAa,QAAQ,SAExD,KAAK,aAAa,eACrB,QAAQ,cAAc,aAAc,CAClC,MACA,OAAQ,wBACR,UAAW,GAAI,KAAI,iBAAiB,wBACpC,UAAW,KAAK,UAhBtB,QAAA,oBAAA,oBAyBA,4CAAmD,KAAoB,MAAiB,CACtF,GAAI,CAAC,iBAAiB,KAAK,IAAI,OAAQ,MAAM,IAAI,QAC/C,KAAM,IAAI,OAAM,6CAA6C,MAAM,IAAI,sBAAsB,OAAA,MAAM,aAAa,KAAK,mBAAmB,KAAK,IAAI,mEAMnJ,GAAI,iBAAiB,KAAK,IAAI,QAAS,MAAM,IAAI,SAAU,CACzD,KAAM,mBAAoB,iBAAiB,OAAA,MAAM,aAAa,KAAK,QAEnE,MAAM,oBAAoB,GAAI,KAAI,gBAAgB,CAChD,IAAK,kBACL,WAAY,CAAC,GAAI,KAAI,iBAAiB,yBACtC,OAAQ,IAAI,OAAO,MACnB,QAAS,CAAC,mBACV,UAAW,CAAC,MAAM,UAClB,WAAY,CACV,UAAW,CACT,gBAAiB,KAAK,iBAK5B,QAAA,YAAY,GAAG,MAAM,WAAW,+EAA+E,KAAK,uIAAuI,MAAM,IAAI,YAxBzQ,QAAA,mCAAA,mCAoCA,0BAA0B,KAAc,KAAY,CAClD,MAAO,CAAC,OAAA,gBAAgB,KAAM,OAAA,gBAAgB,iBAAiB,SAAS,OAAA,MAAM,eAAe,KAAM",
  "names": []
}
