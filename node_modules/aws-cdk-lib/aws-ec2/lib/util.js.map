{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { Construct } from 'constructs';\nimport { ISubnet, Subnet, SubnetType } from './vpc';\n\n/**\n * Turn an arbitrary string into one that can be used as a CloudFormation identifier by stripping special characters\n *\n * (At the moment, no efforts are taken to prevent collisions, but we can add that later when it becomes necessary).\n */\nexport function slugify(x: string): string {\n  return x.replace(/[^a-zA-Z0-9]/g, '');\n}\n\n/**\n * The default names for every subnet type\n */\nexport function defaultSubnetName(type: SubnetType) {\n  switch (type) {\n    case SubnetType.PUBLIC: return 'Public';\n    case SubnetType.PRIVATE_WITH_NAT: return 'Private';\n    case SubnetType.PRIVATE_ISOLATED: return 'Isolated';\n  }\n}\n\n/**\n * Return a subnet name from its construct ID\n *\n * All subnet names look like NAME <> \"Subnet\" <> INDEX\n */\nexport function subnetGroupNameFromConstructId(subnet: ISubnet) {\n  return subnet.node.id.replace(/Subnet\\d+$/, '');\n}\n\n/**\n * Make the subnet construct ID from a name and number\n */\nexport function subnetId(name: string, i: number) {\n  return `${name}Subnet${i + 1}`;\n}\n\nexport class ImportSubnetGroup {\n  private readonly subnetIds: string[];\n  private readonly names: string[];\n  private readonly routeTableIds: string[];\n  private readonly groups: number;\n\n  constructor(\n    subnetIds: string[] | undefined,\n    names: string[] | undefined,\n    routeTableIds: string[] | undefined,\n    type: SubnetType,\n    private readonly availabilityZones: string[],\n    idField: string,\n    nameField: string,\n    routeTableIdField: string) {\n\n    this.subnetIds = subnetIds || [];\n    this.routeTableIds = routeTableIds || [];\n    this.groups = this.subnetIds.length / this.availabilityZones.length;\n\n    if (Math.floor(this.groups) !== this.groups) {\n      // eslint-disable-next-line max-len\n      throw new Error(`Number of ${idField} (${this.subnetIds.length}) must be a multiple of availability zones (${this.availabilityZones.length}).`);\n    }\n    if (this.routeTableIds.length !== this.subnetIds.length && routeTableIds != null) {\n      // We don't err if no routeTableIds were provided to maintain backwards-compatibility. See https://github.com/aws/aws-cdk/pull/3171\n      /* eslint-disable max-len */\n      throw new Error(`Number of ${routeTableIdField} (${this.routeTableIds.length}) must be equal to the amount of ${idField} (${this.subnetIds.length}).`);\n    }\n\n    this.names = this.normalizeNames(names, defaultSubnetName(type), nameField);\n  }\n\n  public import(scope: Construct): ISubnet[] {\n    return range(this.subnetIds.length).map(i => {\n      const k = Math.floor(i / this.availabilityZones.length);\n      return Subnet.fromSubnetAttributes(scope, subnetId(this.names[k], i), {\n        availabilityZone: this.pickAZ(i),\n        subnetId: this.subnetIds[i],\n        routeTableId: this.routeTableIds[i],\n      });\n    });\n  }\n\n  /**\n   * Return a list with a name for every subnet\n   */\n  private normalizeNames(names: string[] | undefined, defaultName: string, fieldName: string) {\n    // If not given, return default\n    if (names === undefined || names.length === 0) {\n      return [defaultName];\n    }\n\n    // If given, must match given subnets\n    if (names.length !== this.groups) {\n      throw new Error(`${fieldName} must have an entry for every corresponding subnet group, got: ${JSON.stringify(names)}`);\n    }\n\n    return names;\n  }\n\n  /**\n   * Return the i'th AZ\n   */\n  private pickAZ(i: number) {\n    return this.availabilityZones[i % this.availabilityZones.length];\n  }\n}\n\n/**\n * Generate the list of numbers of [0..n)\n */\nexport function range(n: number): number[] {\n  const ret: number[] = [];\n  for (let i = 0; i < n; i++) {\n    ret.push(i);\n  }\n  return ret;\n}\n\n/**\n * Return the union of table IDs from all selected subnets\n */\nexport function allRouteTableIds(subnets: ISubnet[]): string[] {\n  const ret = new Set<string>();\n  for (const subnet of subnets) {\n    if (subnet.routeTable && subnet.routeTable.routeTableId) {\n      ret.add(subnet.routeTable.routeTableId);\n    }\n  }\n  return Array.from(ret);\n}\n\nexport function flatten<A>(xs: A[][]): A[] {\n  return Array.prototype.concat.apply([], xs);\n}\n"],
  "mappings": "8PACA,KAAA,OAAA,QAAA,SAOA,iBAAwB,EAAS,CAC/B,MAAO,GAAE,QAAQ,gBAAiB,IADpC,QAAA,QAAA,QAOA,2BAAkC,KAAgB,CAChD,OAAQ,UACD,OAAA,WAAW,OAAQ,MAAO,aAC1B,OAAA,WAAW,iBAAkB,MAAO,cACpC,OAAA,WAAW,iBAAkB,MAAO,YAJ7C,QAAA,kBAAA,kBAaA,wCAA+C,OAAe,CAC5D,MAAO,QAAO,KAAK,GAAG,QAAQ,aAAc,IAD9C,QAAA,+BAAA,+BAOA,kBAAyB,KAAc,EAAS,CAC9C,MAAO,GAAG,aAAa,EAAI,IAD7B,QAAA,SAAA,SAIA,uBAA8B,CAM5B,YACE,UACA,MACA,cACA,KACiB,kBACjB,QACA,UACA,kBAAyB,CAMzB,GATiB,KAAA,kBAAA,kBAKjB,KAAK,UAAY,WAAa,GAC9B,KAAK,cAAgB,eAAiB,GACtC,KAAK,OAAS,KAAK,UAAU,OAAS,KAAK,kBAAkB,OAEzD,KAAK,MAAM,KAAK,UAAY,KAAK,OAEnC,KAAM,IAAI,OAAM,aAAa,YAAY,KAAK,UAAU,qDAAqD,KAAK,kBAAkB,YAEtI,GAAI,KAAK,cAAc,SAAW,KAAK,UAAU,QAAU,eAAiB,KAG1E,KAAM,IAAI,OAAM,aAAa,sBAAsB,KAAK,cAAc,0CAA0C,YAAY,KAAK,UAAU,YAG7I,KAAK,MAAQ,KAAK,eAAe,MAAO,kBAAkB,MAAO,WAG5D,OAAO,MAAgB,CAC5B,MAAO,OAAM,KAAK,UAAU,QAAQ,IAAI,GAAI,CAC1C,KAAM,GAAI,KAAK,MAAM,EAAI,KAAK,kBAAkB,QAChD,MAAO,OAAA,OAAO,qBAAqB,MAAO,SAAS,KAAK,MAAM,GAAI,GAAI,CACpE,iBAAkB,KAAK,OAAO,GAC9B,SAAU,KAAK,UAAU,GACzB,aAAc,KAAK,cAAc,OAQ/B,eAAe,MAA6B,YAAqB,UAAiB,CAExF,GAAI,QAAU,QAAa,MAAM,SAAW,EAC1C,MAAO,CAAC,aAIV,GAAI,MAAM,SAAW,KAAK,OACxB,KAAM,IAAI,OAAM,GAAG,2EAA2E,KAAK,UAAU,UAG/G,MAAO,OAMD,OAAO,EAAS,CACtB,MAAO,MAAK,kBAAkB,EAAI,KAAK,kBAAkB,SAjE7D,QAAA,kBAAA,kBAwEA,eAAsB,EAAS,CAC7B,KAAM,KAAgB,GACtB,OAAS,GAAI,EAAG,EAAI,EAAG,IACrB,IAAI,KAAK,GAEX,MAAO,KALT,QAAA,MAAA,MAWA,0BAAiC,QAAkB,CACjD,KAAM,KAAM,GAAI,KAChB,SAAW,UAAU,SACnB,AAAI,OAAO,YAAc,OAAO,WAAW,cACzC,IAAI,IAAI,OAAO,WAAW,cAG9B,MAAO,OAAM,KAAK,KAPpB,QAAA,iBAAA,iBAUA,iBAA2B,GAAS,CAClC,MAAO,OAAM,UAAU,OAAO,MAAM,GAAI,IAD1C,QAAA,QAAA",
  "names": []
}
