{
  "version": 3,
  "sources": ["peer.ts"],
  "sourcesContent": ["import { Token } from '../../core';\nimport { Connections, IConnectable } from './connections';\n\n/**\n * Interface for classes that provide the peer-specification parts of a security group rule\n */\nexport interface IPeer extends IConnectable {\n  /**\n   * Whether the rule can be inlined into a SecurityGroup or not\n   */\n  readonly canInlineRule: boolean;\n\n  /**\n   * A unique identifier for this connection peer\n   */\n  readonly uniqueId: string;\n\n  /**\n   * Produce the ingress rule JSON for the given connection\n   */\n  toIngressRuleConfig(): any;\n\n  /**\n   * Produce the egress rule JSON for the given connection\n   */\n  toEgressRuleConfig(): any;\n}\n\n/**\n * Peer object factories (to be used in Security Group management)\n *\n * The static methods on this object can be used to create peer objects\n * which represent a connection partner in Security Group rules.\n *\n * Use this object if you need to represent connection partners using plain IP\n * addresses, or a prefix list ID.\n *\n * If you want to address a connection partner by Security Group, you can just\n * use the Security Group (or the construct that contains a Security Group)\n * directly, as it already implements `IPeer`.\n */\nexport class Peer {\n  /**\n   * Create an IPv4 peer from a CIDR\n   */\n  public static ipv4(cidrIp: string): IPeer {\n    return new CidrIPv4(cidrIp);\n  }\n\n  /**\n   * Any IPv4 address\n   */\n  public static anyIpv4(): IPeer {\n    return new AnyIPv4();\n  }\n\n  /**\n   * Create an IPv6 peer from a CIDR\n   */\n  public static ipv6(cidrIp: string): IPeer {\n    return new CidrIPv6(cidrIp);\n  }\n\n  /**\n   * Any IPv6 address\n   */\n  public static anyIpv6(): IPeer {\n    return new AnyIPv6();\n  }\n\n  /**\n   * A prefix list\n   */\n  public static prefixList(prefixListId: string): IPeer {\n    return new PrefixList(prefixListId);\n  }\n\n  /**\n   * A security group ID\n   */\n  public static securityGroupId(securityGroupId: string, sourceSecurityGroupOwnerId?: string): IPeer {\n    return new SecurityGroupId(securityGroupId, sourceSecurityGroupOwnerId);\n  }\n\n  protected constructor() {\n  }\n}\n\n/**\n * A connection to and from a given IP range\n */\nclass CidrIPv4 implements IPeer {\n  public readonly canInlineRule = true;\n  public readonly connections: Connections = new Connections({ peer: this });\n  public readonly uniqueId: string;\n\n  constructor(private readonly cidrIp: string) {\n    if (!Token.isUnresolved(cidrIp)) {\n      const cidrMatch = cidrIp.match(/^(\\d{1,3}\\.){3}\\d{1,3}(\\/\\d+)?$/);\n\n      if (!cidrMatch) {\n        throw new Error(`Invalid IPv4 CIDR: \"${cidrIp}\"`);\n      }\n\n      if (!cidrMatch[2]) {\n        throw new Error(`CIDR mask is missing in IPv4: \"${cidrIp}\". Did you mean \"${cidrIp}/32\"?`);\n      }\n    }\n\n    this.uniqueId = cidrIp;\n  }\n\n  /**\n   * Produce the ingress rule JSON for the given connection\n   */\n  public toIngressRuleConfig(): any {\n    return { cidrIp: this.cidrIp };\n  }\n  /**\n   * Produce the egress rule JSON for the given connection\n   */\n  public toEgressRuleConfig(): any {\n    return { cidrIp: this.cidrIp };\n  }\n}\n\n/**\n * Any IPv4 address\n */\nclass AnyIPv4 extends CidrIPv4 {\n  constructor() {\n    super('0.0.0.0/0');\n  }\n}\n\n/**\n * A connection to a from a given IPv6 range\n */\nclass CidrIPv6 implements IPeer {\n  public readonly canInlineRule = true;\n  public readonly connections: Connections = new Connections({ peer: this });\n  public readonly uniqueId: string;\n\n  constructor(private readonly cidrIpv6: string) {\n    if (!Token.isUnresolved(cidrIpv6)) {\n      const cidrMatch = cidrIpv6.match(/^([\\da-f]{0,4}:){2,7}([\\da-f]{0,4})?(\\/\\d+)?$/);\n\n      if (!cidrMatch) {\n        throw new Error(`Invalid IPv6 CIDR: \"${cidrIpv6}\"`);\n      }\n\n      if (!cidrMatch[3]) {\n        throw new Error(`CIDR mask is missing in IPv6: \"${cidrIpv6}\". Did you mean \"${cidrIpv6}/128\"?`);\n      }\n    }\n\n    this.uniqueId = cidrIpv6;\n  }\n\n  /**\n   * Produce the ingress rule JSON for the given connection\n   */\n  public toIngressRuleConfig(): any {\n    return { cidrIpv6: this.cidrIpv6 };\n  }\n  /**\n   * Produce the egress rule JSON for the given connection\n   */\n  public toEgressRuleConfig(): any {\n    return { cidrIpv6: this.cidrIpv6 };\n  }\n}\n\n/**\n * Any IPv6 address\n */\nclass AnyIPv6 extends CidrIPv6 {\n  constructor() {\n    super('::/0');\n  }\n}\n\n/**\n * A prefix list\n *\n * Prefix lists are used to allow traffic to VPC-local service endpoints.\n *\n * For more information, see this page:\n *\n * https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-endpoints.html\n */\nclass PrefixList implements IPeer {\n  public readonly canInlineRule = false;\n  public readonly connections: Connections = new Connections({ peer: this });\n  public readonly uniqueId: string;\n\n  constructor(private readonly prefixListId: string) {\n    this.uniqueId = prefixListId;\n  }\n\n  public toIngressRuleConfig(): any {\n    return { sourcePrefixListId: this.prefixListId };\n  }\n\n  public toEgressRuleConfig(): any {\n    return { destinationPrefixListId: this.prefixListId };\n  }\n}\n\n/**\n * A connection to or from a given security group ID\n *\n * For ingress rules, a sourceSecurityGroupOwnerId parameter can be specified if\n * the security group exists in another account.\n * This parameter will be ignored for egress rules.\n */\nclass SecurityGroupId implements IPeer {\n  public readonly canInlineRule = true;\n  public readonly connections: Connections = new Connections({ peer: this });\n  public readonly uniqueId: string;\n\n  constructor(private readonly securityGroupId: string, private readonly sourceSecurityGroupOwnerId?: string) {\n    if (!Token.isUnresolved(securityGroupId)) {\n      const securityGroupMatch = securityGroupId.match(/^sg-[a-z0-9]{8,17}$/);\n\n      if (!securityGroupMatch) {\n        throw new Error(`Invalid security group ID: \"${securityGroupId}\"`);\n      }\n    }\n\n    if (sourceSecurityGroupOwnerId && !Token.isUnresolved(sourceSecurityGroupOwnerId)) {\n      const accountNumberMatch = sourceSecurityGroupOwnerId.match(/^[0-9]{12}$/);\n\n      if (!accountNumberMatch) {\n        throw new Error(`Invalid security group owner ID: \"${sourceSecurityGroupOwnerId}\"`);\n      }\n    }\n    this.uniqueId = securityGroupId;\n  }\n\n  /**\n   * Produce the ingress rule JSON for the given connection\n   */\n  public toIngressRuleConfig(): any {\n    return {\n      sourceSecurityGroupId: this.securityGroupId,\n      ...(this.sourceSecurityGroupOwnerId && { sourceSecurityGroupOwnerId: this.sourceSecurityGroupOwnerId }),\n    };\n  }\n\n  /**\n   * Produce the egress rule JSON for the given connection\n   */\n  public toEgressRuleConfig(): any {\n    return { destinationSecurityGroupId: this.securityGroupId };\n  }\n}"],
  "mappings": "gJAAA,OAAA,QAAA,cACA,cAAA,QAAA,iBAwCA,UAAiB,CA2Cf,aAAA,QAvCc,MAAK,OAAc,CAC/B,MAAO,IAAI,UAAS,cAMR,UAAO,CACnB,MAAO,IAAI,eAMC,MAAK,OAAc,CAC/B,MAAO,IAAI,UAAS,cAMR,UAAO,CACnB,MAAO,IAAI,eAMC,YAAW,aAAoB,CAC3C,MAAO,IAAI,YAAW,oBAMV,iBAAgB,gBAAyB,2BAAmC,CACxF,MAAO,IAAI,iBAAgB,gBAAiB,6BAxChD,QAAA,KAAA,sFAkDA,cAAc,CAKZ,YAA6B,OAAc,CACzC,GAD2B,KAAA,OAAA,OAJb,KAAA,cAAgB,GAChB,KAAA,YAA2B,GAAI,eAAA,YAAY,CAAE,KAAM,OAI7D,CAAC,OAAA,MAAM,aAAa,QAAS,CAC/B,KAAM,WAAY,OAAO,MAAM,mCAE/B,GAAI,CAAC,UACH,KAAM,IAAI,OAAM,uBAAuB,WAGzC,GAAI,CAAC,UAAU,GACb,KAAM,IAAI,OAAM,kCAAkC,0BAA0B,eAIhF,KAAK,SAAW,OAMX,qBAAmB,CACxB,MAAO,CAAE,OAAQ,KAAK,QAKjB,oBAAkB,CACvB,MAAO,CAAE,OAAQ,KAAK,SAO1B,qBAAsB,SAAQ,CAC5B,aAAA,CACE,MAAM,cAOV,cAAc,CAKZ,YAA6B,SAAgB,CAC3C,GAD2B,KAAA,SAAA,SAJb,KAAA,cAAgB,GAChB,KAAA,YAA2B,GAAI,eAAA,YAAY,CAAE,KAAM,OAI7D,CAAC,OAAA,MAAM,aAAa,UAAW,CACjC,KAAM,WAAY,SAAS,MAAM,iDAEjC,GAAI,CAAC,UACH,KAAM,IAAI,OAAM,uBAAuB,aAGzC,GAAI,CAAC,UAAU,GACb,KAAM,IAAI,OAAM,kCAAkC,4BAA4B,kBAIlF,KAAK,SAAW,SAMX,qBAAmB,CACxB,MAAO,CAAE,SAAU,KAAK,UAKnB,oBAAkB,CACvB,MAAO,CAAE,SAAU,KAAK,WAO5B,qBAAsB,SAAQ,CAC5B,aAAA,CACE,MAAM,SAaV,gBAAgB,CAKd,YAA6B,aAAoB,CAApB,KAAA,aAAA,aAJb,KAAA,cAAgB,GAChB,KAAA,YAA2B,GAAI,eAAA,YAAY,CAAE,KAAM,OAIjE,KAAK,SAAW,aAGX,qBAAmB,CACxB,MAAO,CAAE,mBAAoB,KAAK,cAG7B,oBAAkB,CACvB,MAAO,CAAE,wBAAyB,KAAK,eAW3C,qBAAqB,CAKnB,YAA6B,gBAA0C,2BAAmC,CACxG,GAD2B,KAAA,gBAAA,gBAA0C,KAAA,2BAAA,2BAJvD,KAAA,cAAgB,GAChB,KAAA,YAA2B,GAAI,eAAA,YAAY,CAAE,KAAM,OAI7D,CAAC,OAAA,MAAM,aAAa,kBAGlB,CAFuB,gBAAgB,MAAM,uBAG/C,KAAM,IAAI,OAAM,+BAA+B,oBAInD,GAAI,4BAA8B,CAAC,OAAA,MAAM,aAAa,6BAGhD,CAFuB,2BAA2B,MAAM,eAG1D,KAAM,IAAI,OAAM,qCAAqC,+BAGzD,KAAK,SAAW,gBAMX,qBAAmB,CACxB,MAAO,CACL,sBAAuB,KAAK,mBACxB,KAAK,4BAA8B,CAAE,2BAA4B,KAAK,6BAOvE,oBAAkB,CACvB,MAAO,CAAE,2BAA4B,KAAK",
  "names": []
}
