{
  "version": 3,
  "sources": ["network-util.ts"],
  "sourcesContent": ["/**\n * InvalidCidrRangeError is thrown when attempting to perform operations on a CIDR\n * range that is either not valid, or outside of the VPC size limits.\n */\nexport class InvalidCidrRangeError extends Error {\n  constructor(cidr: string) {\n    super(cidr + ' is not a valid VPC CIDR range (must be between /16 and /28)');\n    // The following line is required for type checking of custom errors, and must be called right after super()\n    // https://stackoverflow.com/questions/31626231/custom-error-class-in-typescript\n    Object.setPrototypeOf(this, InvalidCidrRangeError.prototype);\n  }\n}\n\n/**\n * NetworkUtils contains helpers to work with network constructs (subnets/ranges)\n */\nexport class NetworkUtils {\n\n  /**\n   * Validates an IPv4 string\n   *\n   * returns true of the string contains 4 numbers between 0-255 delimited by\n   * a `.` character\n   */\n  public static validIp(ipAddress: string): boolean {\n    const octets = ipAddress.split('.');\n    if (octets.length !== 4) {\n      return false;\n    }\n    return octets.map((octet: string) => parseInt(octet, 10)).\n      filter((octet: number) => octet >= 0 && octet <= 255).length === 4;\n  }\n\n  /**\n   * Converts a string IPv4 to a number\n   *\n   * takes an IP Address (e.g. 174.66.173.168) and converts to a number\n   * (e.g 2923605416); currently only supports IPv4\n   *\n   * Uses the formula:\n   * (first octet * 256\u00B3) + (second octet * 256\u00B2) + (third octet * 256) +\n   * (fourth octet)\n   *\n   * @param  {string} the IP address (e.g. 174.66.173.168)\n   * @returns {number} the integer value of the IP address (e.g 2923605416)\n   */\n  public static ipToNum(ipAddress: string): number {\n    if (!this.validIp(ipAddress)) {\n      throw new Error(`${ipAddress} is not valid`);\n    }\n\n    return ipAddress\n      .split('.')\n      .reduce(\n        (p: number, c: string, i: number) => p + parseInt(c, 10) * 256 ** (3 - i),\n        0,\n      );\n  }\n\n  /**\n   * Takes number and converts it to IPv4 address string\n   *\n   * Takes a number (e.g 2923605416) and converts it to an IPv4 address string\n   * currently only supports IPv4\n   *\n   * @param  {number} the integer value of the IP address (e.g 2923605416)\n   * @returns {string} the IPv4 address (e.g. 174.66.173.168)\n   */\n  public static numToIp(ipNum: number): string {\n    // this all because bitwise math is signed\n    let remaining = ipNum;\n    const address = new Array<number>();\n    for (let i = 0; i < 4; i++) {\n      if (remaining !== 0) {\n        address.push(Math.floor(remaining / 256 ** (3 - i)));\n        remaining = remaining % 256 ** (3 - i);\n      } else {\n        address.push(0);\n      }\n    }\n    const ipAddress: string = address.join('.');\n    if ( !this.validIp(ipAddress) ) {\n      throw new Error(`${ipAddress} is not a valid IP Address`);\n    }\n    return ipAddress;\n  }\n}\n\n/**\n * Creates a network based on a CIDR Block to build contained subnets\n */\nexport class NetworkBuilder {\n\n  /**\n   * The CIDR range used when creating the network\n   */\n  public readonly networkCidr: CidrBlock;\n\n  /**\n   * The list of CIDR blocks for subnets within this network\n   */\n  private readonly subnetCidrs: CidrBlock[] = [];\n\n  /**\n   * The next available IP address as a number\n   */\n  private nextAvailableIp: number;\n\n  /**\n   * Create a network using the provided CIDR block\n   *\n   * No subnets are allocated in the constructor, the maxIpConsumed is set one\n   * less than the first IP in the network\n   *\n   */\n  constructor(cidr: string) {\n    this.networkCidr = new CidrBlock(cidr);\n    this.subnetCidrs = [];\n    this.nextAvailableIp = this.networkCidr.minAddress();\n  }\n\n  /**\n   * Add a subnet to the network and update the maxIpConsumed\n   */\n  public addSubnet(mask: number): string {\n    return this.addSubnets(mask, 1)[0];\n  }\n\n  /**\n   * Add {count} number of subnets to the network and update the maxIpConsumed\n   */\n  public addSubnets(mask: number, count: number = 1): string[] {\n    if (mask < 16 || mask > 28 ) {\n      throw new InvalidCidrRangeError(`x.x.x.x/${mask}`);\n    }\n    const maxIp = this.nextAvailableIp + (CidrBlock.calculateNetsize(mask) * count);\n    if (this.networkCidr.maxAddress() < maxIp - 1) {\n      throw new Error(`${count} of /${mask} exceeds remaining space of ${this.networkCidr.cidr}`);\n    }\n    const subnets: CidrBlock[] = [];\n    for (let i = 0; i < count; i ++) {\n      const subnet: CidrBlock = new CidrBlock(this.nextAvailableIp, mask);\n      this.nextAvailableIp = subnet.nextBlock().minAddress();\n      this.subnetCidrs.push(subnet);\n      subnets.push(subnet);\n    }\n    return subnets.map((subnet) => (subnet.cidr));\n  }\n\n  /**\n   * return the CIDR notation strings for all subnets in the network\n   */\n  public get cidrStrings(): string[] {\n    return this.subnetCidrs.map((subnet) => (subnet.cidr));\n  }\n\n  /**\n   * Calculates the largest subnet to create of the given count from the\n   * remaining IP space\n   */\n  public maskForRemainingSubnets(subnetCount: number): number {\n    const remaining: number = this.networkCidr.maxAddress() - this.nextAvailableIp + 1;\n    const ipsPerSubnet: number = Math.floor(remaining / subnetCount);\n    return 32 - Math.floor(Math.log2(ipsPerSubnet));\n  }\n}\n\n/**\n * A block of IP address space with a given bit prefix\n */\nexport class CidrBlock {\n\n  /**\n   * Calculates the netmask for a given CIDR mask\n   *\n   * For example:\n   * CidrBlock.calculateNetmask(24) returns '255.255.255.0'\n   */\n  public static calculateNetmask(mask: number): string {\n    return NetworkUtils.numToIp(2 ** 32 - 2 ** (32 - mask));\n  }\n\n  /**\n   * Calculates the number IP addresses in a CIDR Mask\n   *\n   * For example:\n   * CidrBlock.calculateNetsize(24) returns 256\n   */\n  public static calculateNetsize(mask: number): number {\n    return 2 ** (32 - mask);\n  }\n\n  /*\n   * The CIDR Block represented as a string e.g. '10.0.0.0/21'\n   */\n  public readonly cidr: string;\n\n  /*\n   * The CIDR mask e.g. for CIDR '10.0.0.0/21' returns 21\n   */\n  public readonly mask: number;\n\n  /*\n   * The total number of IP addresses in the CIDR\n   */\n  public readonly networkSize: number;\n\n  /*\n   * The network address provided in CIDR creation offset by the Netsize -1\n   */\n  private readonly networkAddress: number;\n\n  /*\n   * Parses either CIDR notation String or two numbers representing the IP\n   * space\n   *\n   * cidr expects a string '10.0.0.0/16'\n   * ipAddress expects a number\n   * mask expects a number\n   *\n   * If the given `cidr` or `ipAddress` is not the beginning of the block,\n   * then the next available block will be returned. For example, if\n   * `10.0.3.1/28` is given the returned block will represent `10.0.3.16/28`.\n   */\n  constructor(cidr: string)\n  constructor(ipAddress: number, mask: number)\n  constructor(ipAddressOrCidr: string | number, mask?: number) {\n    if (typeof ipAddressOrCidr === 'string') {\n      this.mask = parseInt(ipAddressOrCidr.split('/')[1], 10);\n      this.networkAddress = NetworkUtils.ipToNum(ipAddressOrCidr.split('/')[0]) +\n        CidrBlock.calculateNetsize(this.mask) - 1;\n    } else {\n      if (typeof mask === 'number') {\n        this.mask = mask;\n      } else {\n        // this should be impossible\n        this.mask = 16;\n      }\n      this.networkAddress = ipAddressOrCidr + CidrBlock.calculateNetsize(this.mask) - 1;\n      this.networkSize = 2 ** (32 - this.mask);\n    }\n    this.networkSize = 2 ** (32 - this.mask);\n    this.cidr = `${this.minIp()}/${this.mask}`;\n  }\n\n  /*\n   * The maximum IP in the CIDR Block e.g. '10.0.8.255'\n   */\n  public maxIp(): string {\n    // min + (2^(32-mask)) - 1 [zero needs to count]\n    return NetworkUtils.numToIp(this.maxAddress());\n  }\n\n  /*\n   * The minimum IP in the CIDR Block e.g. '10.0.0.0'\n   */\n  public minIp(): string {\n    return NetworkUtils.numToIp(this.minAddress());\n  }\n\n  /*\n   * Returns the number representation for the minimum IPv4 address\n   */\n  public minAddress(): number {\n    const div = this.networkAddress % this.networkSize;\n    return this.networkAddress - div;\n  }\n\n  /*\n   * Returns the number representation for the maximum IPv4 address\n   */\n  public maxAddress(): number {\n    // min + (2^(32-mask)) - 1 [zero needs to count]\n    return this.minAddress() + this.networkSize - 1;\n  }\n\n  /*\n   * Returns the next CIDR Block of the same mask size\n   */\n  public nextBlock(): CidrBlock {\n    return new CidrBlock(this.maxAddress() + 1, this.mask);\n  }\n\n  /*\n   * Returns true if this CidrBlock fully contains the provided CidrBlock\n   */\n  public containsCidr(other: CidrBlock): boolean {\n    return (this.maxAddress() >= other.maxAddress()) &&\n      (this.minAddress() <= other.minAddress());\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
