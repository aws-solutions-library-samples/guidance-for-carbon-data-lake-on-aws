"use strict";var _a,_b;Object.defineProperty(exports,"__esModule",{value:!0}),exports.PropagatedTagSource=exports.DeploymentControllerType=exports.LaunchType=exports.BaseService=exports.ListenerConfig=void 0;const jsiiDeprecationWarnings=require("../../../.warnings.jsii.js"),JSII_RTTI_SYMBOL_1=Symbol.for("jsii.rtti"),appscaling=require("../../../aws-applicationautoscaling"),cloudwatch=require("../../../aws-cloudwatch"),ec2=require("../../../aws-ec2"),elbv2=require("../../../aws-elasticloadbalancingv2"),iam=require("../../../aws-iam"),cloudmap=require("../../../aws-servicediscovery"),core_1=require("../../../core"),task_definition_1=require("../base/task-definition"),cluster_1=require("../cluster"),ecs_generated_1=require("../ecs.generated"),scalable_task_count_1=require("./scalable-task-count");class ListenerConfig{static applicationListener(listener,props){return jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancingv2_ApplicationListener(listener),jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancingv2_AddApplicationTargetsProps(props),new ApplicationListenerConfig(listener,props)}static networkListener(listener,props){return jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancingv2_NetworkListener(listener),jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancingv2_AddNetworkTargetsProps(props),new NetworkListenerConfig(listener,props)}}exports.ListenerConfig=ListenerConfig,_a=JSII_RTTI_SYMBOL_1,ListenerConfig[_a]={fqn:"aws-cdk-lib.aws_ecs.ListenerConfig",version:"2.15.0"};class ApplicationListenerConfig extends ListenerConfig{constructor(listener,props){super();this.listener=listener,this.props=props}addTargets(id,target,service){var _c;const props=this.props||{},protocol=props.protocol,port=(_c=props.port)!==null&&_c!==void 0?_c:protocol===elbv2.ApplicationProtocol.HTTPS?443:80;this.listener.addTargets(id,{...props,targets:[service.loadBalancerTarget({...target})],port})}}class NetworkListenerConfig extends ListenerConfig{constructor(listener,props){super();this.listener=listener,this.props=props}addTargets(id,target,service){var _c,_d;const port=(_d=(_c=this.props)===null||_c===void 0?void 0:_c.port)!==null&&_d!==void 0?_d:80;this.listener.addTargets(id,{...this.props,targets:[service.loadBalancerTarget({...target})],port})}}class BaseService extends core_1.Resource{constructor(scope,id,props,additionalProps,taskDefinition){var _c,_d,_e,_f,_g,_h,_j,_k,_l;super(scope,id,{physicalName:props.serviceName});if(this.connections=new ec2.Connections,this.loadBalancers=new Array,this.serviceRegistries=new Array,jsiiDeprecationWarnings.aws_cdk_lib_aws_ecs_BaseServiceProps(props),jsiiDeprecationWarnings.aws_cdk_lib_aws_ecs_TaskDefinition(taskDefinition),props.propagateTags&&props.propagateTaskTagsFrom)throw new Error("You can only specify either propagateTags or propagateTaskTagsFrom. Alternatively, you can leave both blank");this.taskDefinition=taskDefinition;const launchType=((_c=props.deploymentController)===null||_c===void 0?void 0:_c.type)===DeploymentControllerType.EXTERNAL||props.capacityProviderStrategies!==void 0?void 0:props.launchType,propagateTagsFromSource=(_e=(_d=props.propagateTaskTagsFrom)!==null&&_d!==void 0?_d:props.propagateTags)!==null&&_e!==void 0?_e:PropagatedTagSource.NONE;if(this.resource=new ecs_generated_1.CfnService(this,"Service",{desiredCount:props.desiredCount,serviceName:this.physicalName,loadBalancers:core_1.Lazy.any({produce:()=>this.loadBalancers},{omitEmptyArray:!0}),deploymentConfiguration:{maximumPercent:props.maxHealthyPercent||200,minimumHealthyPercent:props.minHealthyPercent===void 0?50:props.minHealthyPercent,deploymentCircuitBreaker:props.circuitBreaker?{enable:!0,rollback:(_f=props.circuitBreaker.rollback)!==null&&_f!==void 0?_f:!1}:void 0},propagateTags:propagateTagsFromSource===PropagatedTagSource.NONE?void 0:props.propagateTags,enableEcsManagedTags:(_g=props.enableECSManagedTags)!==null&&_g!==void 0?_g:!1,deploymentController:props.circuitBreaker?{type:DeploymentControllerType.ECS}:props.deploymentController,launchType,enableExecuteCommand:props.enableExecuteCommand,capacityProviderStrategy:props.capacityProviderStrategies,healthCheckGracePeriodSeconds:this.evaluateHealthGracePeriod(props.healthCheckGracePeriod),networkConfiguration:core_1.Lazy.any({produce:()=>this.networkConfiguration},{omitEmptyArray:!0}),serviceRegistries:core_1.Lazy.any({produce:()=>this.serviceRegistries},{omitEmptyArray:!0}),...additionalProps}),((_h=props.deploymentController)===null||_h===void 0?void 0:_h.type)===DeploymentControllerType.EXTERNAL&&core_1.Annotations.of(this).addWarning("taskDefinition and launchType are blanked out when using external deployment controller."),this.serviceArn=this.getResourceArnAttribute(this.resource.ref,{service:"ecs",resource:"service",resourceName:`${props.cluster.clusterName}/${this.physicalName}`}),this.serviceName=this.getResourceNameAttribute(this.resource.attrName),this.cluster=props.cluster,props.cloudMapOptions&&this.enableCloudMap(props.cloudMapOptions),props.enableExecuteCommand){this.enableExecuteCommand();const logging=(_k=(_j=this.cluster.executeCommandConfiguration)===null||_j===void 0?void 0:_j.logging)!==null&&_k!==void 0?_k:cluster_1.ExecuteCommandLogging.DEFAULT;((_l=this.cluster.executeCommandConfiguration)===null||_l===void 0?void 0:_l.kmsKey)&&this.enableExecuteCommandEncryption(logging),logging!==cluster_1.ExecuteCommandLogging.NONE&&this.executeCommandLogConfiguration()}this.node.defaultChild=this.resource}static fromServiceArnWithCluster(scope,id,serviceArn){const arn=core_1.Stack.of(scope).splitArn(serviceArn,core_1.ArnFormat.SLASH_RESOURCE_NAME),resourceName=arn.resourceName;if(!resourceName)throw new Error("Missing resource Name from service ARN: ${serviceArn}");const resourceNameParts=resourceName.split("/");if(resourceNameParts.length!==2)throw new Error(`resource name ${resourceName} from service ARN: ${serviceArn} is not using the ARN cluster format`);const clusterName=resourceNameParts[0],serviceName=resourceNameParts[1],clusterArn=core_1.Stack.of(scope).formatArn({partition:arn.partition,region:arn.region,account:arn.account,service:"ecs",resource:"cluster",resourceName:clusterName}),cluster=cluster_1.Cluster.fromClusterArn(scope,`${id}Cluster`,clusterArn);class Import extends core_1.Resource{constructor(){super(...arguments);this.serviceArn=serviceArn,this.serviceName=serviceName,this.cluster=cluster}}return new Import(scope,id,{environmentFromArn:serviceArn})}get cloudMapService(){return this.cloudmapService}executeCommandLogConfiguration(){var _c,_d;const logConfiguration=(_c=this.cluster.executeCommandConfiguration)===null||_c===void 0?void 0:_c.logConfiguration;this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["logs:DescribeLogGroups"],resources:["*"]}));const logGroupArn=(logConfiguration==null?void 0:logConfiguration.cloudWatchLogGroup)?`arn:${this.stack.partition}:logs:${this.stack.region}:${this.stack.account}:log-group:${logConfiguration.cloudWatchLogGroup.logGroupName}:*`:"*";this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["logs:CreateLogStream","logs:DescribeLogStreams","logs:PutLogEvents"],resources:[logGroupArn]})),((_d=logConfiguration==null?void 0:logConfiguration.s3Bucket)===null||_d===void 0?void 0:_d.bucketName)&&(this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["s3:GetBucketLocation"],resources:["*"]})),this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["s3:PutObject"],resources:[`arn:${this.stack.partition}:s3:::${logConfiguration.s3Bucket.bucketName}/*`]})),logConfiguration.s3EncryptionEnabled&&this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["s3:GetEncryptionConfiguration"],resources:[`arn:${this.stack.partition}:s3:::${logConfiguration.s3Bucket.bucketName}`]})))}enableExecuteCommandEncryption(logging){var _c,_d,_e,_f,_g,_h,_j,_k;this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["kms:Decrypt","kms:GenerateDataKey"],resources:[`${(_d=(_c=this.cluster.executeCommandConfiguration)===null||_c===void 0?void 0:_c.kmsKey)===null||_d===void 0?void 0:_d.keyArn}`]})),(_f=(_e=this.cluster.executeCommandConfiguration)===null||_e===void 0?void 0:_e.kmsKey)===null||_f===void 0||_f.addToResourcePolicy(new iam.PolicyStatement({actions:["kms:*"],resources:["*"],principals:[new iam.ArnPrincipal(`arn:${this.stack.partition}:iam::${this.stack.account}:root`)]})),(logging===cluster_1.ExecuteCommandLogging.DEFAULT||((_h=(_g=this.cluster.executeCommandConfiguration)===null||_g===void 0?void 0:_g.logConfiguration)===null||_h===void 0?void 0:_h.cloudWatchEncryptionEnabled))&&((_k=(_j=this.cluster.executeCommandConfiguration)===null||_j===void 0?void 0:_j.kmsKey)===null||_k===void 0||_k.addToResourcePolicy(new iam.PolicyStatement({actions:["kms:Encrypt*","kms:Decrypt*","kms:ReEncrypt*","kms:GenerateDataKey*","kms:Describe*"],resources:["*"],principals:[new iam.ServicePrincipal(`logs.${this.stack.region}.amazonaws.com`)],conditions:{ArnLike:{"kms:EncryptionContext:aws:logs:arn":`arn:${this.stack.partition}:logs:${this.stack.region}:${this.stack.account}:*`}}})))}attachToApplicationTargetGroup(targetGroup){return jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancingv2_IApplicationTargetGroup(targetGroup),this.defaultLoadBalancerTarget.attachToApplicationTargetGroup(targetGroup)}attachToClassicLB(loadBalancer){return jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancing_LoadBalancer(loadBalancer),this.defaultLoadBalancerTarget.attachToClassicLB(loadBalancer)}loadBalancerTarget(options){jsiiDeprecationWarnings.aws_cdk_lib_aws_ecs_LoadBalancerTargetOptions(options);const self=this,target=this.taskDefinition._validateTarget(options),connections=self.connections;return{attachToApplicationTargetGroup(targetGroup){return targetGroup.registerConnectable(self,self.taskDefinition._portRangeFromPortMapping(target.portMapping)),self.attachToELBv2(targetGroup,target.containerName,target.portMapping.containerPort)},attachToNetworkTargetGroup(targetGroup){return self.attachToELBv2(targetGroup,target.containerName,target.portMapping.containerPort)},connections,attachToClassicLB(loadBalancer){return self.attachToELB(loadBalancer,target.containerName,target.portMapping.containerPort)}}}registerLoadBalancerTargets(...targets){jsiiDeprecationWarnings.aws_cdk_lib_aws_ecs_EcsTarget(targets);for(const target of targets)target.listener.addTargets(target.newTargetGroupId,{containerName:target.containerName,containerPort:target.containerPort,protocol:target.protocol},this)}attachToNetworkTargetGroup(targetGroup){return jsiiDeprecationWarnings.aws_cdk_lib_aws_elasticloadbalancingv2_INetworkTargetGroup(targetGroup),this.defaultLoadBalancerTarget.attachToNetworkTargetGroup(targetGroup)}autoScaleTaskCount(props){if(jsiiDeprecationWarnings.aws_cdk_lib_aws_applicationautoscaling_EnableScalingProps(props),this.scalableTaskCount)throw new Error("AutoScaling of task count already enabled for this service");return this.scalableTaskCount=new scalable_task_count_1.ScalableTaskCount(this,"TaskCount",{serviceNamespace:appscaling.ServiceNamespace.ECS,resourceId:`service/${this.cluster.clusterName}/${this.serviceName}`,dimension:"ecs:service:DesiredCount",role:this.makeAutoScalingRole(),...props})}enableCloudMap(options){var _c;jsiiDeprecationWarnings.aws_cdk_lib_aws_ecs_CloudMapOptions(options);const sdNamespace=(_c=options.cloudMapNamespace)!==null&&_c!==void 0?_c:this.cluster.defaultCloudMapNamespace;if(sdNamespace===void 0)throw new Error("Cannot enable service discovery if a Cloudmap Namespace has not been created in the cluster.");const networkMode=this.taskDefinition.networkMode;if(networkMode===task_definition_1.NetworkMode.NONE)throw new Error("Cannot use a service discovery if NetworkMode is None. Use Bridge, Host or AwsVpc instead.");let dnsRecordType=options.dnsRecordType;if((networkMode===task_definition_1.NetworkMode.BRIDGE||networkMode===task_definition_1.NetworkMode.HOST)&&(dnsRecordType===void 0&&(dnsRecordType=cloudmap.DnsRecordType.SRV),dnsRecordType!==cloudmap.DnsRecordType.SRV))throw new Error("SRV records must be used when network mode is Bridge or Host.");networkMode===task_definition_1.NetworkMode.AWS_VPC&&dnsRecordType===void 0&&(dnsRecordType=cloudmap.DnsRecordType.A);const{containerName,containerPort}=determineContainerNameAndPort({taskDefinition:this.taskDefinition,dnsRecordType,container:options.container,containerPort:options.containerPort}),cloudmapService=new cloudmap.Service(this,"CloudmapService",{namespace:sdNamespace,name:options.name,dnsRecordType,customHealthCheck:{failureThreshold:options.failureThreshold||1},dnsTtl:options.dnsTtl}),serviceArn=cloudmapService.serviceArn;return this.addServiceRegistry({arn:serviceArn,containerName,containerPort}),this.cloudmapService=cloudmapService,cloudmapService}associateCloudMapService(options){jsiiDeprecationWarnings.aws_cdk_lib_aws_ecs_AssociateCloudMapServiceOptions(options);const service=options.service,{containerName,containerPort}=determineContainerNameAndPort({taskDefinition:this.taskDefinition,dnsRecordType:service.dnsRecordType,container:options.container,containerPort:options.containerPort});this.addServiceRegistry({arn:service.serviceArn,containerName,containerPort})}metric(metricName,props){return jsiiDeprecationWarnings.aws_cdk_lib_aws_cloudwatch_MetricOptions(props),new cloudwatch.Metric({namespace:"AWS/ECS",metricName,dimensionsMap:{ClusterName:this.cluster.clusterName,ServiceName:this.serviceName},...props}).attachTo(this)}metricMemoryUtilization(props){return jsiiDeprecationWarnings.aws_cdk_lib_aws_cloudwatch_MetricOptions(props),this.metric("MemoryUtilization",props)}metricCpuUtilization(props){return jsiiDeprecationWarnings.aws_cdk_lib_aws_cloudwatch_MetricOptions(props),this.metric("CPUUtilization",props)}configureAwsVpcNetworking(vpc,assignPublicIp,vpcSubnets,securityGroup){vpcSubnets===void 0&&(vpcSubnets=assignPublicIp?{subnetType:ec2.SubnetType.PUBLIC}:{}),securityGroup===void 0&&(securityGroup=new ec2.SecurityGroup(this,"SecurityGroup",{vpc})),this.connections.addSecurityGroup(securityGroup),this.networkConfiguration={awsvpcConfiguration:{assignPublicIp:assignPublicIp?"ENABLED":"DISABLED",subnets:vpc.selectSubnets(vpcSubnets).subnetIds,securityGroups:core_1.Lazy.list({produce:()=>[securityGroup.securityGroupId]})}}}configureAwsVpcNetworkingWithSecurityGroups(vpc,assignPublicIp,vpcSubnets,securityGroups){jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_IVpc(vpc),jsiiDeprecationWarnings.aws_cdk_lib_aws_ec2_SubnetSelection(vpcSubnets),vpcSubnets===void 0&&(vpcSubnets=assignPublicIp?{subnetType:ec2.SubnetType.PUBLIC}:{}),(securityGroups===void 0||securityGroups.length===0)&&(securityGroups=[new ec2.SecurityGroup(this,"SecurityGroup",{vpc})]),securityGroups.forEach(sg=>{this.connections.addSecurityGroup(sg)},this),this.networkConfiguration={awsvpcConfiguration:{assignPublicIp:assignPublicIp?"ENABLED":"DISABLED",subnets:vpc.selectSubnets(vpcSubnets).subnetIds,securityGroups:securityGroups.map(sg=>sg.securityGroupId)}}}renderServiceRegistry(registry){return{registryArn:registry.arn,containerName:registry.containerName,containerPort:registry.containerPort}}attachToELB(loadBalancer,containerName,containerPort){if(this.taskDefinition.networkMode===task_definition_1.NetworkMode.AWS_VPC)throw new Error("Cannot use a Classic Load Balancer if NetworkMode is AwsVpc. Use Host or Bridge instead.");if(this.taskDefinition.networkMode===task_definition_1.NetworkMode.NONE)throw new Error("Cannot use a Classic Load Balancer if NetworkMode is None. Use Host or Bridge instead.");this.loadBalancers.push({loadBalancerName:loadBalancer.loadBalancerName,containerName,containerPort})}attachToELBv2(targetGroup,containerName,containerPort){if(this.taskDefinition.networkMode===task_definition_1.NetworkMode.NONE)throw new Error("Cannot use a load balancer if NetworkMode is None. Use Bridge, Host or AwsVpc instead.");return this.loadBalancers.push({targetGroupArn:targetGroup.targetGroupArn,containerName,containerPort}),this.resource.node.addDependency(targetGroup.loadBalancerAttached),{targetType:this.taskDefinition.networkMode===task_definition_1.NetworkMode.AWS_VPC?elbv2.TargetType.IP:elbv2.TargetType.INSTANCE}}get defaultLoadBalancerTarget(){return this.loadBalancerTarget({containerName:this.taskDefinition.defaultContainer.containerName})}makeAutoScalingRole(){return iam.Role.fromRoleArn(this,"ScalingRole",core_1.Stack.of(this).formatArn({region:"",service:"iam",resource:"role/aws-service-role/ecs.application-autoscaling.amazonaws.com",resourceName:"AWSServiceRoleForApplicationAutoScaling_ECSService"}))}addServiceRegistry(registry){if(this.serviceRegistries.length>=1)throw new Error("Cannot associate with the given service discovery registry. ECS supports at most one service registry per service.");const sr=this.renderServiceRegistry(registry);this.serviceRegistries.push(sr)}evaluateHealthGracePeriod(providedHealthCheckGracePeriod){return core_1.Lazy.any({produce:()=>{var _c;return(_c=providedHealthCheckGracePeriod==null?void 0:providedHealthCheckGracePeriod.toSeconds())!==null&&_c!==void 0?_c:this.loadBalancers.length>0?60:void 0}})}enableExecuteCommand(){this.taskDefinition.addToTaskRolePolicy(new iam.PolicyStatement({actions:["ssmmessages:CreateControlChannel","ssmmessages:CreateDataChannel","ssmmessages:OpenControlChannel","ssmmessages:OpenDataChannel"],resources:["*"]}))}}exports.BaseService=BaseService,_b=JSII_RTTI_SYMBOL_1,BaseService[_b]={fqn:"aws-cdk-lib.aws_ecs.BaseService",version:"2.15.0"};var LaunchType;(function(LaunchType2){LaunchType2.EC2="EC2",LaunchType2.FARGATE="FARGATE",LaunchType2.EXTERNAL="EXTERNAL"})(LaunchType=exports.LaunchType||(exports.LaunchType={}));var DeploymentControllerType;(function(DeploymentControllerType2){DeploymentControllerType2.ECS="ECS",DeploymentControllerType2.CODE_DEPLOY="CODE_DEPLOY",DeploymentControllerType2.EXTERNAL="EXTERNAL"})(DeploymentControllerType=exports.DeploymentControllerType||(exports.DeploymentControllerType={}));var PropagatedTagSource;(function(PropagatedTagSource2){PropagatedTagSource2.SERVICE="SERVICE",PropagatedTagSource2.TASK_DEFINITION="TASK_DEFINITION",PropagatedTagSource2.NONE="NONE"})(PropagatedTagSource=exports.PropagatedTagSource||(exports.PropagatedTagSource={}));function determineContainerNameAndPort(options){var _c,_d;if(options.dnsRecordType===cloudmap.DnsRecordType.SRV){if(options.container&&options.container.taskDefinition!=options.taskDefinition)throw new Error("Cannot add discovery for a container from another task definition");const container=(_c=options.container)!==null&&_c!==void 0?_c:options.taskDefinition.defaultContainer;if(options.containerPort&&!container.portMappings.some(mapping=>mapping.containerPort===options.containerPort))throw new Error("Cannot add discovery for a container port that has not been mapped");return{containerName:container.containerName,containerPort:(_d=options.containerPort)!==null&&_d!==void 0?_d:options.taskDefinition.defaultContainer.containerPort}}return{}}
//# sourceMappingURL=base-service.js.map
