{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["/* eslint-disable no-console */\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { IsCompleteResponse, OnEventResponse } from '../../../custom-resources/lib/provider-framework/types';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as aws from 'aws-sdk';\nimport { EksClient, ResourceEvent, ResourceHandler } from './common';\n\nconst MAX_CLUSTER_NAME_LEN = 100;\n\nexport class ClusterResourceHandler extends ResourceHandler {\n  public get clusterName() {\n    if (!this.physicalResourceId) {\n      throw new Error('Cannot determine cluster name without physical resource ID');\n    }\n\n    return this.physicalResourceId;\n  }\n\n  private readonly newProps: aws.EKS.CreateClusterRequest;\n  private readonly oldProps: Partial<aws.EKS.CreateClusterRequest>;\n\n  constructor(eks: EksClient, event: ResourceEvent) {\n    super(eks, event);\n\n    this.newProps = parseProps(this.event.ResourceProperties);\n    this.oldProps = event.RequestType === 'Update' ? parseProps(event.OldResourceProperties) : {};\n  }\n\n  // ------\n  // CREATE\n  // ------\n\n  protected async onCreate(): Promise<OnEventResponse> {\n    console.log('onCreate: creating cluster with options:', JSON.stringify(this.newProps, undefined, 2));\n    if (!this.newProps.roleArn) {\n      throw new Error('\"roleArn\" is required');\n    }\n\n    const clusterName = this.newProps.name || this.generateClusterName();\n\n    const resp = await this.eks.createCluster({\n      ...this.newProps,\n      name: clusterName,\n    });\n\n    if (!resp.cluster) {\n      throw new Error(`Error when trying to create cluster ${clusterName}: CreateCluster returned without cluster information`);\n    }\n\n    return {\n      PhysicalResourceId: resp.cluster.name,\n    };\n  }\n\n  protected async isCreateComplete() {\n    return this.isActive();\n  }\n\n  // ------\n  // DELETE\n  // ------\n\n  protected async onDelete(): Promise<OnEventResponse> {\n    console.log(`onDelete: deleting cluster ${this.clusterName}`);\n    try {\n      await this.eks.deleteCluster({ name: this.clusterName });\n    } catch (e) {\n      if (e.code !== 'ResourceNotFoundException') {\n        throw e;\n      } else {\n        console.log(`cluster ${this.clusterName} not found, idempotently succeeded`);\n      }\n    }\n    return {\n      PhysicalResourceId: this.clusterName,\n    };\n  }\n\n  protected async isDeleteComplete(): Promise<IsCompleteResponse> {\n    console.log(`isDeleteComplete: waiting for cluster ${this.clusterName} to be deleted`);\n\n    try {\n      const resp = await this.eks.describeCluster({ name: this.clusterName });\n      console.log('describeCluster returned:', JSON.stringify(resp, undefined, 2));\n    } catch (e) {\n      if (e.code === 'ResourceNotFoundException') {\n        console.log('received ResourceNotFoundException, this means the cluster has been deleted (or never existed)');\n        return { IsComplete: true };\n      }\n\n      console.log('describeCluster error:', e);\n      throw e;\n    }\n\n    return {\n      IsComplete: false,\n    };\n  }\n\n  // ------\n  // UPDATE\n  // ------\n\n  protected async onUpdate() {\n    const updates = analyzeUpdate(this.oldProps, this.newProps);\n    console.log('onUpdate:', JSON.stringify({ updates }, undefined, 2));\n\n    // updates to encryption config is not supported\n    if (updates.updateEncryption) {\n      throw new Error('Cannot update cluster encryption configuration');\n    }\n\n    // if there is an update that requires replacement, go ahead and just create\n    // a new cluster with the new config. The old cluster will automatically be\n    // deleted by cloudformation upon success.\n    if (updates.replaceName || updates.replaceRole || updates.replaceVpc) {\n\n      // if we are replacing this cluster and the cluster has an explicit\n      // physical name, the creation of the new cluster will fail with \"there is\n      // already a cluster with that name\". this is a common behavior for\n      // CloudFormation resources that support specifying a physical name.\n      if (this.oldProps.name === this.newProps.name && this.oldProps.name) {\n        throw new Error(`Cannot replace cluster \"${this.oldProps.name}\" since it has an explicit physical name. Either rename the cluster or remove the \"name\" configuration`);\n      }\n\n      return this.onCreate();\n    }\n\n    // if a version update is required, issue the version update\n    if (updates.updateVersion) {\n      if (!this.newProps.version) {\n        throw new Error(`Cannot remove cluster version configuration. Current version is ${this.oldProps.version}`);\n      }\n\n      return this.updateClusterVersion(this.newProps.version);\n    }\n\n    if (updates.updateLogging || updates.updateAccess) {\n      const config: aws.EKS.UpdateClusterConfigRequest = {\n        name: this.clusterName,\n        logging: this.newProps.logging,\n      };\n      if (updates.updateAccess) {\n        // Updating the cluster with securityGroupIds and subnetIds (as specified in the warning here:\n        // https://awscli.amazonaws.com/v2/documentation/api/latest/reference/eks/update-cluster-config.html)\n        // will fail, therefore we take only the access fields explicitly\n        config.resourcesVpcConfig = {\n          endpointPrivateAccess: this.newProps.resourcesVpcConfig.endpointPrivateAccess,\n          endpointPublicAccess: this.newProps.resourcesVpcConfig.endpointPublicAccess,\n          publicAccessCidrs: this.newProps.resourcesVpcConfig.publicAccessCidrs,\n        };\n      }\n      const updateResponse = await this.eks.updateClusterConfig(config);\n\n      return { EksUpdateId: updateResponse.update?.id };\n    }\n\n    // no updates\n    return;\n  }\n\n  protected async isUpdateComplete() {\n    console.log('isUpdateComplete');\n\n    // if this is an EKS update, we will monitor the update event itself\n    if (this.event.EksUpdateId) {\n      const complete = await this.isEksUpdateComplete(this.event.EksUpdateId);\n      if (!complete) {\n        return { IsComplete: false };\n      }\n\n      // fall through: if the update is done, we simply delegate to isActive()\n      // in order to extract attributes and state from the cluster itself, which\n      // is supposed to be in an ACTIVE state after the update is complete.\n    }\n\n    return this.isActive();\n  }\n\n  private async updateClusterVersion(newVersion: string) {\n    console.log(`updating cluster version to ${newVersion}`);\n\n    // update-cluster-version will fail if we try to update to the same version,\n    // so skip in this case.\n    const cluster = (await this.eks.describeCluster({ name: this.clusterName })).cluster;\n    if (cluster?.version === newVersion) {\n      console.log(`cluster already at version ${cluster.version}, skipping version update`);\n      return;\n    }\n\n    const updateResponse = await this.eks.updateClusterVersion({ name: this.clusterName, version: newVersion });\n    return { EksUpdateId: updateResponse.update?.id };\n  }\n\n  private async isActive(): Promise<IsCompleteResponse> {\n    console.log('waiting for cluster to become ACTIVE');\n    const resp = await this.eks.describeCluster({ name: this.clusterName });\n    console.log('describeCluster result:', JSON.stringify(resp, undefined, 2));\n    const cluster = resp.cluster;\n\n    // if cluster is undefined (shouldnt happen) or status is not ACTIVE, we are\n    // not complete. note that the custom resource provider framework forbids\n    // returning attributes (Data) if isComplete is false.\n    if (cluster?.status === 'FAILED') {\n      // not very informative, unfortunately the response doesn't contain any error\n      // information :\\\n      throw new Error('Cluster is in a FAILED status');\n    } else if (cluster?.status !== 'ACTIVE') {\n      return {\n        IsComplete: false,\n      };\n    } else {\n      return {\n        IsComplete: true,\n        Data: {\n          Name: cluster.name,\n          Endpoint: cluster.endpoint,\n          Arn: cluster.arn,\n\n          // IMPORTANT: CFN expects that attributes will *always* have values,\n          // so return an empty string in case the value is not defined.\n          // Otherwise, CFN will throw with `Vendor response doesn't contain\n          // XXXX key`.\n\n          CertificateAuthorityData: cluster.certificateAuthority?.data ?? '',\n          ClusterSecurityGroupId: cluster.resourcesVpcConfig?.clusterSecurityGroupId ?? '',\n          OpenIdConnectIssuerUrl: cluster.identity?.oidc?.issuer ?? '',\n          OpenIdConnectIssuer: cluster.identity?.oidc?.issuer?.substring(8) ?? '', // Strips off https:// from the issuer url\n\n          // We can safely return the first item from encryption configuration array, because it has a limit of 1 item\n          // https://docs.aws.amazon.com/eks/latest/APIReference/API_CreateCluster.html#AmazonEKS-CreateCluster-request-encryptionConfig\n          EncryptionConfigKeyArn: cluster.encryptionConfig?.shift()?.provider?.keyArn ?? '',\n        },\n      };\n    }\n  }\n\n  private async isEksUpdateComplete(eksUpdateId: string) {\n    this.log({ isEksUpdateComplete: eksUpdateId });\n\n    const describeUpdateResponse = await this.eks.describeUpdate({\n      name: this.clusterName,\n      updateId: eksUpdateId,\n    });\n\n    this.log({ describeUpdateResponse });\n\n    if (!describeUpdateResponse.update) {\n      throw new Error(`unable to describe update with id \"${eksUpdateId}\"`);\n    }\n\n    switch (describeUpdateResponse.update.status) {\n      case 'InProgress':\n        return false;\n      case 'Successful':\n        return true;\n      case 'Failed':\n      case 'Cancelled':\n        throw new Error(`cluster update id \"${eksUpdateId}\" failed with errors: ${JSON.stringify(describeUpdateResponse.update.errors)}`);\n      default:\n        throw new Error(`unknown status \"${describeUpdateResponse.update.status}\" for update id \"${eksUpdateId}\"`);\n    }\n  }\n\n  private generateClusterName() {\n    const suffix = this.requestId.replace(/-/g, ''); // 32 chars\n    const prefix = this.logicalResourceId.substr(0, MAX_CLUSTER_NAME_LEN - suffix.length - 1);\n    return `${prefix}-${suffix}`;\n  }\n}\n\nfunction parseProps(props: any): aws.EKS.CreateClusterRequest {\n\n  const parsed = props?.Config ?? {};\n\n  // this is weird but these boolean properties are passed by CFN as a string, and we need them to be booleanic for the SDK.\n  // Otherwise it fails with 'Unexpected Parameter: params.resourcesVpcConfig.endpointPrivateAccess is expected to be a boolean'\n\n  if (typeof (parsed.resourcesVpcConfig?.endpointPrivateAccess) === 'string') {\n    parsed.resourcesVpcConfig.endpointPrivateAccess = parsed.resourcesVpcConfig.endpointPrivateAccess === 'true';\n  }\n\n  if (typeof (parsed.resourcesVpcConfig?.endpointPublicAccess) === 'string') {\n    parsed.resourcesVpcConfig.endpointPublicAccess = parsed.resourcesVpcConfig.endpointPublicAccess === 'true';\n  }\n\n  if (typeof (parsed.logging?.clusterLogging[0].enabled) === 'string') {\n    parsed.logging.clusterLogging[0].enabled = parsed.logging.clusterLogging[0].enabled === 'true';\n  }\n\n  return parsed;\n\n}\n\ninterface UpdateMap {\n  replaceName: boolean; // name\n  replaceVpc: boolean; // resourcesVpcConfig.subnetIds and securityGroupIds\n  replaceRole: boolean; // roleArn\n\n  updateVersion: boolean; // version\n  updateLogging: boolean; // logging\n  updateEncryption: boolean; // encryption (cannot be updated)\n  updateAccess: boolean; // resourcesVpcConfig.endpointPrivateAccess and endpointPublicAccess\n}\n\nfunction analyzeUpdate(oldProps: Partial<aws.EKS.CreateClusterRequest>, newProps: aws.EKS.CreateClusterRequest): UpdateMap {\n  console.log('old props: ', JSON.stringify(oldProps));\n  console.log('new props: ', JSON.stringify(newProps));\n\n  const newVpcProps = newProps.resourcesVpcConfig || {};\n  const oldVpcProps = oldProps.resourcesVpcConfig || {};\n\n  const oldPublicAccessCidrs = new Set(oldVpcProps.publicAccessCidrs ?? []);\n  const newPublicAccessCidrs = new Set(newVpcProps.publicAccessCidrs ?? []);\n  const newEnc = newProps.encryptionConfig || {};\n  const oldEnc = oldProps.encryptionConfig || {};\n\n  return {\n    replaceName: newProps.name !== oldProps.name,\n    replaceVpc:\n      JSON.stringify(newVpcProps.subnetIds) !== JSON.stringify(oldVpcProps.subnetIds) ||\n      JSON.stringify(newVpcProps.securityGroupIds) !== JSON.stringify(oldVpcProps.securityGroupIds),\n    updateAccess:\n      newVpcProps.endpointPrivateAccess !== oldVpcProps.endpointPrivateAccess ||\n      newVpcProps.endpointPublicAccess !== oldVpcProps.endpointPublicAccess ||\n      !setsEqual(newPublicAccessCidrs, oldPublicAccessCidrs),\n    replaceRole: newProps.roleArn !== oldProps.roleArn,\n    updateVersion: newProps.version !== oldProps.version,\n    updateEncryption: JSON.stringify(newEnc) !== JSON.stringify(oldEnc),\n    updateLogging: JSON.stringify(newProps.logging) !== JSON.stringify(oldProps.logging),\n  };\n}\n\nfunction setsEqual(first: Set<string>, second: Set<string>) {\n  return first.size === second.size || [...first].every((e: string) => second.has(e));\n}\n"],
  "mappings": "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",
  "names": []
}
