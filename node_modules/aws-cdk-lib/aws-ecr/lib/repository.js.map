{
  "version": 3,
  "sources": ["repository.ts"],
  "sourcesContent": ["import { EOL } from 'os';\nimport * as events from '../../aws-events';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport { ArnFormat, IResource, Lazy, RemovalPolicy, Resource, Stack, Token } from '../../core';\nimport { IConstruct, Construct } from 'constructs';\nimport { CfnRepository } from './ecr.generated';\nimport { LifecycleRule, TagStatus } from './lifecycle';\n\n/**\n * Represents an ECR repository.\n */\nexport interface IRepository extends IResource {\n  /**\n   * The name of the repository\n   * @attribute\n   */\n  readonly repositoryName: string;\n\n  /**\n   * The ARN of the repository\n   * @attribute\n   */\n  readonly repositoryArn: string;\n\n  /**\n   * The URI of this repository (represents the latest image):\n   *\n   *    ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPOSITORY\n   *\n   * @attribute\n   */\n  readonly repositoryUri: string;\n\n  /**\n   * Returns the URI of the repository for a certain tag. Can be used in `docker push/pull`.\n   *\n   *    ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPOSITORY[:TAG]\n   *\n   * @param tag Image tag to use (tools usually default to \"latest\" if omitted)\n   */\n  repositoryUriForTag(tag?: string): string;\n\n  /**\n   * Returns the URI of the repository for a certain tag. Can be used in `docker push/pull`.\n   *\n   *    ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPOSITORY[@DIGEST]\n   *\n   * @param digest Image digest to use (tools usually default to the image with the \"latest\" tag if omitted)\n   */\n  repositoryUriForDigest(digest?: string): string;\n\n  /**\n   * Add a policy statement to the repository's resource policy\n   */\n  addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;\n\n  /**\n   * Grant the given principal identity permissions to perform the actions on this repository\n   */\n  grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n  /**\n   * Grant the given identity permissions to pull images in this repository.\n   */\n  grantPull(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Grant the given identity permissions to pull and push images to this repository.\n   */\n  grantPullPush(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Define a CloudWatch event that triggers when something happens to this repository\n   *\n   * Requires that there exists at least one CloudTrail Trail in your account\n   * that captures the event. This method will not create the Trail.\n   *\n   * @param id The id of the rule\n   * @param options Options for adding the rule\n   */\n  onCloudTrailEvent(id: string, options?: events.OnEventOptions): events.Rule;\n\n  /**\n   * Defines an AWS CloudWatch event rule that can trigger a target when an image is pushed to this\n   * repository.\n   *\n   * Requires that there exists at least one CloudTrail Trail in your account\n   * that captures the event. This method will not create the Trail.\n   *\n   * @param id The id of the rule\n   * @param options Options for adding the rule\n   */\n  onCloudTrailImagePushed(id: string, options?: OnCloudTrailImagePushedOptions): events.Rule;\n\n  /**\n   * Defines an AWS CloudWatch event rule that can trigger a target when the image scan is completed\n   *\n   *\n   * @param id The id of the rule\n   * @param options Options for adding the rule\n   */\n  onImageScanCompleted(id: string, options?: OnImageScanCompletedOptions): events.Rule;\n\n  /**\n   * Defines a CloudWatch event rule which triggers for repository events. Use\n   * `rule.addEventPattern(pattern)` to specify a filter.\n   */\n  onEvent(id: string, options?: events.OnEventOptions): events.Rule;\n}\n\n/**\n * Base class for ECR repository. Reused between imported repositories and owned repositories.\n */\nexport abstract class RepositoryBase extends Resource implements IRepository {\n  /**\n   * The name of the repository\n   */\n  public abstract readonly repositoryName: string;\n\n  /**\n   * The ARN of the repository\n   */\n  public abstract readonly repositoryArn: string;\n\n  /**\n   * Add a policy statement to the repository's resource policy\n   */\n  public abstract addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;\n\n  /**\n   * The URI of this repository (represents the latest image):\n   *\n   *    ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPOSITORY\n   *\n   */\n  public get repositoryUri() {\n    return this.repositoryUriForTag();\n  }\n\n  /**\n   * Returns the URL of the repository. Can be used in `docker push/pull`.\n   *\n   *    ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPOSITORY[:TAG]\n   *\n   * @param tag Optional image tag\n   */\n  public repositoryUriForTag(tag?: string): string {\n    const tagSuffix = tag ? `:${tag}` : '';\n    return this.repositoryUriWithSuffix(tagSuffix);\n  }\n\n  /**\n   * Returns the URL of the repository. Can be used in `docker push/pull`.\n   *\n   *    ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPOSITORY[@DIGEST]\n   *\n   * @param digest Optional image digest\n   */\n  public repositoryUriForDigest(digest?: string): string {\n    const digestSuffix = digest ? `@${digest}` : '';\n    return this.repositoryUriWithSuffix(digestSuffix);\n  }\n\n  /**\n   * Returns the repository URI, with an appended suffix, if provided.\n   * @param suffix An image tag or an image digest.\n   * @private\n   */\n  private repositoryUriWithSuffix(suffix?: string): string {\n    const parts = this.stack.splitArn(this.repositoryArn, ArnFormat.SLASH_RESOURCE_NAME);\n    return `${parts.account}.dkr.ecr.${parts.region}.${this.stack.urlSuffix}/${this.repositoryName}${suffix}`;\n  }\n\n  /**\n   * Define a CloudWatch event that triggers when something happens to this repository\n   *\n   * Requires that there exists at least one CloudTrail Trail in your account\n   * that captures the event. This method will not create the Trail.\n   *\n   * @param id The id of the rule\n   * @param options Options for adding the rule\n   */\n  public onCloudTrailEvent(id: string, options: events.OnEventOptions = {}): events.Rule {\n    const rule = new events.Rule(this, id, options);\n    rule.addTarget(options.target);\n    rule.addEventPattern({\n      source: ['aws.ecr'],\n      detailType: ['AWS API Call via CloudTrail'],\n      detail: {\n        requestParameters: {\n          repositoryName: [this.repositoryName],\n        },\n      },\n    });\n    return rule;\n  }\n\n  /**\n   * Defines an AWS CloudWatch event rule that can trigger a target when an image is pushed to this\n   * repository.\n   *\n   * Requires that there exists at least one CloudTrail Trail in your account\n   * that captures the event. This method will not create the Trail.\n   *\n   * @param id The id of the rule\n   * @param options Options for adding the rule\n   */\n  public onCloudTrailImagePushed(id: string, options: OnCloudTrailImagePushedOptions = {}): events.Rule {\n    const rule = this.onCloudTrailEvent(id, options);\n    rule.addEventPattern({\n      detail: {\n        eventName: ['PutImage'],\n        requestParameters: {\n          imageTag: options.imageTag ? [options.imageTag] : undefined,\n        },\n      },\n    });\n    return rule;\n  }\n  /**\n   * Defines an AWS CloudWatch event rule that can trigger a target when an image scan is completed\n   *\n   *\n   * @param id The id of the rule\n   * @param options Options for adding the rule\n   */\n  public onImageScanCompleted(id: string, options: OnImageScanCompletedOptions = {}): events.Rule {\n    const rule = new events.Rule(this, id, options);\n    rule.addTarget(options.target);\n    rule.addEventPattern({\n      source: ['aws.ecr'],\n      detailType: ['ECR Image Scan'],\n      detail: {\n        'repository-name': [this.repositoryName],\n        'scan-status': ['COMPLETE'],\n        'image-tags': options.imageTags ?? undefined,\n      },\n    });\n    return rule;\n  }\n\n  /**\n   * Defines a CloudWatch event rule which triggers for repository events. Use\n   * `rule.addEventPattern(pattern)` to specify a filter.\n   */\n  public onEvent(id: string, options: events.OnEventOptions = {}) {\n    const rule = new events.Rule(this, id, options);\n    rule.addEventPattern({\n      source: ['aws.ecr'],\n      resources: [this.repositoryArn],\n    });\n    rule.addTarget(options.target);\n    return rule;\n  }\n  /**\n   * Grant the given principal identity permissions to perform the actions on this repository\n   */\n  public grant(grantee: iam.IGrantable, ...actions: string[]) {\n    return iam.Grant.addToPrincipalOrResource({\n      grantee,\n      actions,\n      resourceArns: [this.repositoryArn],\n      resourceSelfArns: [],\n      resource: this,\n    });\n  }\n\n  /**\n   * Grant the given identity permissions to use the images in this repository\n   */\n  public grantPull(grantee: iam.IGrantable) {\n    const ret = this.grant(grantee, 'ecr:BatchCheckLayerAvailability', 'ecr:GetDownloadUrlForLayer', 'ecr:BatchGetImage');\n\n    iam.Grant.addToPrincipal({\n      grantee,\n      actions: ['ecr:GetAuthorizationToken'],\n      resourceArns: ['*'],\n      scope: this,\n    });\n\n    return ret;\n  }\n\n  /**\n   * Grant the given identity permissions to pull and push images to this repository.\n   */\n  public grantPullPush(grantee: iam.IGrantable) {\n    this.grantPull(grantee);\n    return this.grant(grantee,\n      'ecr:PutImage',\n      'ecr:InitiateLayerUpload',\n      'ecr:UploadLayerPart',\n      'ecr:CompleteLayerUpload');\n  }\n}\n\n/**\n * Options for the onCloudTrailImagePushed method\n */\nexport interface OnCloudTrailImagePushedOptions extends events.OnEventOptions {\n  /**\n   * Only watch changes to this image tag\n   *\n   * @default - Watch changes to all tags\n   */\n  readonly imageTag?: string;\n}\n\n/**\n * Options for the OnImageScanCompleted method\n */\nexport interface OnImageScanCompletedOptions extends events.OnEventOptions {\n  /**\n   * Only watch changes to the image tags spedified.\n   * Leave it undefined to watch the full repository.\n   *\n   * @default - Watch the changes to the repository with all image tags\n   */\n  readonly imageTags?: string[];\n}\n\nexport interface RepositoryProps {\n  /**\n   * Name for this repository\n   *\n   * @default Automatically generated name.\n   */\n  readonly repositoryName?: string;\n\n  /**\n   * The kind of server-side encryption to apply to this repository.\n   *\n   * If you choose KMS, you can specify a KMS key via `encryptionKey`. If\n   * encryptionKey is not specified, an AWS managed KMS key is used.\n   *\n   * @default - `KMS` if `encryptionKey` is specified, or `AES256` otherwise.\n   */\n  readonly encryption?: RepositoryEncryption;\n\n  /**\n   * External KMS key to use for repository encryption.\n   *\n   * The 'encryption' property must be either not specified or set to \"KMS\".\n   * An error will be emitted if encryption is set to \"AES256\".\n   *\n   * @default - If encryption is set to `KMS` and this property is undefined,\n   * an AWS managed KMS key is used.\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * Life cycle rules to apply to this registry\n   *\n   * @default No life cycle rules\n   */\n  readonly lifecycleRules?: LifecycleRule[];\n\n  /**\n   * The AWS account ID associated with the registry that contains the repository.\n   *\n   * @see https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_PutLifecyclePolicy.html\n   * @default The default registry is assumed.\n   */\n  readonly lifecycleRegistryId?: string;\n\n  /**\n   * Determine what happens to the repository when the resource/stack is deleted.\n   *\n   * @default RemovalPolicy.Retain\n   */\n  readonly removalPolicy?: RemovalPolicy;\n\n  /**\n   * Enable the scan on push when creating the repository\n   *\n   *  @default false\n   */\n  readonly imageScanOnPush?: boolean;\n\n  /**\n   * The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten.\n   *\n   *  @default TagMutability.MUTABLE\n   */\n  readonly imageTagMutability?: TagMutability;\n}\n\nexport interface RepositoryAttributes {\n  readonly repositoryName: string;\n  readonly repositoryArn: string;\n}\n\n/**\n * Define an ECR repository\n */\nexport class Repository extends RepositoryBase {\n  /**\n   * Import a repository\n   */\n  public static fromRepositoryAttributes(scope: Construct, id: string, attrs: RepositoryAttributes): IRepository {\n    class Import extends RepositoryBase {\n      public readonly repositoryName = attrs.repositoryName;\n      public readonly repositoryArn = attrs.repositoryArn;\n\n      public addToResourcePolicy(_statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n        // dropped\n        return { statementAdded: false };\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  public static fromRepositoryArn(scope: Construct, id: string, repositoryArn: string): IRepository {\n\n    // if repositoryArn is a token, the repository name is also required. this is because\n    // repository names can include \"/\" (e.g. foo/bar/myrepo) and it is impossible to\n    // parse the name from an ARN using CloudFormation's split/select.\n    if (Token.isUnresolved(repositoryArn)) {\n      throw new Error('\"repositoryArn\" is a late-bound value, and therefore \"repositoryName\" is required. Use `fromRepositoryAttributes` instead');\n    }\n\n    const repositoryName = repositoryArn.split('/').slice(1).join('/');\n\n    class Import extends RepositoryBase {\n      public repositoryName = repositoryName;\n      public repositoryArn = repositoryArn;\n\n      public addToResourcePolicy(_statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n        // dropped\n        return { statementAdded: false };\n      }\n    }\n\n    return new Import(scope, id, {\n      environmentFromArn: repositoryArn,\n    });\n  }\n\n  public static fromRepositoryName(scope: Construct, id: string, repositoryName: string): IRepository {\n    class Import extends RepositoryBase {\n      public repositoryName = repositoryName;\n      public repositoryArn = Repository.arnForLocalRepository(repositoryName, scope);\n\n      public addToResourcePolicy(_statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n        // dropped\n        return { statementAdded: false };\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * Returns an ECR ARN for a repository that resides in the same account/region\n   * as the current stack.\n   */\n  public static arnForLocalRepository(repositoryName: string, scope: IConstruct, account?: string): string {\n    return Stack.of(scope).formatArn({\n      account,\n      service: 'ecr',\n      resource: 'repository',\n      resourceName: repositoryName,\n    });\n  }\n\n\n  private static validateRepositoryName(physicalName: string) {\n    const repositoryName = physicalName;\n    if (!repositoryName || Token.isUnresolved(repositoryName)) {\n      // the name is a late-bound value, not a defined string,\n      // so skip validation\n      return;\n    }\n\n    const errors: string[] = [];\n\n    // Rules codified from https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html\n    if (repositoryName.length < 2 || repositoryName.length > 256) {\n      errors.push('Repository name must be at least 2 and no more than 256 characters');\n    }\n    const isPatternMatch = /^(?:[a-z0-9]+(?:[._-][a-z0-9]+)*\\/)*[a-z0-9]+(?:[._-][a-z0-9]+)*$/.test(repositoryName);\n    if (!isPatternMatch) {\n      errors.push('Repository name must follow the specified pattern: (?:[a-z0-9]+(?:[._-][a-z0-9]+)*/)*[a-z0-9]+(?:[._-][a-z0-9]+)*');\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Invalid ECR repository name (value: ${repositoryName})${EOL}${errors.join(EOL)}`);\n    }\n  }\n\n  public readonly repositoryName: string;\n  public readonly repositoryArn: string;\n  private readonly lifecycleRules = new Array<LifecycleRule>();\n  private readonly registryId?: string;\n  private policyDocument?: iam.PolicyDocument;\n\n  constructor(scope: Construct, id: string, props: RepositoryProps = {}) {\n    super(scope, id, {\n      physicalName: props.repositoryName,\n    });\n\n    Repository.validateRepositoryName(this.physicalName);\n\n    const resource = new CfnRepository(this, 'Resource', {\n      repositoryName: this.physicalName,\n      // It says \"Text\", but they actually mean \"Object\".\n      repositoryPolicyText: Lazy.any({ produce: () => this.policyDocument }),\n      lifecyclePolicy: Lazy.any({ produce: () => this.renderLifecyclePolicy() }),\n      imageScanningConfiguration: !props.imageScanOnPush ? undefined : {\n        scanOnPush: true,\n      },\n      imageTagMutability: props.imageTagMutability || undefined,\n      encryptionConfiguration: this.parseEncryption(props),\n    });\n\n    resource.applyRemovalPolicy(props.removalPolicy);\n\n    this.registryId = props.lifecycleRegistryId;\n    if (props.lifecycleRules) {\n      props.lifecycleRules.forEach(this.addLifecycleRule.bind(this));\n    }\n\n    this.repositoryName = this.getResourceNameAttribute(resource.ref);\n    this.repositoryArn = this.getResourceArnAttribute(resource.attrArn, {\n      service: 'ecr',\n      resource: 'repository',\n      resourceName: this.physicalName,\n    });\n\n    this.node.addValidation({ validate: () => this.policyDocument?.validateForResourcePolicy() ?? [] });\n  }\n\n  public addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n    if (this.policyDocument === undefined) {\n      this.policyDocument = new iam.PolicyDocument();\n    }\n    this.policyDocument.addStatements(statement);\n    return { statementAdded: false, policyDependable: this.policyDocument };\n  }\n\n  /**\n   * Add a life cycle rule to the repository\n   *\n   * Life cycle rules automatically expire images from the repository that match\n   * certain conditions.\n   */\n  public addLifecycleRule(rule: LifecycleRule) {\n    // Validate rule here so users get errors at the expected location\n    if (rule.tagStatus === undefined) {\n      rule = { ...rule, tagStatus: rule.tagPrefixList === undefined ? TagStatus.ANY : TagStatus.TAGGED };\n    }\n\n    if (rule.tagStatus === TagStatus.TAGGED && (rule.tagPrefixList === undefined || rule.tagPrefixList.length === 0)) {\n      throw new Error('TagStatus.Tagged requires the specification of a tagPrefixList');\n    }\n    if (rule.tagStatus !== TagStatus.TAGGED && rule.tagPrefixList !== undefined) {\n      throw new Error('tagPrefixList can only be specified when tagStatus is set to Tagged');\n    }\n    if ((rule.maxImageAge !== undefined) === (rule.maxImageCount !== undefined)) {\n      throw new Error(`Life cycle rule must contain exactly one of 'maxImageAge' and 'maxImageCount', got: ${JSON.stringify(rule)}`);\n    }\n\n    if (rule.tagStatus === TagStatus.ANY && this.lifecycleRules.filter(r => r.tagStatus === TagStatus.ANY).length > 0) {\n      throw new Error('Life cycle can only have one TagStatus.Any rule');\n    }\n\n    this.lifecycleRules.push({ ...rule });\n  }\n\n  /**\n   * Render the life cycle policy object\n   */\n  private renderLifecyclePolicy(): CfnRepository.LifecyclePolicyProperty | undefined {\n    const stack = Stack.of(this);\n    let lifecyclePolicyText: any;\n\n    if (this.lifecycleRules.length === 0 && !this.registryId) { return undefined; }\n\n    if (this.lifecycleRules.length > 0) {\n      lifecyclePolicyText = JSON.stringify(stack.resolve({\n        rules: this.orderedLifecycleRules().map(renderLifecycleRule),\n      }));\n    }\n\n    return {\n      lifecyclePolicyText,\n      registryId: this.registryId,\n    };\n  }\n\n  /**\n   * Return life cycle rules with automatic ordering applied.\n   *\n   * Also applies validation of the 'any' rule.\n   */\n  private orderedLifecycleRules(): LifecycleRule[] {\n    if (this.lifecycleRules.length === 0) { return []; }\n\n    const prioritizedRules = this.lifecycleRules.filter(r => r.rulePriority !== undefined && r.tagStatus !== TagStatus.ANY);\n    const autoPrioritizedRules = this.lifecycleRules.filter(r => r.rulePriority === undefined && r.tagStatus !== TagStatus.ANY);\n    const anyRules = this.lifecycleRules.filter(r => r.tagStatus === TagStatus.ANY);\n    if (anyRules.length > 0 && anyRules[0].rulePriority !== undefined && autoPrioritizedRules.length > 0) {\n      // Supporting this is too complex for very little value. We just prohibit it.\n      throw new Error(\"Cannot combine prioritized TagStatus.Any rule with unprioritized rules. Remove rulePriority from the 'Any' rule.\");\n    }\n\n    const prios = prioritizedRules.map(r => r.rulePriority!);\n    let autoPrio = (prios.length > 0 ? Math.max(...prios) : 0) + 1;\n\n    const ret = new Array<LifecycleRule>();\n    for (const rule of prioritizedRules.concat(autoPrioritizedRules).concat(anyRules)) {\n      ret.push({\n        ...rule,\n        rulePriority: rule.rulePriority ?? autoPrio++,\n      });\n    }\n\n    // Do validation on the final array--might still be wrong because the user supplied all prios, but incorrectly.\n    validateAnyRuleLast(ret);\n    return ret;\n  }\n\n  /**\n   * Set up key properties and return the Repository encryption property from the\n   * user's configuration.\n   */\n  private parseEncryption(props: RepositoryProps): CfnRepository.EncryptionConfigurationProperty | undefined {\n\n    // default based on whether encryptionKey is specified\n    const encryptionType = props.encryption ?? (props.encryptionKey ? RepositoryEncryption.KMS : RepositoryEncryption.AES_256);\n\n    // if encryption key is set, encryption must be set to KMS.\n    if (encryptionType !== RepositoryEncryption.KMS && props.encryptionKey) {\n      throw new Error(`encryptionKey is specified, so 'encryption' must be set to KMS (value: ${encryptionType.value})`);\n    }\n\n    if (encryptionType === RepositoryEncryption.AES_256) {\n      return undefined;\n    }\n\n    if (encryptionType === RepositoryEncryption.KMS) {\n      return {\n        encryptionType: 'KMS',\n        kmsKey: props.encryptionKey?.keyArn,\n      };\n    }\n\n    throw new Error(`Unexpected 'encryptionType': ${encryptionType}`);\n  }\n}\n\nfunction validateAnyRuleLast(rules: LifecycleRule[]) {\n  const anyRules = rules.filter(r => r.tagStatus === TagStatus.ANY);\n  if (anyRules.length === 1) {\n    const maxPrio = Math.max(...rules.map(r => r.rulePriority!));\n    if (anyRules[0].rulePriority !== maxPrio) {\n      throw new Error(`TagStatus.Any rule must have highest priority, has ${anyRules[0].rulePriority} which is smaller than ${maxPrio}`);\n    }\n  }\n}\n\n/**\n * Render the lifecycle rule to JSON\n */\nfunction renderLifecycleRule(rule: LifecycleRule) {\n  return {\n    rulePriority: rule.rulePriority,\n    description: rule.description,\n    selection: {\n      tagStatus: rule.tagStatus || TagStatus.ANY,\n      tagPrefixList: rule.tagPrefixList,\n      countType: rule.maxImageAge !== undefined ? CountType.SINCE_IMAGE_PUSHED : CountType.IMAGE_COUNT_MORE_THAN,\n      countNumber: rule.maxImageAge?.toDays() ?? rule.maxImageCount,\n      countUnit: rule.maxImageAge !== undefined ? 'days' : undefined,\n    },\n    action: {\n      type: 'expire',\n    },\n  };\n}\n\n/**\n * Select images based on counts\n */\nconst enum CountType {\n  /**\n   * Set a limit on the number of images in your repository\n   */\n  IMAGE_COUNT_MORE_THAN = 'imageCountMoreThan',\n\n  /**\n   * Set an age limit on the images in your repository\n   */\n  SINCE_IMAGE_PUSHED = 'sinceImagePushed',\n}\n\n/**\n * The tag mutability setting for your repository.\n */\nexport enum TagMutability {\n  /**\n   * allow image tags to be overwritten.\n   */\n  MUTABLE = 'MUTABLE',\n\n  /**\n   * all image tags within the repository will be immutable which will prevent them from being overwritten.\n   */\n  IMMUTABLE = 'IMMUTABLE',\n\n}\n\n/**\n * Indicates whether server-side encryption is enabled for the object, and whether that encryption is\n * from the AWS Key Management Service (AWS KMS) or from Amazon S3 managed encryption (SSE-S3).\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#SysMetadata\n */\nexport class RepositoryEncryption {\n  /**\n   * 'AES256'\n   */\n  public static readonly AES_256 = new RepositoryEncryption('AES256');\n  /**\n   * 'KMS'\n   */\n  public static readonly KMS = new RepositoryEncryption('KMS');\n\n  /**\n   * @param value the string value of the encryption\n   */\n  protected constructor(public readonly value: string) { }\n}\n"],
  "mappings": "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",
  "names": []
}
