{
  "version": 3,
  "sources": ["fact.ts"],
  "sourcesContent": ["import { AWS_REGIONS } from './aws-entities';\n\n/**\n * A database of regional information.\n */\nexport class Fact {\n  /**\n   * @returns the list of names of AWS regions for which there is at least one registered fact. This\n   *          may not be an exhaustive list of all available AWS regions.\n   */\n  public static get regions(): string[] {\n    // Return by copy to ensure no modifications can be made to the undelying constant.\n    return Array.from(AWS_REGIONS);\n  }\n\n  /**\n   * Retrieves a fact from this Fact database.\n   *\n   * @param region the name of the region (e.g: `us-east-1`)\n   * @param name   the name of the fact being looked up (see the `FactName` class for details)\n   *\n   * @returns the fact value if it is known, and `undefined` otherwise.\n   */\n  public static find(region: string, name: string): string | undefined {\n    const regionFacts = this.database[region];\n    return regionFacts && regionFacts[name];\n  }\n\n  /**\n   * Retrieve a fact from the Fact database. (retrieval will fail if the specified region or\n   * fact name does not exist.)\n   *\n   * @param region the name of the region (e.g: `us-east-1`)\n   * @param name the name of the fact being looked up (see the `FactName` class for details)\n   */\n  public static requireFact(region: string, name: string): string {\n    const foundFact = this.find(region, name);\n\n    if (!foundFact) {\n      throw new Error(`No fact ${name} could be found for region: ${region} and name: ${name}`);\n    }\n\n    return foundFact;\n  }\n\n  /**\n   * Registers a new fact in this Fact database.\n   *\n   * @param fact           the new fact to be registered.\n   * @param allowReplacing whether new facts can replace existing facts or not.\n   */\n  public static register(fact: IFact, allowReplacing = false): void {\n    const regionFacts = this.database[fact.region] || (this.database[fact.region] = {});\n    if (fact.name in regionFacts && regionFacts[fact.name] !== fact.value && !allowReplacing) {\n      throw new Error(`Region ${fact.region} already has a fact ${fact.name}, with value ${regionFacts[fact.name]}`);\n    }\n    if (fact.value !== undefined) {\n      regionFacts[fact.name] = fact.value;\n    }\n  }\n\n  /**\n   * Removes a fact from the database.\n   * @param region the region for which the fact is to be removed.\n   * @param name   the name of the fact to remove.\n   * @param value  the value that should be removed (removal will fail if the value is specified, but does not match the\n   *               current stored value).\n   */\n  public static unregister(region: string, name: string, value?: string): void {\n    const regionFacts = this.database[region] || {};\n    if (name in regionFacts && value && regionFacts[name] !== value) {\n      throw new Error(`Attempted to remove ${name} from ${region} with value ${value}, but the fact's value is ${regionFacts[name]}`);\n    }\n    delete regionFacts[name];\n  }\n\n  private static readonly database: { [region: string]: { [name: string]: string } } = {};\n\n  private constructor() {\n    throw new Error('Use the static methods of Fact instead!');\n  }\n}\n\n/**\n * A fact that can be registered about a particular region.\n */\nexport interface IFact {\n  /**\n   * The region for which this fact applies.\n   */\n  readonly region: string;\n\n  /**\n   * The name of this fact. Standardized values are provided by the `Facts` class.\n   */\n  readonly name: string;\n\n  /**\n   * The value of this fact.\n   */\n  readonly value: string | undefined;\n}\n\n/**\n * All standardized fact names.\n */\nexport class FactName {\n  /**\n   * The name of the partition for a region (e.g: 'aws', 'aws-cn', ...)\n   */\n  public static readonly PARTITION = 'partition';\n\n  /**\n   * The domain suffix for a region (e.g: 'amazonaws.com`)\n   */\n  public static readonly DOMAIN_SUFFIX = 'domainSuffix';\n\n  /**\n   * Whether the AWS::CDK::Metadata CloudFormation Resource is available in-region or not. The value is a boolean\n   * modelled as `YES` or `NO`.\n   */\n  public static readonly CDK_METADATA_RESOURCE_AVAILABLE = 'cdk:metadata-resource:available';\n\n  /**\n   * The endpoint used for hosting S3 static websites\n   */\n  public static readonly S3_STATIC_WEBSITE_ENDPOINT = 's3-static-website:endpoint';\n\n  /**\n   * The endpoint used for aliasing S3 static websites in Route 53\n   */\n  public static readonly S3_STATIC_WEBSITE_ZONE_53_HOSTED_ZONE_ID = 's3-static-website:route-53-hosted-zone-id';\n\n  /**\n   * The hosted zone ID used by Route 53 to alias a EBS environment endpoint in this region (e.g: Z2O1EMRO9K5GLX)\n   */\n  public static readonly EBS_ENV_ENDPOINT_HOSTED_ZONE_ID = 'ebs-environment:route-53-hosted-zone-id';\n\n  /**\n   * The prefix for VPC Endpoint Service names,\n   * cn.com.amazonaws.vpce for China regions,\n   * com.amazonaws.vpce otherwise.\n   */\n  public static readonly VPC_ENDPOINT_SERVICE_NAME_PREFIX = 'vpcEndpointServiceNamePrefix';\n\n  /**\n   * The account for ELBv2 in this region\n   */\n  public static readonly ELBV2_ACCOUNT = 'elbv2Account';\n\n  /**\n   * The ID of the AWS account that owns the public ECR repository that contains the\n   * AWS Deep Learning Containers images in a given region.\n   */\n  public static readonly DLC_REPOSITORY_ACCOUNT = 'dlcRepositoryAccount';\n\n  /**\n   * The ID of the AWS account that owns the public ECR repository that contains the\n   * AWS App Mesh Envoy Proxy images in a given region.\n   */\n  public static readonly APPMESH_ECR_ACCOUNT = 'appMeshRepositoryAccount';\n\n  /**\n   * The CIDR block used by Kinesis Data Firehose servers.\n   */\n  public static readonly FIREHOSE_CIDR_BLOCK = 'firehoseCidrBlock';\n\n  /**\n   * The ARN of CloudWatch Lambda Insights for a version (e.g. 1.0.98.0)\n   */\n  public static cloudwatchLambdaInsightsVersion(version: string, arch?: string) {\n    // if we are provided an architecture use that, otherwise\n    // default to x86_64 for backwards compatibility\n    const suffix = version.split('.').join('_') + `_${arch ?? 'x86_64'}`;\n    return `cloudwatch-lambda-insights-version:${suffix}`;\n  }\n\n  /**\n   * The name of the regional service principal for a given service.\n   *\n   * @param service the service name, either simple (e.g: `s3`, `codedeploy`) or qualified (e.g: `s3.amazonaws.com`).\n   *                The `.amazonaws.com` and `.amazonaws.com.cn` domains are stripped from service names, so they are\n   *                canonicalized in that respect.\n   */\n  public static servicePrincipal(service: string) {\n    return `service-principal:${service.replace(/\\.amazonaws\\.com(\\.cn)?$/, '')}`;\n  }\n}\n"],
  "mappings": "+NAAA,eAAA,QAAA,kBAKA,UAAiB,CAyEf,aAAA,CACE,KAAM,IAAI,OAAM,qDArEA,UAAO,CAEvB,MAAO,OAAM,KAAK,eAAA,mBAWN,MAAK,OAAgB,KAAY,CAC7C,KAAM,aAAc,KAAK,SAAS,QAClC,MAAO,cAAe,YAAY,YAUtB,aAAY,OAAgB,KAAY,CACpD,KAAM,WAAY,KAAK,KAAK,OAAQ,MAEpC,GAAI,CAAC,UACH,KAAM,IAAI,OAAM,WAAW,mCAAmC,oBAAoB,QAGpF,MAAO,iBASK,UAAS,KAAa,eAAiB,GAAK,6DACxD,KAAM,aAAc,KAAK,SAAS,KAAK,SAAY,MAAK,SAAS,KAAK,QAAU,IAChF,GAAI,KAAK,OAAQ,cAAe,YAAY,KAAK,QAAU,KAAK,OAAS,CAAC,eACxE,KAAM,IAAI,OAAM,UAAU,KAAK,6BAA6B,KAAK,oBAAoB,YAAY,KAAK,SAExG,AAAI,KAAK,QAAU,QACjB,aAAY,KAAK,MAAQ,KAAK,aAWpB,YAAW,OAAgB,KAAc,MAAc,CACnE,KAAM,aAAc,KAAK,SAAS,SAAW,GAC7C,GAAI,OAAQ,cAAe,OAAS,YAAY,QAAU,MACxD,KAAM,IAAI,OAAM,uBAAuB,aAAa,qBAAqB,kCAAkC,YAAY,SAEzH,MAAO,aAAY,OApEvB,QAAA,KAAA,0FAuE0B,KAAA,SAA6D,GA8BvF,cAAqB,OAgEL,iCAAgC,QAAiB,KAAa,CAI1E,MAAO,sCADQ,QAAQ,MAAM,KAAK,KAAK,KAAO,IAAI,MAAI,KAAJ,KAAQ,mBAW9C,kBAAiB,QAAe,CAC5C,MAAO,qBAAqB,QAAQ,QAAQ,2BAA4B,OA/E5E,QAAA,SAAA,sGAIyB,SAAA,UAAY,YAKZ,SAAA,cAAgB,eAMhB,SAAA,gCAAkC,kCAKlC,SAAA,2BAA6B,6BAK7B,SAAA,yCAA2C,4CAK3C,SAAA,gCAAkC,0CAOlC,SAAA,iCAAmC,+BAKnC,SAAA,cAAgB,eAMhB,SAAA,uBAAyB,uBAMzB,SAAA,oBAAsB,2BAKtB,SAAA,oBAAsB",
  "names": []
}
