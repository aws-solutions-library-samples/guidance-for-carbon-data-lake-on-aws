{
  "version": 3,
  "sources": ["service.ts"],
  "sourcesContent": ["import * as elbv2 from '../../aws-elasticloadbalancingv2';\nimport { Duration, IResource, Resource } from '../../core';\nimport { Construct } from 'constructs';\nimport { AliasTargetInstance } from './alias-target-instance';\nimport { CnameInstance, CnameInstanceBaseProps } from './cname-instance';\nimport { IInstance } from './instance';\nimport { IpInstance, IpInstanceBaseProps } from './ip-instance';\nimport { INamespace, NamespaceType } from './namespace';\nimport { NonIpInstance, NonIpInstanceBaseProps } from './non-ip-instance';\nimport { CfnService } from './servicediscovery.generated';\n\nexport interface IService extends IResource {\n  /**\n   * A name for the Cloudmap Service.\n   * @attribute\n   */\n  readonly serviceName: string;\n\n  /**\n   *  The namespace for the Cloudmap Service.\n   */\n  readonly namespace: INamespace;\n\n  /**\n   * The ID of the namespace that you want to use for DNS configuration.\n   * @attribute\n   */\n  readonly serviceId: string;\n\n  /**\n   * The Arn of the namespace that you want to use for DNS configuration.\n   * @attribute\n   */\n  readonly serviceArn: string;\n\n  /**\n   * The DnsRecordType used by the service\n   */\n  readonly dnsRecordType: DnsRecordType;\n\n  /**\n   * The Routing Policy used by the service\n   */\n  readonly routingPolicy: RoutingPolicy;\n}\n\n/**\n * Basic props needed to create a service in a given namespace. Used by HttpNamespace.createService\n */\nexport interface BaseServiceProps {\n  /**\n   * A name for the Service.\n   *\n   * @default CloudFormation-generated name\n   */\n  readonly name?: string;\n\n  /**\n   * A description of the service.\n   *\n   * @default none\n   */\n  readonly description?: string;\n\n  /**\n   * Settings for an optional health check.  If you specify health check settings, AWS Cloud Map associates the health\n   * check with the records that you specify in DnsConfig. Only one of healthCheckConfig or healthCheckCustomConfig can\n   * be specified. Not valid for PrivateDnsNamespaces. If you use healthCheck, you can only register IP instances to\n   * this service.\n   *\n   * @default none\n   */\n  readonly healthCheck?: HealthCheckConfig;\n\n  /**\n   * Structure containing failure threshold for a custom health checker.\n   * Only one of healthCheckConfig or healthCheckCustomConfig can be specified.\n   * See: https://docs.aws.amazon.com/cloud-map/latest/api/API_HealthCheckCustomConfig.html\n   *\n   * @default none\n   */\n  readonly customHealthCheck?: HealthCheckCustomConfig;\n}\n\n/**\n * Service props needed to create a service in a given namespace. Used by createService() for PrivateDnsNamespace and\n * PublicDnsNamespace\n */\nexport interface DnsServiceProps extends BaseServiceProps {\n  /**\n   * The DNS type of the record that you want AWS Cloud Map to create. Supported record types\n   * include A, AAAA, A and AAAA (A_AAAA), CNAME, and SRV.\n   *\n   * @default A\n   */\n  readonly dnsRecordType?: DnsRecordType;\n\n  /**\n   * The amount of time, in seconds, that you want DNS resolvers to cache the settings for this\n   * record.\n   *\n   * @default Duration.minutes(1)\n   */\n  readonly dnsTtl?: Duration;\n\n  /**\n   * The routing policy that you want to apply to all DNS records that AWS Cloud Map creates when you\n   * register an instance and specify this service.\n   *\n   * @default WEIGHTED for CNAME records and when loadBalancer is true, MULTIVALUE otherwise\n   */\n  readonly routingPolicy?: RoutingPolicy;\n\n  /**\n   * Whether or not this service will have an Elastic LoadBalancer registered to it as an AliasTargetInstance.\n   *\n   * Setting this to `true` correctly configures the `routingPolicy`\n   * and performs some additional validation.\n   *\n   * @default false\n   */\n  readonly loadBalancer?: boolean;\n}\n\nexport interface ServiceProps extends DnsServiceProps {\n  /**\n   * The namespace that you want to use for DNS configuration.\n   */\n  readonly namespace: INamespace;\n}\n\nabstract class ServiceBase extends Resource implements IService {\n  public abstract namespace: INamespace;\n  public abstract serviceId: string;\n  public abstract serviceArn: string;\n  public abstract dnsRecordType: DnsRecordType;\n  public abstract routingPolicy: RoutingPolicy;\n  public abstract readonly serviceName: string;\n}\n\nexport interface ServiceAttributes {\n  readonly namespace: INamespace;\n  readonly serviceName: string;\n  readonly serviceId: string;\n  readonly serviceArn: string;\n  readonly dnsRecordType: DnsRecordType;\n  readonly routingPolicy: RoutingPolicy;\n}\n\n/**\n * Define a CloudMap Service\n */\nexport class Service extends ServiceBase {\n\n  public static fromServiceAttributes(scope: Construct, id: string, attrs: ServiceAttributes): IService {\n    class Import extends ServiceBase {\n      public namespace: INamespace = attrs.namespace;\n      public serviceId = attrs.serviceId;\n      public serviceArn = attrs.serviceArn;\n      public dnsRecordType = attrs.dnsRecordType;\n      public routingPolicy = attrs.routingPolicy;\n      public serviceName = attrs.serviceName;\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * A name for the Cloudmap Service.\n   */\n  public readonly serviceName: string;\n\n  /**\n   *  The namespace for the Cloudmap Service.\n   */\n  public readonly namespace: INamespace;\n\n  /**\n   * The ID of the namespace that you want to use for DNS configuration.\n   */\n  public readonly serviceId: string;\n\n  /**\n   * The Arn of the namespace that you want to use for DNS configuration.\n   */\n  public readonly serviceArn: string;\n\n  /**\n   * The DnsRecordType used by the service\n   */\n  public readonly dnsRecordType: DnsRecordType;\n\n  /**\n   * The Routing Policy used by the service\n   */\n  public readonly routingPolicy: RoutingPolicy;\n\n  constructor(scope: Construct, id: string, props: ServiceProps) {\n    super(scope, id);\n\n    const namespaceType = props.namespace.type;\n\n    // Validations\n    if (namespaceType === NamespaceType.HTTP && (props.routingPolicy || props.dnsRecordType)) {\n      throw new Error('Cannot specify `routingPolicy` or `dnsRecord` when using an HTTP namespace.');\n    }\n\n    if (props.healthCheck && props.customHealthCheck) {\n      throw new Error('Cannot specify both `healthCheckConfig` and `healthCheckCustomConfig`.');\n    }\n\n    if (namespaceType === NamespaceType.DNS_PRIVATE && props.healthCheck) {\n      throw new Error('Cannot specify `healthCheckConfig` for a Private DNS namespace.');\n    }\n\n    if (props.routingPolicy === RoutingPolicy.MULTIVALUE\n        && props.dnsRecordType === DnsRecordType.CNAME) {\n      throw new Error('Cannot use `CNAME` record when routing policy is `Multivalue`.');\n    }\n\n    // Additional validation for eventual attachment of LBs\n    // The same validation happens later on during the actual attachment\n    // of LBs, but we need the property for the correct configuration of\n    // routingPolicy anyway, so might as well do the validation as well.\n    if (props.routingPolicy === RoutingPolicy.MULTIVALUE\n        && props.loadBalancer) {\n      throw new Error('Cannot register loadbalancers when routing policy is `Multivalue`.');\n    }\n\n    if (props.healthCheck\n        && props.healthCheck.type === HealthCheckType.TCP\n        && props.healthCheck.resourcePath) {\n      throw new Error('Cannot specify `resourcePath` when using a `TCP` health check.');\n    }\n\n    // Set defaults where necessary\n    const routingPolicy = (props.dnsRecordType === DnsRecordType.CNAME) || props.loadBalancer\n      ? RoutingPolicy.WEIGHTED\n      : RoutingPolicy.MULTIVALUE;\n\n    const dnsRecordType = props.dnsRecordType || DnsRecordType.A;\n\n    if (props.loadBalancer\n      && (!(dnsRecordType === DnsRecordType.A\n        || dnsRecordType === DnsRecordType.AAAA\n        || dnsRecordType === DnsRecordType.A_AAAA))) {\n      throw new Error('Must support `A` or `AAAA` records to register loadbalancers.');\n    }\n\n    const dnsConfig: CfnService.DnsConfigProperty | undefined = props.namespace.type === NamespaceType.HTTP\n      ? undefined\n      : {\n        dnsRecords: renderDnsRecords(dnsRecordType, props.dnsTtl),\n        namespaceId: props.namespace.namespaceId,\n        routingPolicy,\n      };\n\n    const healthCheckConfigDefaults = {\n      type: HealthCheckType.HTTP,\n      failureThreshold: 1,\n      resourcePath: props.healthCheck && props.healthCheck.type !== HealthCheckType.TCP\n        ? '/'\n        : undefined,\n    };\n\n    const healthCheckConfig = props.healthCheck && { ...healthCheckConfigDefaults, ...props.healthCheck };\n    const healthCheckCustomConfig = props.customHealthCheck;\n\n    // Create service\n    const service = new CfnService(this, 'Resource', {\n      name: props.name,\n      description: props.description,\n      dnsConfig,\n      healthCheckConfig,\n      healthCheckCustomConfig,\n      namespaceId: props.namespace.namespaceId,\n    });\n\n    this.serviceName = service.attrName;\n    this.serviceArn = service.attrArn;\n    this.serviceId = service.attrId;\n    this.namespace = props.namespace;\n    this.dnsRecordType = dnsRecordType;\n    this.routingPolicy = routingPolicy;\n  }\n\n  /**\n   * Registers an ELB as a new instance with unique name instanceId in this service.\n   */\n  public registerLoadBalancer(id: string, loadBalancer: elbv2.ILoadBalancerV2, customAttributes?: {[key: string]: string}): IInstance {\n    return new AliasTargetInstance(this, id, {\n      service: this,\n      dnsName: loadBalancer.loadBalancerDnsName,\n      customAttributes,\n    });\n  }\n\n  /**\n   * Registers a resource that is accessible using values other than an IP address or a domain name (CNAME).\n   */\n  public registerNonIpInstance(id: string, props: NonIpInstanceBaseProps): IInstance {\n    return new NonIpInstance(this, id, {\n      service: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Registers a resource that is accessible using an IP address.\n   */\n  public registerIpInstance(id: string, props: IpInstanceBaseProps): IInstance {\n    return new IpInstance(this, id, {\n      service: this,\n      ...props,\n    });\n  }\n\n  /**\n   * Registers a resource that is accessible using a CNAME.\n   */\n  public registerCnameInstance(id: string, props: CnameInstanceBaseProps): IInstance {\n    return new CnameInstance(this, id, {\n      service: this,\n      ...props,\n    });\n  }\n}\n\nfunction renderDnsRecords(dnsRecordType: DnsRecordType, dnsTtl: Duration = Duration.minutes(1)): CfnService.DnsRecordProperty[] {\n  const ttl = dnsTtl.toSeconds();\n\n  if (dnsRecordType === DnsRecordType.A_AAAA) {\n    return [{\n      type: DnsRecordType.A,\n      ttl,\n    }, {\n      type: DnsRecordType.AAAA,\n      ttl,\n    }];\n  } else {\n    return [{ type: dnsRecordType, ttl }];\n  }\n}\n\n/**\n * Settings for an optional Amazon Route 53 health check. If you specify settings for a health check, AWS Cloud Map\n * associates the health check with all the records that you specify in DnsConfig. Only valid with a PublicDnsNamespace.\n */\nexport interface HealthCheckConfig {\n  /**\n   * The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is\n   * healthy. Cannot be modified once created. Supported values are HTTP, HTTPS, and TCP.\n   *\n   * @default HTTP\n   */\n  readonly type?: HealthCheckType;\n\n  /**\n   * The path that you want Route 53 to request when performing health checks. Do not use when health check type is TCP.\n   *\n   * @default '/'\n   */\n  readonly resourcePath?: string;\n\n  /**\n   * The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current\n   * status of the endpoint from unhealthy to healthy or vice versa.\n   *\n   * @default 1\n   */\n  readonly failureThreshold?: number;\n}\n\n/**\n * Specifies information about an optional custom health check.\n */\nexport interface HealthCheckCustomConfig {\n  /**\n   * The number of 30-second intervals that you want Cloud Map to wait after receiving an\n   * UpdateInstanceCustomHealthStatus request before it changes the health status of a service instance.\n   *\n   * @default 1\n   */\n  readonly failureThreshold?: number;\n}\n\nexport enum DnsRecordType {\n  /**\n   * An A record\n   */\n  A = 'A',\n\n  /**\n   * An AAAA record\n   */\n  AAAA = 'AAAA',\n\n  /**\n   * Both an A and AAAA record\n   */\n  A_AAAA = 'A, AAAA',\n\n  /**\n   * A Srv record\n   */\n  SRV = 'SRV',\n\n  /**\n   * A CNAME record\n   */\n  CNAME = 'CNAME',\n}\n\nexport enum RoutingPolicy {\n  /**\n   * Route 53 returns the applicable value from one randomly selected instance from among the instances that you\n   * registered using the same service.\n   */\n  WEIGHTED = 'WEIGHTED',\n\n  /**\n   * If you define a health check for the service and the health check is healthy, Route 53 returns the applicable value\n   * for up to eight instances.\n   */\n  MULTIVALUE = 'MULTIVALUE',\n}\n\nexport enum HealthCheckType {\n  /**\n   * Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP\n   * status code of 200 or greater and less than 400.\n   */\n  HTTP = 'HTTP',\n\n  /**\n   * Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an\n   * HTTP status code of 200 or greater and less than 400.  If you specify HTTPS for the value of Type, the endpoint\n   * must support TLS v1.0 or later.\n   */\n  HTTPS = 'HTTPS',\n\n  /**\n   * Route 53 tries to establish a TCP connection.\n   * If you specify TCP for Type, don't specify a value for ResourcePath.\n   */\n  TCP = 'TCP',\n}\n"],
  "mappings": "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",
  "names": []
}
