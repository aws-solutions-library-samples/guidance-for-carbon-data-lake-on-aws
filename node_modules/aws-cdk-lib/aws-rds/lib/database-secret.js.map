{
  "version": 3,
  "sources": ["database-secret.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport * as kms from '../../aws-kms';\nimport * as secretsmanager from '../../aws-secretsmanager';\nimport { Aws, Names } from '../../core';\nimport { Construct } from 'constructs';\nimport { DEFAULT_PASSWORD_EXCLUDE_CHARS } from './private/util';\n\n/**\n * Construction properties for a DatabaseSecret.\n */\nexport interface DatabaseSecretProps {\n  /**\n   * The username.\n   */\n  readonly username: string;\n\n  /**\n   * A name for the secret.\n   *\n   * @default - A name is generated by CloudFormation.\n   */\n  readonly secretName?: string;\n\n  /**\n   * The KMS key to use to encrypt the secret.\n   *\n   * @default default master key\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * The master secret which will be used to rotate this secret.\n   *\n   * @default - no master secret information will be included\n   */\n  readonly masterSecret?: secretsmanager.ISecret;\n\n  /**\n   * Characters to not include in the generated password.\n   *\n   * @default \" %+~`#$&*()|[]{}:;<>?!'/@\\\"\\\\\"\n   */\n  readonly excludeCharacters?: string;\n\n  /**\n   * Whether to replace this secret when the criteria for the password change.\n   *\n   * This is achieved by overriding the logical id of the AWS::SecretsManager::Secret\n   * with a hash of the options that influence the password generation. This\n   * way a new secret will be created when the password is regenerated and the\n   * cluster or instance consuming this secret will have its credentials updated.\n   *\n   * @default false\n   */\n  readonly replaceOnPasswordCriteriaChanges?: boolean;\n\n  /**\n   * A list of regions where to replicate this secret.\n   *\n   * @default - Secret is not replicated\n   */\n  readonly replicaRegions?: secretsmanager.ReplicaRegion[];\n}\n\n/**\n * A database secret.\n *\n * @resource AWS::SecretsManager::Secret\n */\nexport class DatabaseSecret extends secretsmanager.Secret {\n  constructor(scope: Construct, id: string, props: DatabaseSecretProps) {\n    const excludeCharacters = props.excludeCharacters ?? DEFAULT_PASSWORD_EXCLUDE_CHARS;\n\n    super(scope, id, {\n      encryptionKey: props.encryptionKey,\n      description: `Generated by the CDK for stack: ${Aws.STACK_NAME}`,\n      secretName: props.secretName,\n      generateSecretString: {\n        passwordLength: 30, // Oracle password cannot have more than 30 characters\n        secretStringTemplate: JSON.stringify({\n          username: props.username,\n          masterarn: props.masterSecret?.secretArn,\n        }),\n        generateStringKey: 'password',\n        excludeCharacters,\n      },\n      replicaRegions: props.replicaRegions,\n    });\n\n    if (props.replaceOnPasswordCriteriaChanges) {\n      const hash = crypto.createHash('md5');\n      hash.update(JSON.stringify({\n        // Use here the options that influence the password generation.\n        // If at some point we add other password customization options\n        // they sould be added here below (e.g. `passwordLength`).\n        excludeCharacters,\n      }));\n      const logicalId = `${Names.uniqueId(this)}${hash.digest('hex')}`;\n\n      const secret = this.node.defaultChild as secretsmanager.CfnSecret;\n      secret.overrideLogicalId(logicalId.slice(-255)); // Take last 255 chars\n    }\n  }\n}\n"],
  "mappings": "qNAAA,OAAA,QAAA,UAEA,eAAA,QAAA,4BACA,OAAA,QAAA,cAEA,OAAA,QAAA,kBAgEA,4BAAoC,gBAAe,MAAM,CACvD,YAAY,MAAkB,GAAY,MAA0B,kFAClE,KAAM,mBAAiB,IAAG,MAAM,qBAAiB,MAAA,KAAA,OAAA,GAAI,OAAA,+BAErD,MAAM,MAAO,GAAI,CACf,cAAe,MAAM,cACrB,YAAa,mCAAmC,OAAA,IAAI,aACpD,WAAY,MAAM,WAClB,qBAAsB,CACpB,eAAgB,GAChB,qBAAsB,KAAK,UAAU,CACnC,SAAU,MAAM,SAChB,UAAS,IAAE,MAAM,gBAAY,MAAA,KAAA,OAAA,OAAA,GAAE,YAEjC,kBAAmB,WACnB,mBAEF,eAAgB,MAAM,iBAGxB,GAAI,MAAM,iCAAkC,CAC1C,KAAM,MAAO,OAAO,WAAW,OAC/B,KAAK,OAAO,KAAK,UAAU,CAIzB,qBAEF,KAAM,WAAY,GAAG,OAAA,MAAM,SAAS,QAAQ,KAAK,OAAO,SAGxD,AADe,KAAK,KAAK,aAClB,kBAAkB,UAAU,MAAM,SA/B/C,QAAA,eAAA",
  "names": []
}
