{
  "version": 3,
  "sources": ["pattern.ts"],
  "sourcesContent": ["// Implementation of metric patterns\n\n/**\n * Interface for objects that can render themselves to log patterns.\n */\nexport interface IFilterPattern {\n  readonly logPatternString: string;\n}\n\n/**\n * Base class for patterns that only match JSON log events.\n */\nexport abstract class JsonPattern implements IFilterPattern {\n  // This is a separate class so we have some type safety where users can't\n  // combine text patterns and JSON patterns with an 'and' operation.\n  constructor(public readonly jsonPatternString: string) { }\n\n  public get logPatternString(): string {\n    return '{ ' + this.jsonPatternString + ' }';\n  }\n}\n\n/**\n * A collection of static methods to generate appropriate ILogPatterns\n */\nexport class FilterPattern {\n\n  /**\n   * Use the given string as log pattern.\n   *\n   * See https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html\n   * for information on writing log patterns.\n   *\n   * @param logPatternString The pattern string to use.\n   */\n  public static literal(logPatternString: string): IFilterPattern {\n    return new LiteralLogPattern(logPatternString);\n  }\n\n  /**\n   * A log pattern that matches all events.\n   */\n  public static allEvents(): IFilterPattern {\n    return new LiteralLogPattern('');\n  }\n\n  /**\n   * A log pattern that matches if all the strings given appear in the event.\n   *\n   * @param terms The words to search for. All terms must match.\n   */\n  public static allTerms(...terms: string[]): IFilterPattern {\n    return new TextLogPattern([terms]);\n  }\n\n  /**\n   * A log pattern that matches if any of the strings given appear in the event.\n   *\n   * @param terms The words to search for. Any terms must match.\n   */\n  public static anyTerm(...terms: string[]): IFilterPattern {\n    return new TextLogPattern(terms.map(t => [t]));\n  }\n\n  /**\n   * A log pattern that matches if any of the given term groups matches the event.\n   *\n   * A term group matches an event if all the terms in it appear in the event string.\n   *\n   * @param termGroups A list of term groups to search for. Any one of the clauses must match.\n   */\n  public static anyTermGroup(...termGroups: string[][]): IFilterPattern {\n    return new TextLogPattern(termGroups);\n  }\n\n  /**\n   * A JSON log pattern that compares string values.\n   *\n   * This pattern only matches if the event is a JSON event, and the indicated field inside\n   * compares with the string value.\n   *\n   * Use '$' to indicate the root of the JSON structure. The comparison operator can only\n   * compare equality or inequality. The '*' wildcard may appear in the value may at the\n   * start or at the end.\n   *\n   * For more information, see:\n   *\n   * https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html\n   *\n   * @param jsonField Field inside JSON. Example: \"$.myField\"\n   * @param comparison Comparison to carry out. Either = or !=.\n   * @param value The string value to compare to. May use '*' as wildcard at start or end of string.\n   */\n  public static stringValue(jsonField: string, comparison: string, value: string): JsonPattern {\n    return new JSONStringPattern(jsonField, comparison, value);\n  }\n\n  /**\n   * A JSON log pattern that compares numerical values.\n   *\n   * This pattern only matches if the event is a JSON event, and the indicated field inside\n   * compares with the value in the indicated way.\n   *\n   * Use '$' to indicate the root of the JSON structure. The comparison operator can only\n   * compare equality or inequality. The '*' wildcard may appear in the value may at the\n   * start or at the end.\n   *\n   * For more information, see:\n   *\n   * https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html\n   *\n   * @param jsonField Field inside JSON. Example: \"$.myField\"\n   * @param comparison Comparison to carry out. One of =, !=, <, <=, >, >=.\n   * @param value The numerical value to compare to\n   */\n  public static numberValue(jsonField: string, comparison: string, value: number): JsonPattern {\n    return new JSONNumberPattern(jsonField, comparison, value);\n  }\n\n  /**\n   * A JSON log pattern that matches if the field exists and has the special value 'null'.\n   *\n   * @param jsonField Field inside JSON. Example: \"$.myField\"\n   */\n  public static isNull(jsonField: string): JsonPattern {\n    return new JSONPostfixPattern(jsonField, 'IS NULL');\n  }\n\n  /**\n   * A JSON log pattern that matches if the field does not exist.\n   *\n   * @param jsonField Field inside JSON. Example: \"$.myField\"\n   */\n  public static notExists(jsonField: string): JsonPattern {\n    return new JSONPostfixPattern(jsonField, 'NOT EXISTS');\n  }\n\n  /**\n   * A JSON log patter that matches if the field exists.\n   *\n   * This is a readable convenience wrapper over 'field = *'\n   *\n   * @param jsonField Field inside JSON. Example: \"$.myField\"\n   */\n  public static exists(jsonField: string): JsonPattern {\n    return new JSONStringPattern(jsonField, '=', '*');\n  }\n\n  /**\n   * A JSON log pattern that matches if the field exists and equals the boolean value.\n   *\n   * @param jsonField Field inside JSON. Example: \"$.myField\"\n   * @param value The value to match\n   */\n  public static booleanValue(jsonField: string, value: boolean): JsonPattern {\n    return new JSONPostfixPattern(jsonField, value ? 'IS TRUE' : 'IS FALSE');\n  }\n\n  /**\n   * A JSON log pattern that matches if all given JSON log patterns match\n   */\n  public static all(...patterns: JsonPattern[]): JsonPattern {\n    if (patterns.length === 0) { throw new Error('Must supply at least one pattern, or use allEvents() to match all events.'); }\n    if (patterns.length === 1) { return patterns[0]; }\n    return new JSONAggregatePattern('&&', patterns);\n  }\n\n  /**\n   * A JSON log pattern that matches if any of the given JSON log patterns match\n   */\n  public static any(...patterns: JsonPattern[]): JsonPattern {\n    if (patterns.length === 0) { throw new Error('Must supply at least one pattern'); }\n    if (patterns.length === 1) { return patterns[0]; }\n    return new JSONAggregatePattern('||', patterns);\n  }\n\n  /**\n   * A space delimited log pattern matcher.\n   *\n   * The log event is divided into space-delimited columns (optionally\n   * enclosed by \"\" or [] to capture spaces into column values), and names\n   * are given to each column.\n   *\n   * '...' may be specified once to match any number of columns.\n   *\n   * Afterwards, conditions may be added to individual columns.\n   *\n   * @param columns The columns in the space-delimited log stream.\n   */\n  public static spaceDelimited(...columns: string[]): SpaceDelimitedTextPattern {\n    return SpaceDelimitedTextPattern.construct(columns);\n  }\n}\n\n/**\n * Use a string literal as a log pattern\n */\nclass LiteralLogPattern implements IFilterPattern {\n  constructor(public readonly logPatternString: string) {\n  }\n}\n\n/**\n * Search for a set of set of terms\n */\nclass TextLogPattern implements IFilterPattern {\n  public readonly logPatternString: string;\n\n  constructor(clauses: string[][]) {\n    const quotedClauses = clauses.map(terms => terms.map(quoteTerm).join(' '));\n    if (quotedClauses.length === 1) {\n      this.logPatternString = quotedClauses[0];\n    } else {\n      this.logPatternString = quotedClauses.map(alt => '?' + alt).join(' ');\n    }\n  }\n}\n\n/**\n * A string comparison for JSON values\n */\nclass JSONStringPattern extends JsonPattern {\n  public constructor(jsonField: string, comparison: string, value: string) {\n    comparison = validateStringOperator(comparison);\n    super(`${jsonField} ${comparison} ${quoteTerm(value)}`);\n  }\n}\n\n/**\n * A number comparison for JSON values\n */\nclass JSONNumberPattern extends JsonPattern {\n  public constructor(jsonField: string, comparison: string, value: number) {\n    comparison = validateNumericalOperator(comparison);\n    super(`${jsonField} ${comparison} ${value}`);\n  }\n}\n\n/**\n * A postfix operator for JSON patterns\n */\nclass JSONPostfixPattern extends JsonPattern {\n  public constructor(jsonField: string, postfix: string) {\n    // No validation, we assume these are generated by trusted factory functions\n    super(`${jsonField} ${postfix}`);\n  }\n}\n\n/**\n * Combines multiple other JSON patterns with an operator\n */\nclass JSONAggregatePattern extends JsonPattern {\n  public constructor(operator: string, patterns: JsonPattern[]) {\n    if (operator !== '&&' && operator !== '||') {\n      throw new Error('Operator must be one of && or ||');\n    }\n\n    const clauses = patterns.map(p => '(' + p.jsonPatternString + ')');\n\n    super(clauses.join(` ${operator} `));\n  }\n}\n\nexport type RestrictionMap = {[column: string]: ColumnRestriction[]};\n\nconst COL_ELLIPSIS = '...';\n\n/**\n * Space delimited text pattern\n */\nexport class SpaceDelimitedTextPattern implements IFilterPattern {\n  /**\n   * Construct a new instance of a space delimited text pattern\n   *\n   * Since this class must be public, we can't rely on the user only creating it through\n   * the `LogPattern.spaceDelimited()` factory function. We must therefore validate the\n   * argument in the constructor. Since we're returning a copy on every mutation, and we\n   * don't want to re-validate the same things on every construction, we provide a limited\n   * set of mutator functions and only validate the new data every time.\n   */\n  public static construct(columns: string[]) {\n    // Validation happens here because a user could instantiate this object directly without\n    // going through the factory\n    for (const column of columns) {\n      if (!validColumnName(column)) {\n        throw new Error(`Invalid column name: ${column}`);\n      }\n    }\n\n    if (sum(columns.map(c => c === COL_ELLIPSIS ? 1 : 0)) > 1) {\n      throw new Error(\"Can use at most one '...' column\");\n    }\n\n    return new SpaceDelimitedTextPattern(columns, {});\n  }\n\n  // TODO: Temporarily changed from private to protected to unblock build. We need to think\n  //     about how to handle jsii types with private constructors.\n  protected constructor(private readonly columns: string[], private readonly restrictions: RestrictionMap) {\n    // Private constructor so we validate in the .construct() factory function\n  }\n\n  /**\n   * Restrict where the pattern applies\n   */\n  public whereString(columnName: string, comparison: string, value: string): SpaceDelimitedTextPattern {\n    if (columnName === COL_ELLIPSIS) {\n      throw new Error(\"Can't use '...' in a restriction\");\n    }\n    if (this.columns.indexOf(columnName) === -1) {\n      throw new Error(`Column in restrictions that is not in columns: ${columnName}`);\n    }\n\n    comparison = validateStringOperator(comparison);\n\n    return new SpaceDelimitedTextPattern(this.columns, this.addRestriction(columnName, {\n      comparison,\n      stringValue: value,\n    }));\n  }\n\n  /**\n   * Restrict where the pattern applies\n   */\n  public whereNumber(columnName: string, comparison: string, value: number): SpaceDelimitedTextPattern {\n    if (columnName === COL_ELLIPSIS) {\n      throw new Error(\"Can't use '...' in a restriction\");\n    }\n    if (this.columns.indexOf(columnName) === -1) {\n      throw new Error(`Column in restrictions that is not in columns: ${columnName}`);\n    }\n\n    comparison = validateNumericalOperator(comparison);\n\n    return new SpaceDelimitedTextPattern(this.columns, this.addRestriction(columnName, {\n      comparison,\n      numberValue: value,\n    }));\n  }\n\n  public get logPatternString(): string {\n    return '[' + this.columns.map(this.columnExpression.bind(this)).join(', ') + ']';\n  }\n\n  /**\n   * Return the column expression for the given column\n   */\n  private columnExpression(column: string) {\n    const restrictions = this.restrictions[column];\n    if (!restrictions) { return column; }\n\n    return restrictions.map(r => renderRestriction(column, r)).join(' && ');\n  }\n\n  /**\n   * Make a copy of the current restrictions and add one\n   */\n  private addRestriction(columnName: string, restriction: ColumnRestriction) {\n    const ret: RestrictionMap = {};\n    for (const key of Object.keys(this.restrictions)) {\n      ret[key] = this.restrictions[key].slice();\n    }\n    if (!(columnName in ret)) { ret[columnName] = []; }\n    ret[columnName].push(restriction);\n    return ret;\n  }\n}\n\nexport interface ColumnRestriction {\n  /**\n   * Comparison operator to use\n   */\n  readonly comparison: string;\n\n  /**\n   * String value to compare to\n   *\n   * Exactly one of 'stringValue' and 'numberValue' must be set.\n   */\n  readonly stringValue?: string;\n\n  /**\n   * Number value to compare to\n   *\n   * Exactly one of 'stringValue' and 'numberValue' must be set.\n   */\n  readonly numberValue?: number;\n}\n\n/**\n * Quote a term for use in a pattern expression\n *\n * It's never wrong to quote a string term, and required if the term\n * contains non-alphanumerical characters, so we just always do it.\n *\n * Inner double quotes are escaped using a backslash.\n */\nfunction quoteTerm(term: string): string {\n  return '\"' + term.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') + '\"';\n}\n\n/**\n * Return whether the given column name is valid in a space-delimited table\n */\nfunction validColumnName(column: string) {\n  return column === COL_ELLIPSIS || /^[a-zA-Z0-9_-]+$/.exec(column);\n}\n\n/**\n * Validate and normalize the string comparison operator\n *\n * Correct for a common typo/confusion, treat '==' as '='\n */\nfunction validateStringOperator(operator: string) {\n  if (operator === '==') { operator = '='; }\n\n  if (operator !== '=' && operator !== '!=') {\n    throw new Error(`Invalid comparison operator ('${operator}'), must be either '=' or '!='`);\n  }\n\n  return operator;\n}\n\nconst VALID_OPERATORS = ['=', '!=', '<', '<=', '>', '>='];\n\n/**\n * Validate and normalize numerical comparison operators\n *\n * Correct for a common typo/confusion, treat '==' as '='\n */\nfunction validateNumericalOperator(operator: string) {\n  // Correct for a common typo, treat '==' as '='\n  if (operator === '==') { operator = '='; }\n\n  if (VALID_OPERATORS.indexOf(operator) === -1) {\n    throw new Error(`Invalid comparison operator ('${operator}'), must be one of ${VALID_OPERATORS.join(', ')}`);\n  }\n\n  return operator;\n}\n\n/**\n * Render a table restriction\n */\nfunction renderRestriction(column: string, restriction: ColumnRestriction) {\n  if (restriction.numberValue !== undefined) {\n    return `${column} ${restriction.comparison} ${restriction.numberValue}`;\n  } else if (restriction.stringValue) {\n    return `${column} ${restriction.comparison} ${quoteTerm(restriction.stringValue)}`;\n  } else {\n    throw new Error('Invalid restriction');\n  }\n}\n\nfunction sum(xs: number[]): number {\n  return xs.reduce((a, c) => a + c, 0);\n}\n"],
  "mappings": "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",
  "names": []
}
