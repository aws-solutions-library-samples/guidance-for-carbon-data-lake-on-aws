{
  "version": 3,
  "sources": ["log-retention.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport * as iam from '../../aws-iam';\nimport * as s3_assets from '../../aws-s3-assets';\nimport * as cdk from '../../core';\nimport { Construct } from 'constructs';\nimport { RetentionDays } from './log-group';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { ArnFormat } from '../../core';\n\n/**\n * Construction properties for a LogRetention.\n */\nexport interface LogRetentionProps {\n  /**\n   * The log group name.\n   */\n  readonly logGroupName: string;\n\n  /**\n   * The region where the log group should be created\n   * @default - same region as the stack\n   */\n  readonly logGroupRegion?: string;\n\n  /**\n   * The number of days log events are kept in CloudWatch Logs.\n   */\n  readonly retention: RetentionDays;\n\n  /**\n   * The IAM role for the Lambda function associated with the custom resource.\n   *\n   * @default - A new role is created\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Retry options for all AWS API calls.\n   *\n   * @default - AWS SDK default retry options\n   */\n  readonly logRetentionRetryOptions?: LogRetentionRetryOptions;\n}\n\n/**\n * Retry options for all AWS API calls.\n */\nexport interface LogRetentionRetryOptions {\n  /**\n   * The maximum amount of retries.\n   *\n   * @default 3 (AWS SDK default)\n   */\n  readonly maxRetries?: number;\n  /**\n   * The base duration to use in the exponential backoff for operation retries.\n   *\n   * @default Duration.millis(100) (AWS SDK default)\n   */\n  readonly base?: cdk.Duration;\n}\n\n/**\n * Creates a custom resource to control the retention policy of a CloudWatch Logs\n * log group. The log group is created if it doesn't already exist. The policy\n * is removed when `retentionDays` is `undefined` or equal to `Infinity`.\n * Log group can be created in the region that is different from stack region by\n * specifying `logGroupRegion`\n */\nexport class LogRetention extends Construct {\n\n  /**\n   * The ARN of the LogGroup.\n   */\n  public readonly logGroupArn: string;\n\n  constructor(scope: Construct, id: string, props: LogRetentionProps) {\n    super(scope, id);\n\n    // Custom resource provider\n    const provider = this.ensureSingletonLogRetentionFunction(props);\n\n    // Need to use a CfnResource here to prevent lerna dependency cycles\n    // @aws-cdk/aws-cloudformation -> @aws-cdk/aws-lambda -> @aws-cdk/aws-cloudformation\n    const retryOptions = props.logRetentionRetryOptions;\n    const resource = new cdk.CfnResource(this, 'Resource', {\n      type: 'Custom::LogRetention',\n      properties: {\n        ServiceToken: provider.functionArn,\n        LogGroupName: props.logGroupName,\n        LogGroupRegion: props.logGroupRegion,\n        SdkRetry: retryOptions ? {\n          maxRetries: retryOptions.maxRetries,\n          base: retryOptions.base?.toMilliseconds(),\n        } : undefined,\n        RetentionInDays: props.retention === RetentionDays.INFINITE ? undefined : props.retention,\n      },\n    });\n\n    const logGroupName = resource.getAtt('LogGroupName').toString();\n    // Append ':*' at the end of the ARN to match with how CloudFormation does this for LogGroup ARNs\n    // See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html#aws-resource-logs-loggroup-return-values\n    this.logGroupArn = cdk.Stack.of(this).formatArn({\n      region: props.logGroupRegion,\n      service: 'logs',\n      resource: 'log-group',\n      resourceName: `${logGroupName}:*`,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n  }\n\n  /**\n   * Helper method to ensure that only one instance of LogRetentionFunction resources are in the stack mimicking the\n   * behaviour of @aws-cdk/aws-lambda's SingletonFunction to prevent circular dependencies\n   */\n  private ensureSingletonLogRetentionFunction(props: LogRetentionProps) {\n    const functionLogicalId = 'LogRetentionaae0aa3c5b4d4f87b02d85b201efdd8a';\n    const existing = cdk.Stack.of(this).node.tryFindChild(functionLogicalId);\n    if (existing) {\n      return existing as LogRetentionFunction;\n    }\n    return new LogRetentionFunction(cdk.Stack.of(this), functionLogicalId, props);\n  }\n}\n\n/**\n * Private provider Lambda function to support the log retention custom resource.\n */\nclass LogRetentionFunction extends Construct implements cdk.ITaggable {\n  public readonly functionArn: cdk.Reference;\n\n  public readonly tags: cdk.TagManager = new cdk.TagManager(cdk.TagType.KEY_VALUE, 'AWS::Lambda::Function');\n\n  constructor(scope: Construct, id: string, props: LogRetentionProps) {\n    super(scope, id);\n\n    // Code\n    const asset = new s3_assets.Asset(this, 'Code', {\n      path: path.join(__dirname, 'log-retention-provider'),\n    });\n\n    // Role\n    const role = props.role || new iam.Role(this, 'ServiceRole', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n      managedPolicies: [iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')],\n    });\n    // Duplicate statements will be deduplicated by `PolicyDocument`\n    role.addToPrincipalPolicy(new iam.PolicyStatement({\n      actions: ['logs:PutRetentionPolicy', 'logs:DeleteRetentionPolicy'],\n      // We need '*' here because we will also put a retention policy on\n      // the log group of the provider function. Referencing its name\n      // creates a CF circular dependency.\n      resources: ['*'],\n    }));\n\n    // Lambda function\n    const resource = new cdk.CfnResource(this, 'Resource', {\n      type: 'AWS::Lambda::Function',\n      properties: {\n        Handler: 'index.handler',\n        Runtime: 'nodejs14.x', // Equivalent to Runtime.NODEJS_14_X\n        Code: {\n          S3Bucket: asset.s3BucketName,\n          S3Key: asset.s3ObjectKey,\n        },\n        Role: role.roleArn,\n        Tags: this.tags.renderedTags,\n      },\n    });\n    this.functionArn = resource.getAtt('Arn');\n\n    asset.addResourceMetadata(resource, 'Code');\n\n    // Function dependencies\n    role.node.children.forEach((child) => {\n      if (cdk.CfnResource.isCfnResource(child)) {\n        resource.addDependsOn(child);\n      }\n      if (Construct.isConstruct(child) && child.node.defaultChild && cdk.CfnResource.isCfnResource(child.node.defaultChild)) {\n        resource.addDependsOn(child.node.defaultChild);\n      }\n    });\n  }\n}\n"],
  "mappings": "mNAAA,KAAA,QAAA,QACA,IAAA,QAAA,iBACA,UAAA,QAAA,uBACA,IAAA,QAAA,cACA,aAAA,QAAA,cACA,YAAA,QAAA,eAIA,OAAA,QAAA,cA8DA,0BAAkC,cAAA,SAAS,CAOzC,YAAY,MAAkB,GAAY,MAAwB,QAChE,MAAM,MAAO,0EAGb,KAAM,UAAW,KAAK,oCAAoC,OAIpD,aAAe,MAAM,yBAerB,aAAe,AAdJ,GAAI,KAAI,YAAY,KAAM,WAAY,CACrD,KAAM,uBACN,WAAY,CACV,aAAc,SAAS,YACvB,aAAc,MAAM,aACpB,eAAgB,MAAM,eACtB,SAAU,aAAe,CACvB,WAAY,aAAa,WACzB,KAAI,IAAE,aAAa,QAAI,MAAA,KAAA,OAAA,OAAA,GAAE,kBACvB,OACJ,gBAAiB,MAAM,YAAc,YAAA,cAAc,SAAW,OAAY,MAAM,aAItD,OAAO,gBAAgB,WAGrD,KAAK,YAAc,IAAI,MAAM,GAAG,MAAM,UAAU,CAC9C,OAAQ,MAAM,eACd,QAAS,OACT,SAAU,YACV,aAAc,GAAG,iBACjB,UAAW,OAAA,UAAU,sBAQjB,oCAAoC,MAAwB,CAClE,KAAM,mBAAoB,+CACpB,SAAW,IAAI,MAAM,GAAG,MAAM,KAAK,aAAa,mBACtD,MAAI,WAGG,GAAI,sBAAqB,IAAI,MAAM,GAAG,MAAO,kBAAmB,QApD3E,QAAA,aAAA,+GA2DA,kCAAmC,cAAA,SAAS,CAK1C,YAAY,MAAkB,GAAY,MAAwB,CAChE,MAAM,MAAO,IAHC,KAAA,KAAuB,GAAI,KAAI,WAAW,IAAI,QAAQ,UAAW,yBAM/E,KAAM,OAAQ,GAAI,WAAU,MAAM,KAAM,OAAQ,CAC9C,KAAM,KAAK,KAAK,UAAW,4BAIvB,KAAO,MAAM,MAAQ,GAAI,KAAI,KAAK,KAAM,cAAe,CAC3D,UAAW,GAAI,KAAI,iBAAiB,wBACpC,gBAAiB,CAAC,IAAI,cAAc,yBAAyB,+CAG/D,KAAK,qBAAqB,GAAI,KAAI,gBAAgB,CAChD,QAAS,CAAC,0BAA2B,8BAIrC,UAAW,CAAC,QAId,KAAM,UAAW,GAAI,KAAI,YAAY,KAAM,WAAY,CACrD,KAAM,wBACN,WAAY,CACV,QAAS,gBACT,QAAS,aACT,KAAM,CACJ,SAAU,MAAM,aAChB,MAAO,MAAM,aAEf,KAAM,KAAK,QACX,KAAM,KAAK,KAAK,gBAGpB,KAAK,YAAc,SAAS,OAAO,OAEnC,MAAM,oBAAoB,SAAU,QAGpC,KAAK,KAAK,SAAS,QAAQ,AAAC,OAAS,CACnC,AAAI,IAAI,YAAY,cAAc,QAChC,SAAS,aAAa,OAEpB,aAAA,UAAU,YAAY,QAAU,MAAM,KAAK,cAAgB,IAAI,YAAY,cAAc,MAAM,KAAK,eACtG,SAAS,aAAa,MAAM,KAAK",
  "names": []
}
