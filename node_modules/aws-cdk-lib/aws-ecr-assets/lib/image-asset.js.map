{
  "version": 3,
  "sources": ["image-asset.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport * as ecr from '../../aws-ecr';\nimport { Annotations, AssetStaging, FeatureFlags, FileFingerprintOptions, IgnoreMode, Stack, SymlinkFollowMode, Token, Stage, CfnResource } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { Construct } from 'constructs';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line\nimport { FingerprintOptions, FollowMode, IAsset } from '../../assets';\n\n/**\n * networking mode on build time supported by docker\n */\nexport class NetworkMode {\n  /**\n   * The default networking mode if omitted, create a network stack on the default Docker bridge\n   */\n  public static readonly DEFAULT = new NetworkMode('default');\n\n  /**\n   * Use the Docker host network stack\n   */\n  public static readonly HOST = new NetworkMode('host');\n\n  /**\n   * Disable the network stack, only the loopback device will be created\n   */\n  public static readonly NONE = new NetworkMode('none');\n\n  /**\n   * Reuse another container's network stack\n   *\n   * @param containerId The target container's id or name\n   */\n  public static fromContainer(containerId: string) {\n    return new NetworkMode(`container:${containerId}`);\n  }\n\n  /**\n   * Used to specify a custom networking mode\n   * Use this if the networking mode name is not yet supported by the CDK.\n   *\n   * @param mode The networking mode to use for docker build\n   */\n  public static custom(mode: string) {\n    return new NetworkMode(mode);\n  }\n\n  /**\n   * @param mode The networking mode to use for docker build\n   */\n  private constructor(public readonly mode: string) {}\n}\n\n/**\n * Options to control invalidation of `DockerImageAsset` asset hashes\n */\nexport interface DockerImageAssetInvalidationOptions {\n  /**\n   * Use `extraHash` while calculating the asset hash\n   *\n   * @default true\n   */\n  readonly extraHash?: boolean;\n\n  /**\n   * Use `buildArgs` while calculating the asset hash\n   *\n   * @default true\n   */\n  readonly buildArgs?: boolean;\n\n  /**\n   * Use `target` while calculating the asset hash\n   *\n   * @default true\n   */\n  readonly target?: boolean;\n\n  /**\n   * Use `file` while calculating the asset hash\n   *\n   * @default true\n   */\n  readonly file?: boolean;\n\n  /**\n   * Use `repositoryName` while calculating the asset hash\n   *\n   * @default true\n   */\n  readonly repositoryName?: boolean;\n\n  /**\n   * Use `networkMode` while calculating the asset hash\n   *\n   * @default true\n   */\n  readonly networkMode?: boolean;\n}\n\n/**\n * Options for DockerImageAsset\n */\nexport interface DockerImageAssetOptions extends FingerprintOptions, FileFingerprintOptions {\n  /**\n   * ECR repository name\n   *\n   * Specify this property if you need to statically address the image, e.g.\n   * from a Kubernetes Pod. Note, this is only the repository name, without the\n   * registry and the tag parts.\n   *\n   * @default - the default ECR repository for CDK assets\n   * @deprecated to control the location of docker image assets, please override\n   * `Stack.addDockerImageAsset`. this feature will be removed in future\n   * releases.\n   */\n  readonly repositoryName?: string;\n\n  /**\n   * Build args to pass to the `docker build` command.\n   *\n   * Since Docker build arguments are resolved before deployment, keys and\n   * values cannot refer to unresolved tokens (such as `lambda.functionArn` or\n   * `queue.queueUrl`).\n   *\n   * @default - no build args are passed\n   */\n  readonly buildArgs?: { [key: string]: string };\n\n  /**\n   * Docker target to build to\n   *\n   * @default - no target\n   */\n  readonly target?: string;\n\n  /**\n   * Path to the Dockerfile (relative to the directory).\n   *\n   * @default 'Dockerfile'\n   */\n  readonly file?: string;\n\n  /**\n   * Networking mode for the RUN commands during build. Support docker API 1.25+.\n   *\n   * @default - no networking mode specified (the default networking mode `NetworkMode.DEFAULT` will be used)\n   */\n  readonly networkMode?: NetworkMode;\n\n  /**\n   * Options to control which parameters are used to invalidate the asset hash.\n   *\n   * @default - hash all parameters\n   */\n  readonly invalidation?: DockerImageAssetInvalidationOptions;\n}\n\n/**\n * Props for DockerImageAssets\n */\nexport interface DockerImageAssetProps extends DockerImageAssetOptions {\n  /**\n   * The directory where the Dockerfile is stored\n   *\n   * Any directory inside with a name that matches the CDK output folder (cdk.out by default) will be excluded from the asset\n   */\n  readonly directory: string;\n}\n\n/**\n * An asset that represents a Docker image.\n *\n * The image will be created in build time and uploaded to an ECR repository.\n */\nexport class DockerImageAsset extends Construct implements IAsset {\n  /**\n   * The full URI of the image (including a tag). Use this reference to pull\n   * the asset.\n   */\n  public imageUri: string;\n\n  /**\n   * Repository where the image is stored\n   */\n  public repository: ecr.IRepository;\n\n  /**\n   * A hash of the source of this asset, which is available at construction time. As this is a plain\n   * string, it can be used in construct IDs in order to enforce creation of a new resource when\n   * the content hash has changed.\n   * @deprecated use assetHash\n   */\n  public readonly sourceHash: string;\n\n  /**\n   * A hash of this asset, which is available at construction time. As this is a plain string, it\n   * can be used in construct IDs in order to enforce creation of a new resource when the content\n   * hash has changed.\n   */\n  public readonly assetHash: string;\n\n  /**\n   * The path to the asset, relative to the current Cloud Assembly\n   *\n   * If asset staging is disabled, this will just be the original path.\n   *\n   * If asset staging is enabled it will be the staged path.\n   */\n  private readonly assetPath: string;\n\n  /**\n   * The path to the Dockerfile, relative to the assetPath\n   */\n  private readonly dockerfilePath?: string;\n\n  /**\n   * Build args to pass to the `docker build` command.\n   */\n  private readonly dockerBuildArgs?: { [key: string]: string };\n\n  /**\n   * Docker target to build to\n   */\n  private readonly dockerBuildTarget?: string;\n\n  constructor(scope: Construct, id: string, props: DockerImageAssetProps) {\n    super(scope, id);\n\n    // none of the properties use tokens\n    validateProps(props);\n\n    // resolve full path\n    const dir = path.resolve(props.directory);\n    if (!fs.existsSync(dir)) {\n      throw new Error(`Cannot find image directory at ${dir}`);\n    }\n\n    // validate the docker file exists\n    this.dockerfilePath = props.file || 'Dockerfile';\n    const file = path.join(dir, this.dockerfilePath);\n    if (!fs.existsSync(file)) {\n      throw new Error(`Cannot find file at ${file}`);\n    }\n\n    const defaultIgnoreMode = FeatureFlags.of(this).isEnabled(cxapi.DOCKER_IGNORE_SUPPORT)\n      ? IgnoreMode.DOCKER : IgnoreMode.GLOB;\n    let ignoreMode = props.ignoreMode ?? defaultIgnoreMode;\n\n    let exclude: string[] = props.exclude || [];\n\n    const ignore = path.join(dir, '.dockerignore');\n\n    if (fs.existsSync(ignore)) {\n      const dockerIgnorePatterns = fs.readFileSync(ignore).toString().split('\\n').filter(e => !!e);\n\n      exclude = [\n        ...dockerIgnorePatterns,\n        ...exclude,\n\n        // Ensure .dockerignore is included no matter what.\n        '!.dockerignore',\n      ];\n    }\n\n    // Ensure the Dockerfile is included no matter what.\n    exclude.push('!' + path.basename(file));\n    // Ensure the cdk.out folder is not included to avoid infinite loops.\n    const cdkout = Stage.of(this)?.outdir ?? 'cdk.out';\n    exclude.push(cdkout);\n\n    if (props.repositoryName) {\n      Annotations.of(this).addWarning('DockerImageAsset.repositoryName is deprecated. Override \"core.Stack.addDockerImageAsset\" to control asset locations');\n    }\n\n    // include build context in \"extra\" so it will impact the hash\n    const extraHash: { [field: string]: any } = {};\n    if (props.invalidation?.extraHash !== false && props.extraHash) { extraHash.user = props.extraHash; }\n    if (props.invalidation?.buildArgs !== false && props.buildArgs) { extraHash.buildArgs = props.buildArgs; }\n    if (props.invalidation?.target !== false && props.target) { extraHash.target = props.target; }\n    if (props.invalidation?.file !== false && props.file) { extraHash.file = props.file; }\n    if (props.invalidation?.repositoryName !== false && props.repositoryName) { extraHash.repositoryName = props.repositoryName; }\n    if (props.invalidation?.networkMode !== false && props.networkMode) { extraHash.networkMode = props.networkMode; }\n\n    // add \"salt\" to the hash in order to invalidate the image in the upgrade to\n    // 1.21.0 which removes the AdoptedRepository resource (and will cause the\n    // deletion of the ECR repository the app used).\n    extraHash.version = '1.21.0';\n\n    const staging = new AssetStaging(this, 'Staging', {\n      ...props,\n      follow: props.followSymlinks ?? toSymlinkFollow(props.follow),\n      exclude,\n      ignoreMode,\n      sourcePath: dir,\n      extraHash: Object.keys(extraHash).length === 0\n        ? undefined\n        : JSON.stringify(extraHash),\n    });\n\n    this.sourceHash = staging.assetHash;\n    this.assetHash = staging.assetHash;\n\n    const stack = Stack.of(this);\n    this.assetPath = staging.relativeStagedPath(stack);\n    this.dockerBuildArgs = props.buildArgs;\n    this.dockerBuildTarget = props.target;\n\n    const location = stack.synthesizer.addDockerImageAsset({\n      directoryName: this.assetPath,\n      dockerBuildArgs: this.dockerBuildArgs,\n      dockerBuildTarget: this.dockerBuildTarget,\n      dockerFile: props.file,\n      sourceHash: staging.assetHash,\n      networkMode: props.networkMode?.mode,\n    });\n\n    this.repository = ecr.Repository.fromRepositoryName(this, 'Repository', location.repositoryName);\n    this.imageUri = location.imageUri;\n  }\n\n  /**\n   * Adds CloudFormation template metadata to the specified resource with\n   * information that indicates which resource property is mapped to this local\n   * asset. This can be used by tools such as SAM CLI to provide local\n   * experience such as local invocation and debugging of Lambda functions.\n   *\n   * Asset metadata will only be included if the stack is synthesized with the\n   * \"aws:cdk:enable-asset-metadata\" context key defined, which is the default\n   * behavior when synthesizing via the CDK Toolkit.\n   *\n   * @see https://github.com/aws/aws-cdk/issues/1432\n   *\n   * @param resource The CloudFormation resource which is using this asset [disable-awslint:ref-via-interface]\n   * @param resourceProperty The property name where this asset is referenced\n   */\n  public addResourceMetadata(resource: CfnResource, resourceProperty: string) {\n    if (!this.node.tryGetContext(cxapi.ASSET_RESOURCE_METADATA_ENABLED_CONTEXT)) {\n      return; // not enabled\n    }\n\n    // tell tools such as SAM CLI that the resourceProperty of this resource\n    // points to a local path and include the path to de dockerfile, docker build args, and target,\n    // in order to enable local invocation of this function.\n    resource.cfnOptions.metadata = resource.cfnOptions.metadata || { };\n    resource.cfnOptions.metadata[cxapi.ASSET_RESOURCE_METADATA_PATH_KEY] = this.assetPath;\n    resource.cfnOptions.metadata[cxapi.ASSET_RESOURCE_METADATA_DOCKERFILE_PATH_KEY] = this.dockerfilePath;\n    resource.cfnOptions.metadata[cxapi.ASSET_RESOURCE_METADATA_DOCKER_BUILD_ARGS_KEY] = this.dockerBuildArgs;\n    resource.cfnOptions.metadata[cxapi.ASSET_RESOURCE_METADATA_DOCKER_BUILD_TARGET_KEY] = this.dockerBuildTarget;\n    resource.cfnOptions.metadata[cxapi.ASSET_RESOURCE_METADATA_PROPERTY_KEY] = resourceProperty;\n  }\n\n}\n\nfunction validateProps(props: DockerImageAssetProps) {\n  for (const [key, value] of Object.entries(props)) {\n    if (Token.isUnresolved(value)) {\n      throw new Error(`Cannot use Token as value of '${key}': this value is used before deployment starts`);\n    }\n  }\n\n  validateBuildArgs(props.buildArgs);\n}\n\nfunction validateBuildArgs(buildArgs?: { [key: string]: string }) {\n  for (const [key, value] of Object.entries(buildArgs || {})) {\n    if (Token.isUnresolved(key) || Token.isUnresolved(value)) {\n      throw new Error('Cannot use tokens in keys or values of \"buildArgs\" since they are needed before deployment');\n    }\n  }\n}\n\nfunction toSymlinkFollow(follow?: FollowMode): SymlinkFollowMode | undefined {\n  switch (follow) {\n    case undefined: return undefined;\n    case FollowMode.NEVER: return SymlinkFollowMode.NEVER;\n    case FollowMode.ALWAYS: return SymlinkFollowMode.ALWAYS;\n    case FollowMode.BLOCK_EXTERNAL: return SymlinkFollowMode.BLOCK_EXTERNAL;\n    case FollowMode.EXTERNAL: return SymlinkFollowMode.EXTERNAL;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
