{
  "version": 3,
  "sources": ["rotation-schedule.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as lambda from '../../aws-lambda';\nimport { Duration, Resource, Stack } from '../../core';\nimport { Construct } from 'constructs';\nimport { ISecret } from './secret';\nimport { CfnRotationSchedule } from './secretsmanager.generated';\n\n/**\n * Options to add a rotation schedule to a secret.\n */\nexport interface RotationScheduleOptions {\n  /**\n   * A Lambda function that can rotate the secret.\n   *\n   * @default - either `rotationLambda` or `hostedRotation` must be specified\n   */\n  readonly rotationLambda?: lambda.IFunction;\n\n  /**\n   * Hosted rotation\n   *\n   * @default - either `rotationLambda` or `hostedRotation` must be specified\n   */\n  readonly hostedRotation?: HostedRotation;\n\n  /**\n   * Specifies the number of days after the previous rotation before\n   * Secrets Manager triggers the next automatic rotation.\n   *\n   * @default Duration.days(30)\n   */\n  readonly automaticallyAfter?: Duration;\n}\n\n/**\n * Construction properties for a RotationSchedule.\n */\nexport interface RotationScheduleProps extends RotationScheduleOptions {\n  /**\n   * The secret to rotate.\n   *\n   * If hosted rotation is used, this must be a JSON string with the following format:\n   *\n   * ```\n   * {\n   *   \"engine\": <required: database engine>,\n   *   \"host\": <required: instance host name>,\n   *   \"username\": <required: username>,\n   *   \"password\": <required: password>,\n   *   \"dbname\": <optional: database name>,\n   *   \"port\": <optional: if not specified, default port will be used>,\n   *   \"masterarn\": <required for multi user rotation: the arn of the master secret which will be used to create users/change passwords>\n   * }\n   * ```\n   *\n   * This is typically the case for a secret referenced from an `AWS::SecretsManager::SecretTargetAttachment`\n   * or an `ISecret` returned by the `attach()` method of `Secret`.\n   */\n  readonly secret: ISecret;\n}\n\n/**\n * A rotation schedule.\n */\nexport class RotationSchedule extends Resource {\n  constructor(scope: Construct, id: string, props: RotationScheduleProps) {\n    super(scope, id);\n\n    if ((!props.rotationLambda && !props.hostedRotation) || (props.rotationLambda && props.hostedRotation)) {\n      throw new Error('One of `rotationLambda` or `hostedRotation` must be specified.');\n    }\n\n    if (props.rotationLambda?.permissionsNode.defaultChild) {\n      if (props.secret.encryptionKey) {\n        props.secret.encryptionKey.grantEncryptDecrypt(\n          new kms.ViaServicePrincipal(\n            `secretsmanager.${Stack.of(this).region}.amazonaws.com`,\n            props.rotationLambda.grantPrincipal,\n          ),\n        );\n      }\n\n      props.rotationLambda.grantInvoke(new iam.ServicePrincipal('secretsmanager.amazonaws.com'));\n\n      props.rotationLambda.addToRolePolicy(\n        new iam.PolicyStatement({\n          actions: [\n            'secretsmanager:DescribeSecret',\n            'secretsmanager:GetSecretValue',\n            'secretsmanager:PutSecretValue',\n            'secretsmanager:UpdateSecretVersionStage',\n          ],\n          resources: [props.secret.secretFullArn ? props.secret.secretFullArn : `${props.secret.secretArn}-??????`],\n        }),\n      );\n      props.rotationLambda.addToRolePolicy(\n        new iam.PolicyStatement({\n          actions: [\n            'secretsmanager:GetRandomPassword',\n          ],\n          resources: ['*'],\n        }),\n      );\n    }\n\n    new CfnRotationSchedule(this, 'Resource', {\n      secretId: props.secret.secretArn,\n      rotationLambdaArn: props.rotationLambda?.functionArn,\n      hostedRotationLambda: props.hostedRotation?.bind(props.secret, this),\n      rotationRules: {\n        automaticallyAfterDays: props.automaticallyAfter && props.automaticallyAfter.toDays() || 30,\n      },\n    });\n\n    // Prevent secrets deletions when rotation is in place\n    props.secret.denyAccountRootDelete();\n  }\n}\n\n/**\n * Single user hosted rotation options\n */\nexport interface SingleUserHostedRotationOptions {\n  /**\n   * A name for the Lambda created to rotate the secret\n   *\n   * @default - a CloudFormation generated name\n   */\n  readonly functionName?: string;\n\n  /**\n   * A list of security groups for the Lambda created to rotate the secret\n   *\n   * @default - a new security group is created\n   */\n  readonly securityGroups?: ec2.ISecurityGroup[];\n\n  /**\n   * The VPC where the Lambda rotation function will run.\n   *\n   * @default - the Lambda is not deployed in a VPC\n   */\n  readonly vpc?: ec2.IVpc;\n\n  /**\n   * The type of subnets in the VPC where the Lambda rotation function will run.\n   *\n   * @default - the Vpc default strategy if not specified.\n   */\n  readonly vpcSubnets?: ec2.SubnetSelection;\n}\n\n/**\n * Multi user hosted rotation options\n */\nexport interface MultiUserHostedRotationOptions extends SingleUserHostedRotationOptions {\n  /**\n   * The master secret for a multi user rotation scheme\n   */\n  readonly masterSecret: ISecret;\n}\n\n/**\n * A hosted rotation\n */\nexport class HostedRotation implements ec2.IConnectable {\n  /** MySQL Single User */\n  public static mysqlSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.MYSQL_SINGLE_USER, options);\n  }\n\n  /** MySQL Multi User */\n  public static mysqlMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.MYSQL_MULTI_USER, options, options.masterSecret);\n  }\n\n  /** PostgreSQL Single User */\n  public static postgreSqlSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.POSTGRESQL_SINGLE_USER, options);\n  }\n\n  /** PostgreSQL Multi User */\n  public static postgreSqlMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.POSTGRESQL_MULTI_USER, options, options.masterSecret);\n  }\n\n  /** Oracle Single User */\n  public static oracleSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.ORACLE_SINGLE_USER, options);\n  }\n\n  /** Oracle Multi User */\n  public static oracleMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.ORACLE_MULTI_USER, options, options.masterSecret);\n  }\n\n  /** MariaDB Single User */\n  public static mariaDbSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.MARIADB_SINGLE_USER, options);\n  }\n\n  /** MariaDB Multi User */\n  public static mariaDbMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.MARIADB_MULTI_USER, options, options.masterSecret);\n  }\n\n  /** SQL Server Single User */\n  public static sqlServerSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.SQLSERVER_SINGLE_USER, options);\n  }\n\n  /** SQL Server Multi User */\n  public static sqlServerMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.SQLSERVER_MULTI_USER, options, options.masterSecret);\n  }\n\n  /** Redshift Single User */\n  public static redshiftSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.REDSHIFT_SINGLE_USER, options);\n  }\n\n  /** Redshift Multi User */\n  public static redshiftMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.REDSHIFT_MULTI_USER, options, options.masterSecret);\n  }\n\n  /** MongoDB Single User */\n  public static mongoDbSingleUser(options: SingleUserHostedRotationOptions = {}) {\n    return new HostedRotation(HostedRotationType.MONGODB_SINGLE_USER, options);\n  }\n\n  /** MongoDB Multi User */\n  public static mongoDbMultiUser(options: MultiUserHostedRotationOptions) {\n    return new HostedRotation(HostedRotationType.MONGODB_MULTI_USER, options, options.masterSecret);\n  }\n\n  private _connections?: ec2.Connections;\n\n  private constructor(\n    private readonly type: HostedRotationType,\n    private readonly props: SingleUserHostedRotationOptions | MultiUserHostedRotationOptions,\n    private readonly masterSecret?: ISecret,\n  ) {\n    if (type.isMultiUser && !masterSecret) {\n      throw new Error('The `masterSecret` must be specified when using the multi user scheme.');\n    }\n  }\n\n  /**\n   * Binds this hosted rotation to a secret\n   */\n  public bind(secret: ISecret, scope: Construct): CfnRotationSchedule.HostedRotationLambdaProperty {\n    // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-secretsmanager-rotationschedule-hostedrotationlambda.html\n    Stack.of(scope).addTransform('AWS::SecretsManager-2020-07-23');\n\n    if (!this.props.vpc && this.props.securityGroups) {\n      throw new Error('`vpc` must be specified when specifying `securityGroups`.');\n    }\n\n    if (this.props.vpc) {\n      this._connections = new ec2.Connections({\n        securityGroups: this.props.securityGroups || [new ec2.SecurityGroup(scope, 'SecurityGroup', {\n          vpc: this.props.vpc,\n        })],\n      });\n    }\n\n    // Prevent master secret deletion when rotation is in place\n    if (this.masterSecret) {\n      this.masterSecret.denyAccountRootDelete();\n    }\n\n    return {\n      rotationType: this.type.name,\n      kmsKeyArn: secret.encryptionKey?.keyArn,\n      masterSecretArn: this.masterSecret?.secretArn,\n      masterSecretKmsKeyArn: this.masterSecret?.encryptionKey?.keyArn,\n      rotationLambdaName: this.props.functionName,\n      vpcSecurityGroupIds: this._connections?.securityGroups?.map(s => s.securityGroupId).join(','),\n      vpcSubnetIds: this.props.vpc?.selectSubnets(this.props.vpcSubnets).subnetIds.join(','),\n    };\n  }\n\n  /**\n   * Security group connections for this hosted rotation\n   */\n  public get connections() {\n    if (!this.props.vpc) {\n      throw new Error('Cannot use connections for a hosted rotation that is not deployed in a VPC');\n    }\n\n    // If we are in a vpc and bind() has been called _connections should be defined\n    if (!this._connections) {\n      throw new Error('Cannot use connections for a hosted rotation that has not been bound to a secret');\n    }\n\n    return this._connections;\n  }\n}\n\n/**\n * Hosted rotation type\n */\nexport class HostedRotationType {\n  /** MySQL Single User */\n  public static readonly MYSQL_SINGLE_USER = new HostedRotationType('MySQLSingleUser');\n\n  /** MySQL Multi User */\n  public static readonly MYSQL_MULTI_USER = new HostedRotationType('MySQLMultiUser', true);\n\n  /** PostgreSQL Single User */\n  public static readonly POSTGRESQL_SINGLE_USER = new HostedRotationType('PostgreSQLSingleUser');\n\n  /** PostgreSQL Multi User */\n  public static readonly POSTGRESQL_MULTI_USER = new HostedRotationType('PostgreSQLMultiUser', true);\n\n  /** Oracle Single User */\n  public static readonly ORACLE_SINGLE_USER = new HostedRotationType('OracleSingleUser');\n\n  /** Oracle Multi User */\n  public static readonly ORACLE_MULTI_USER = new HostedRotationType('OracleMultiUser', true);\n\n  /** MariaDB Single User */\n  public static readonly MARIADB_SINGLE_USER = new HostedRotationType('MariaDBSingleUser');\n\n  /** MariaDB Multi User */\n  public static readonly MARIADB_MULTI_USER = new HostedRotationType('MariaDBMultiUser', true);\n\n  /** SQL Server Single User */\n  public static readonly SQLSERVER_SINGLE_USER = new HostedRotationType('SQLServerSingleUser')\n\n  /** SQL Server Multi User */\n  public static readonly SQLSERVER_MULTI_USER = new HostedRotationType('SQLServerMultiUser', true);\n\n  /** Redshift Single User */\n  public static readonly REDSHIFT_SINGLE_USER = new HostedRotationType('RedshiftSingleUser')\n\n  /** Redshift Multi User */\n  public static readonly REDSHIFT_MULTI_USER = new HostedRotationType('RedshiftMultiUser', true);\n\n  /** MongoDB Single User */\n  public static readonly MONGODB_SINGLE_USER = new HostedRotationType('MongoDBSingleUser');\n\n  /** MongoDB Multi User */\n  public static readonly MONGODB_MULTI_USER = new HostedRotationType('MongoDBMultiUser', true);\n\n  /**\n   * @param name The type of rotation\n   * @param isMultiUser Whether the rotation uses the mutli user scheme\n   */\n  private constructor(public readonly name: string, public readonly isMultiUser?: boolean) {}\n}\n"],
  "mappings": "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",
  "names": []
}
