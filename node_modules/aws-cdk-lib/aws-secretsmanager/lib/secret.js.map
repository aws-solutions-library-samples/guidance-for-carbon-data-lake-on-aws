{
  "version": 3,
  "sources": ["secret.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport { ArnFormat, FeatureFlags, Fn, IResource, Lazy, RemovalPolicy, Resource, ResourceProps, SecretValue, Stack, Token, TokenComparison } from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { IConstruct, Construct } from 'constructs';\nimport { ResourcePolicy } from './policy';\nimport { RotationSchedule, RotationScheduleOptions } from './rotation-schedule';\nimport * as secretsmanager from './secretsmanager.generated';\n\n/**\n * A secret in AWS Secrets Manager.\n */\nexport interface ISecret extends IResource {\n  /**\n   * The customer-managed encryption key that is used to encrypt this secret, if any. When not specified, the default\n   * KMS key for the account and region is being used.\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * The ARN of the secret in AWS Secrets Manager. Will return the full ARN if available, otherwise a partial arn.\n   * For secrets imported by the deprecated `fromSecretName`, it will return the `secretName`.\n   * @attribute\n   */\n  readonly secretArn: string;\n\n  /**\n   * The full ARN of the secret in AWS Secrets Manager, which is the ARN including the Secrets Manager-supplied 6-character suffix.\n   * This is equal to `secretArn` in most cases, but is undefined when a full ARN is not available (e.g., secrets imported by name).\n   */\n  readonly secretFullArn?: string;\n\n  /**\n   * The name of the secret.\n   *\n   * For \"owned\" secrets, this will be the full resource name (secret name + suffix), unless the\n   * '@aws-cdk/aws-secretsmanager:parseOwnedSecretName' feature flag is set.\n   */\n  readonly secretName: string;\n\n  /**\n   * Retrieve the value of the stored secret as a `SecretValue`.\n   * @attribute\n   */\n  readonly secretValue: SecretValue;\n\n  /**\n   * Interpret the secret as a JSON object and return a field's value from it as a `SecretValue`.\n   */\n  secretValueFromJson(key: string): SecretValue;\n\n  /**\n   * Grants reading the secret value to some role.\n   *\n   * @param grantee       the principal being granted permission.\n   * @param versionStages the version stages the grant is limited to. If not specified, no restriction on the version\n   *                      stages is applied.\n   */\n  grantRead(grantee: iam.IGrantable, versionStages?: string[]): iam.Grant;\n\n  /**\n   * Grants writing and updating the secret value to some role.\n   *\n   * @param grantee       the principal being granted permission.\n   */\n  grantWrite(grantee: iam.IGrantable): iam.Grant;\n\n  /**\n   * Adds a rotation schedule to the secret.\n   */\n  addRotationSchedule(id: string, options: RotationScheduleOptions): RotationSchedule;\n\n  /**\n   * Adds a statement to the IAM resource policy associated with this secret.\n   *\n   * If this secret was created in this stack, a resource policy will be\n   * automatically created upon the first call to `addToResourcePolicy`. If\n   * the secret is imported, then this is a no-op.\n   */\n  addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult;\n\n  /**\n   * Denies the `DeleteSecret` action to all principals within the current\n   * account.\n   */\n  denyAccountRootDelete(): void;\n\n  /**\n   * Attach a target to this secret.\n   *\n   * @param target The target to attach.\n   * @returns An attached secret\n   */\n  attach(target: ISecretAttachmentTarget): ISecret;\n}\n\n/**\n * The properties required to create a new secret in AWS Secrets Manager.\n */\nexport interface SecretProps {\n  /**\n   * An optional, human-friendly description of the secret.\n   *\n   * @default - No description.\n   */\n  readonly description?: string;\n\n  /**\n   * The customer-managed encryption key to use for encrypting the secret value.\n   *\n   * @default - A default KMS key for the account and region is used.\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * Configuration for how to generate a secret value.\n   *\n   * Only one of `secretString` and `generateSecretString` can be provided.\n   *\n   * @default - 32 characters with upper-case letters, lower-case letters, punctuation and numbers (at least one from each\n   * category), per the default values of ``SecretStringGenerator``.\n   */\n  readonly generateSecretString?: SecretStringGenerator;\n\n  /**\n   * A name for the secret. Note that deleting secrets from SecretsManager does not happen immediately, but after a 7 to\n   * 30 days blackout period. During that period, it is not possible to create another secret that shares the same name.\n   *\n   * @default - A name is generated by CloudFormation.\n   */\n  readonly secretName?: string;\n\n  /**\n   * Initial value for the secret\n   *\n   * **NOTE:** *It is **highly** encouraged to leave this field undefined and allow SecretsManager to create the secret value.\n   * The secret string -- if provided -- will be included in the output of the cdk as part of synthesis,\n   * and will appear in the CloudFormation template in the console. This can be secure(-ish) if that value is merely reference to\n   * another resource (or one of its attributes), but if the value is a plaintext string, it will be visible to anyone with access\n   * to the CloudFormation template (via the AWS Console, SDKs, or CLI).\n   *\n   * Specifies text data that you want to encrypt and store in this new version of the secret.\n   * May be a simple string value, or a string representation of a JSON structure.\n   *\n   * Only one of `secretString` and `generateSecretString` can be provided.\n   *\n   * @default - SecretsManager generates a new secret value.\n   */\n  readonly secretStringBeta1?: SecretStringValueBeta1;\n\n  /**\n   * Policy to apply when the secret is removed from this stack.\n   *\n   * @default - Not set.\n   */\n  readonly removalPolicy?: RemovalPolicy;\n\n  /**\n   * A list of regions where to replicate this secret.\n   *\n   * @default - Secret is not replicated\n   */\n  readonly replicaRegions?: ReplicaRegion[];\n}\n\n/**\n * Secret replica region\n */\nexport interface ReplicaRegion {\n  /**\n   * The name of the region\n   */\n  readonly region: string;\n\n  /**\n   * The customer-managed encryption key to use for encrypting the secret value.\n   *\n   * @default - A default KMS key for the account and region is used.\n   */\n  readonly encryptionKey?: kms.IKey;\n}\n\n/**\n * An experimental class used to specify an initial secret value for a Secret.\n * The class wraps a simple string (or JSON representation) in order to provide some safety checks and warnings\n * about the dangers of using plaintext strings as initial secret seed values via CDK/CloudFormation.\n */\nexport class SecretStringValueBeta1 {\n\n  /**\n   * Creates a `SecretStringValueBeta1` from a plaintext value.\n   * This approach is inherently unsafe, as the secret value may be visible in your source control repository\n   * and will also appear in plaintext in the resulting CloudFormation template, including in the AWS Console or APIs.\n   * Usage of this method is discouraged, especially for production workloads.\n   */\n  public static fromUnsafePlaintext(secretValue: string) { return new SecretStringValueBeta1(secretValue); }\n\n  /**\n   * Creates a `SecretValueValueBeta1` from a string value coming from a Token.\n   * The intent is to enable creating secrets from references (e.g., `Ref`, `Fn::GetAtt`) from other resources.\n   * This might be the direct output of another Construct, or the output of a Custom Resource.\n   * This method throws if it determines the input is an unsafe plaintext string.\n   *\n   * For example:\n   * ```ts\n   *     // Creates a new IAM user, access and secret keys, and stores the secret access key in a Secret.\n   *     const user = new iam.User(this, 'User');\n   *     const accessKey = new iam.AccessKey(this, 'AccessKey', { user });\n   *     const secretValue = secretsmanager.SecretStringValueBeta1.fromToken(accessKey.secretAccessKey.toString());\n   *     new secretsmanager.Secret(this, 'Secret', {\n   *       secretStringBeta1: secretValue,\n   *     });\n   * ```\n   *\n   * The secret may also be embedded in a string representation of a JSON structure:\n   *     const secretValue = secretsmanager.SecretStringValueBeta1.fromToken(JSON.stringify({\n   *       username: user.userName,\n   *       database: 'foo',\n   *       password: accessKey.secretAccessKey.toString(),\n   *     }));\n   *\n   * Note that the value being a Token does *not* guarantee safety. For example, a Lazy-evaluated string\n   * (e.g., `Lazy.string({ produce: () => 'myInsecurePassword' }))`) is a Token, but as the output is\n   * ultimately a plaintext string, and so insecure.\n   *\n   * @param secretValueFromToken a secret value coming from a Construct attribute or Custom Resource output\n   */\n  public static fromToken(secretValueFromToken: string) {\n    if (!Token.isUnresolved(secretValueFromToken)) {\n      throw new Error('SecretStringValueBeta1 appears to be plaintext (unsafe) string (or resolved Token); use fromUnsafePlaintext if this is intentional');\n    }\n    return new SecretStringValueBeta1(secretValueFromToken);\n  }\n\n  private constructor(private readonly _secretValue: string) { }\n\n  /** Returns the secret value */\n  public secretValue(): string { return this._secretValue; }\n}\n\n/**\n * Attributes required to import an existing secret into the Stack.\n * One ARN format (`secretArn`, `secretCompleteArn`, `secretPartialArn`) must be provided.\n */\nexport interface SecretAttributes {\n  /**\n   * The encryption key that is used to encrypt the secret, unless the default SecretsManager key is used.\n   */\n  readonly encryptionKey?: kms.IKey;\n\n  /**\n   * The ARN of the secret in SecretsManager.\n   * Cannot be used with `secretCompleteArn` or `secretPartialArn`.\n   * @deprecated use `secretCompleteArn` or `secretPartialArn` instead.\n   */\n  readonly secretArn?: string;\n\n  /**\n   * The complete ARN of the secret in SecretsManager. This is the ARN including the Secrets Manager 6-character suffix.\n   * Cannot be used with `secretArn` or `secretPartialArn`.\n   */\n  readonly secretCompleteArn?: string;\n\n  /**\n   * The partial ARN of the secret in SecretsManager. This is the ARN without the Secrets Manager 6-character suffix.\n   * Cannot be used with `secretArn` or `secretCompleteArn`.\n   */\n  readonly secretPartialArn?: string;\n}\n\n/**\n * The common behavior of Secrets. Users should not use this class directly, and instead use ``Secret``.\n */\nabstract class SecretBase extends Resource implements ISecret {\n  public abstract readonly encryptionKey?: kms.IKey;\n  public abstract readonly secretArn: string;\n  public abstract readonly secretName: string;\n\n  protected abstract readonly autoCreatePolicy: boolean;\n\n  private policy?: ResourcePolicy;\n\n  constructor(scope: Construct, id: string, props: ResourceProps = {}) {\n    super(scope, id, props);\n\n    this.node.addValidation({ validate: () => this.policy?.document.validateForResourcePolicy() ?? [] });\n  }\n\n  public get secretFullArn(): string | undefined { return this.secretArn; }\n\n  public grantRead(grantee: iam.IGrantable, versionStages?: string[]): iam.Grant {\n    // @see https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_identity-based-policies.html\n\n    const result = iam.Grant.addToPrincipalOrResource({\n      grantee,\n      actions: ['secretsmanager:GetSecretValue', 'secretsmanager:DescribeSecret'],\n      resourceArns: [this.arnForPolicies],\n      resource: this,\n    });\n\n    const statement = result.principalStatement || result.resourceStatement;\n    if (versionStages != null && statement) {\n      statement.addCondition('ForAnyValue:StringEquals', {\n        'secretsmanager:VersionStage': versionStages,\n      });\n    }\n\n    if (this.encryptionKey) {\n      // @see https://docs.aws.amazon.com/kms/latest/developerguide/services-secrets-manager.html\n      this.encryptionKey.grantDecrypt(\n        new kms.ViaServicePrincipal(`secretsmanager.${Stack.of(this).region}.amazonaws.com`, grantee.grantPrincipal),\n      );\n    }\n\n    const crossAccount = Token.compareStrings(Stack.of(this).account, grantee.grantPrincipal.principalAccount || '');\n\n    // Throw if secret is not imported and it's shared cross account and no KMS key is provided\n    if (this instanceof Secret && result.resourceStatement && (!this.encryptionKey && crossAccount === TokenComparison.DIFFERENT)) {\n      throw new Error('KMS Key must be provided for cross account access to Secret');\n    }\n\n    return result;\n  }\n\n  public grantWrite(grantee: iam.IGrantable): iam.Grant {\n    // See https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_identity-based-policies.html\n    const result = iam.Grant.addToPrincipalOrResource({\n      grantee,\n      actions: ['secretsmanager:PutSecretValue', 'secretsmanager:UpdateSecret'],\n      resourceArns: [this.arnForPolicies],\n      resource: this,\n    });\n\n    if (this.encryptionKey) {\n      // See https://docs.aws.amazon.com/kms/latest/developerguide/services-secrets-manager.html\n      this.encryptionKey.grantEncrypt(\n        new kms.ViaServicePrincipal(`secretsmanager.${Stack.of(this).region}.amazonaws.com`, grantee.grantPrincipal),\n      );\n    }\n\n    // Throw if secret is not imported and it's shared cross account and no KMS key is provided\n    if (this instanceof Secret && result.resourceStatement && !this.encryptionKey) {\n      throw new Error('KMS Key must be provided for cross account access to Secret');\n    }\n\n    return result;\n  }\n\n  public get secretValue() {\n    return this.secretValueFromJson('');\n  }\n\n  public secretValueFromJson(jsonField: string) {\n    return SecretValue.secretsManager(this.secretArn, { jsonField });\n  }\n\n  public addRotationSchedule(id: string, options: RotationScheduleOptions): RotationSchedule {\n    return new RotationSchedule(this, id, {\n      secret: this,\n      ...options,\n    });\n  }\n\n  public addToResourcePolicy(statement: iam.PolicyStatement): iam.AddToResourcePolicyResult {\n    if (!this.policy && this.autoCreatePolicy) {\n      this.policy = new ResourcePolicy(this, 'Policy', { secret: this });\n    }\n\n    if (this.policy) {\n      this.policy.document.addStatements(statement);\n      return { statementAdded: true, policyDependable: this.policy };\n    }\n    return { statementAdded: false };\n  }\n\n  public denyAccountRootDelete() {\n    this.addToResourcePolicy(new iam.PolicyStatement({\n      actions: ['secretsmanager:DeleteSecret'],\n      effect: iam.Effect.DENY,\n      resources: ['*'],\n      principals: [new iam.AccountRootPrincipal()],\n    }));\n  }\n\n  /**\n   * Provides an identifier for this secret for use in IAM policies.\n   * If there is a full ARN, this is just the ARN;\n   * if we have a partial ARN -- due to either importing by secret name or partial ARN --\n   * then we need to add a suffix to capture the full ARN's format.\n   */\n  protected get arnForPolicies() {\n    return this.secretFullArn ? this.secretFullArn : `${this.secretArn}-??????`;\n  }\n\n  /**\n   * Attach a target to this secret\n   *\n   * @param target The target to attach\n   * @returns An attached secret\n   */\n  public attach(target: ISecretAttachmentTarget): ISecret {\n    const id = 'Attachment';\n    const existing = this.node.tryFindChild(id);\n\n    if (existing) {\n      throw new Error('Secret is already attached to a target.');\n    }\n\n    return new SecretTargetAttachment(this, id, {\n      secret: this,\n      target,\n    });\n  }\n}\n\n/**\n * Creates a new secret in AWS SecretsManager.\n */\nexport class Secret extends SecretBase {\n\n  /** @deprecated use `fromSecretCompleteArn` or `fromSecretPartialArn` */\n  public static fromSecretArn(scope: Construct, id: string, secretArn: string): ISecret {\n    const attrs = arnIsComplete(secretArn) ? { secretCompleteArn: secretArn } : { secretPartialArn: secretArn };\n    return Secret.fromSecretAttributes(scope, id, attrs);\n  }\n\n  /** Imports a secret by complete ARN. The complete ARN is the ARN with the Secrets Manager-supplied suffix. */\n  public static fromSecretCompleteArn(scope: Construct, id: string, secretCompleteArn: string): ISecret {\n    return Secret.fromSecretAttributes(scope, id, { secretCompleteArn });\n  }\n\n  /** Imports a secret by partial ARN. The partial ARN is the ARN without the Secrets Manager-supplied suffix. */\n  public static fromSecretPartialArn(scope: Construct, id: string, secretPartialArn: string): ISecret {\n    return Secret.fromSecretAttributes(scope, id, { secretPartialArn });\n  }\n\n  /**\n   * Imports a secret by secret name; the ARN of the Secret will be set to the secret name.\n   * A secret with this name must exist in the same account & region.\n   * @deprecated use `fromSecretNameV2`\n   */\n  public static fromSecretName(scope: Construct, id: string, secretName: string): ISecret {\n    return new class extends SecretBase {\n      public readonly encryptionKey = undefined;\n      public readonly secretArn = secretName;\n      public readonly secretName = secretName;\n      protected readonly autoCreatePolicy = false;\n      public get secretFullArn() { return undefined; }\n      // Overrides the secretArn for grant* methods, where the secretArn must be in ARN format.\n      // Also adds a wildcard to the resource name to support the SecretsManager-provided suffix.\n      protected get arnForPolicies() {\n        return Stack.of(this).formatArn({\n          service: 'secretsmanager',\n          resource: 'secret',\n          resourceName: this.secretName + '*',\n          arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n        });\n      }\n    }(scope, id);\n  }\n\n  /**\n   * Imports a secret by secret name.\n   * A secret with this name must exist in the same account & region.\n   * Replaces the deprecated `fromSecretName`.\n   */\n  public static fromSecretNameV2(scope: Construct, id: string, secretName: string): ISecret {\n    return new class extends SecretBase {\n      public readonly encryptionKey = undefined;\n      public readonly secretName = secretName;\n      public readonly secretArn = this.partialArn;\n      protected readonly autoCreatePolicy = false;\n      public get secretFullArn() { return undefined; }\n      // Creates a \"partial\" ARN from the secret name. The \"full\" ARN would include the SecretsManager-provided suffix.\n      private get partialArn(): string {\n        return Stack.of(this).formatArn({\n          service: 'secretsmanager',\n          resource: 'secret',\n          resourceName: secretName,\n          arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n        });\n      }\n    }(scope, id);\n  }\n\n  /**\n   * Import an existing secret into the Stack.\n   *\n   * @param scope the scope of the import.\n   * @param id    the ID of the imported Secret in the construct tree.\n   * @param attrs the attributes of the imported secret.\n   */\n  public static fromSecretAttributes(scope: Construct, id: string, attrs: SecretAttributes): ISecret {\n    let secretArn: string;\n    let secretArnIsPartial: boolean;\n\n    if (attrs.secretArn) {\n      if (attrs.secretCompleteArn || attrs.secretPartialArn) {\n        throw new Error('cannot use `secretArn` with `secretCompleteArn` or `secretPartialArn`');\n      }\n      secretArn = attrs.secretArn;\n      secretArnIsPartial = false;\n    } else {\n      if ((attrs.secretCompleteArn && attrs.secretPartialArn) ||\n          (!attrs.secretCompleteArn && !attrs.secretPartialArn)) {\n        throw new Error('must use only one of `secretCompleteArn` or `secretPartialArn`');\n      }\n      if (attrs.secretCompleteArn && !arnIsComplete(attrs.secretCompleteArn)) {\n        throw new Error('`secretCompleteArn` does not appear to be complete; missing 6-character suffix');\n      }\n      [secretArn, secretArnIsPartial] = attrs.secretCompleteArn ? [attrs.secretCompleteArn, false] : [attrs.secretPartialArn!, true];\n    }\n\n    return new class extends SecretBase {\n      public readonly encryptionKey = attrs.encryptionKey;\n      public readonly secretArn = secretArn;\n      public readonly secretName = parseSecretName(scope, secretArn);\n      protected readonly autoCreatePolicy = false;\n      public get secretFullArn() { return secretArnIsPartial ? undefined : secretArn; }\n    }(scope, id, { environmentFromArn: secretArn });\n  }\n\n  public readonly encryptionKey?: kms.IKey;\n  public readonly secretArn: string;\n  public readonly secretName: string;\n\n  private replicaRegions: secretsmanager.CfnSecret.ReplicaRegionProperty[] = [];\n\n  protected readonly autoCreatePolicy = true;\n\n  constructor(scope: Construct, id: string, props: SecretProps = {}) {\n    super(scope, id, {\n      physicalName: props.secretName,\n    });\n\n    if (props.generateSecretString &&\n        (props.generateSecretString.secretStringTemplate || props.generateSecretString.generateStringKey) &&\n        !(props.generateSecretString.secretStringTemplate && props.generateSecretString.generateStringKey)) {\n      throw new Error('`secretStringTemplate` and `generateStringKey` must be specified together.');\n    }\n\n    if (props.generateSecretString && props.secretStringBeta1) {\n      throw new Error('Cannot specify both `generateSecretString` and `secretStringBeta1`.');\n    }\n\n    const resource = new secretsmanager.CfnSecret(this, 'Resource', {\n      description: props.description,\n      kmsKeyId: props.encryptionKey && props.encryptionKey.keyArn,\n      generateSecretString: props.generateSecretString ?? (props.secretStringBeta1 ? undefined : {}),\n      secretString: props.secretStringBeta1?.secretValue(),\n      name: this.physicalName,\n      replicaRegions: Lazy.any({ produce: () => this.replicaRegions }, { omitEmptyArray: true }),\n    });\n\n    resource.applyRemovalPolicy(props.removalPolicy, {\n      default: RemovalPolicy.DESTROY,\n    });\n\n    this.secretArn = this.getResourceArnAttribute(resource.ref, {\n      service: 'secretsmanager',\n      resource: 'secret',\n      resourceName: this.physicalName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n\n    this.encryptionKey = props.encryptionKey;\n    const parseOwnedSecretName = FeatureFlags.of(this).isEnabled(cxapi.SECRETS_MANAGER_PARSE_OWNED_SECRET_NAME);\n    this.secretName = parseOwnedSecretName\n      ? parseSecretNameForOwnedSecret(this, this.secretArn, props.secretName)\n      : parseSecretName(this, this.secretArn);\n\n    // @see https://docs.aws.amazon.com/kms/latest/developerguide/services-secrets-manager.html#asm-authz\n    const principal =\n      new kms.ViaServicePrincipal(`secretsmanager.${Stack.of(this).region}.amazonaws.com`, new iam.AccountPrincipal(Stack.of(this).account));\n    this.encryptionKey?.grantEncryptDecrypt(principal);\n    this.encryptionKey?.grant(principal, 'kms:CreateGrant', 'kms:DescribeKey');\n\n    for (const replica of props.replicaRegions ?? []) {\n      this.addReplicaRegion(replica.region, replica.encryptionKey);\n    }\n  }\n\n  /**\n   * Adds a target attachment to the secret.\n   *\n   * @returns an AttachedSecret\n   *\n   * @deprecated use `attach()` instead\n   */\n  public addTargetAttachment(id: string, options: AttachedSecretOptions): SecretTargetAttachment {\n    return new SecretTargetAttachment(this, id, {\n      secret: this,\n      ...options,\n    });\n  }\n\n  /**\n   * Adds a replica region for the secret\n   *\n   * @param region The name of the region\n   * @param encryptionKey The customer-managed encryption key to use for encrypting the secret value.\n   */\n  public addReplicaRegion(region: string, encryptionKey?: kms.IKey): void {\n    const stack = Stack.of(this);\n    if (!Token.isUnresolved(stack.region) && !Token.isUnresolved(region) && region === stack.region) {\n      throw new Error('Cannot add the region where this stack is deployed as a replica region.');\n    }\n\n    this.replicaRegions.push({\n      region,\n      kmsKeyId: encryptionKey?.keyArn,\n    });\n  }\n}\n\n/**\n * A secret attachment target.\n */\nexport interface ISecretAttachmentTarget {\n  /**\n   * Renders the target specifications.\n   */\n  asSecretAttachmentTarget(): SecretAttachmentTargetProps;\n}\n\n/**\n * The type of service or database that's being associated with the secret.\n */\nexport enum AttachmentTargetType {\n  /**\n   * AWS::RDS::DBInstance\n   */\n  RDS_DB_INSTANCE = 'AWS::RDS::DBInstance',\n\n  /**\n   * A database instance\n   *\n   * @deprecated use RDS_DB_INSTANCE instead\n   */\n  INSTANCE = 'AWS::RDS::DBInstance',\n\n  /**\n   * AWS::RDS::DBCluster\n   */\n  RDS_DB_CLUSTER = 'AWS::RDS::DBCluster',\n\n  /**\n   * A database cluster\n   *\n   * @deprecated use RDS_DB_CLUSTER instead\n   */\n  CLUSTER = 'AWS::RDS::DBCluster',\n\n  /**\n   * AWS::RDS::DBProxy\n   */\n  RDS_DB_PROXY = 'AWS::RDS::DBProxy',\n\n  /**\n   * AWS::Redshift::Cluster\n   */\n  REDSHIFT_CLUSTER = 'AWS::Redshift::Cluster',\n\n  /**\n   * AWS::DocDB::DBInstance\n   */\n  DOCDB_DB_INSTANCE = 'AWS::DocDB::DBInstance',\n\n  /**\n   * AWS::DocDB::DBCluster\n   */\n  DOCDB_DB_CLUSTER = 'AWS::DocDB::DBCluster'\n}\n\n/**\n * Attachment target specifications.\n */\nexport interface SecretAttachmentTargetProps {\n  /**\n   * The id of the target to attach the secret to.\n   */\n  readonly targetId: string;\n\n  /**\n   * The type of the target to attach the secret to.\n   */\n  readonly targetType: AttachmentTargetType;\n}\n\n/**\n * Options to add a secret attachment to a secret.\n */\nexport interface AttachedSecretOptions {\n  /**\n   * The target to attach the secret to.\n   */\n  readonly target: ISecretAttachmentTarget;\n}\n\n/**\n * Construction properties for an AttachedSecret.\n */\nexport interface SecretTargetAttachmentProps extends AttachedSecretOptions {\n  /**\n   * The secret to attach to the target.\n   */\n  readonly secret: ISecret;\n}\n\nexport interface ISecretTargetAttachment extends ISecret {\n  /**\n   * Same as `secretArn`\n   *\n   * @attribute\n   */\n  readonly secretTargetAttachmentSecretArn: string;\n}\n\n/**\n * An attached secret.\n */\nexport class SecretTargetAttachment extends SecretBase implements ISecretTargetAttachment {\n\n  public static fromSecretTargetAttachmentSecretArn(scope: Construct, id: string, secretTargetAttachmentSecretArn: string): ISecretTargetAttachment {\n    class Import extends SecretBase implements ISecretTargetAttachment {\n      public encryptionKey?: kms.IKey | undefined;\n      public secretArn = secretTargetAttachmentSecretArn;\n      public secretTargetAttachmentSecretArn = secretTargetAttachmentSecretArn;\n      public secretName = parseSecretName(scope, secretTargetAttachmentSecretArn);\n      protected readonly autoCreatePolicy = false;\n    }\n\n    return new Import(scope, id);\n  }\n\n  public readonly encryptionKey?: kms.IKey;\n  public readonly secretArn: string;\n  public readonly secretName: string;\n\n  /**\n   * @attribute\n   */\n  public readonly secretTargetAttachmentSecretArn: string;\n\n  protected readonly autoCreatePolicy = true;\n\n  constructor(scope: Construct, id: string, props: SecretTargetAttachmentProps) {\n    super(scope, id);\n\n    const attachment = new secretsmanager.CfnSecretTargetAttachment(this, 'Resource', {\n      secretId: props.secret.secretArn,\n      targetId: props.target.asSecretAttachmentTarget().targetId,\n      targetType: props.target.asSecretAttachmentTarget().targetType,\n    });\n\n    this.encryptionKey = props.secret.encryptionKey;\n    this.secretName = props.secret.secretName;\n\n    // This allows to reference the secret after attachment (dependency).\n    this.secretArn = attachment.ref;\n    this.secretTargetAttachmentSecretArn = attachment.ref;\n  }\n}\n\n/**\n * Configuration to generate secrets such as passwords automatically.\n */\nexport interface SecretStringGenerator {\n  /**\n   * Specifies that the generated password shouldn't include uppercase letters.\n   *\n   * @default false\n   */\n  readonly excludeUppercase?: boolean;\n\n  /**\n   * Specifies whether the generated password must include at least one of every allowed character type.\n   *\n   * @default true\n   */\n  readonly requireEachIncludedType?: boolean;\n\n  /**\n   * Specifies that the generated password can include the space character.\n   *\n   * @default false\n   */\n  readonly includeSpace?: boolean;\n\n  /**\n   * A string that includes characters that shouldn't be included in the generated password. The string can be a minimum\n   * of ``0`` and a maximum of ``4096`` characters long.\n   *\n   * @default no exclusions\n   */\n  readonly excludeCharacters?: string;\n\n  /**\n   * The desired length of the generated password.\n   *\n   * @default 32\n   */\n  readonly passwordLength?: number;\n\n  /**\n   * Specifies that the generated password shouldn't include punctuation characters.\n   *\n   * @default false\n   */\n  readonly excludePunctuation?: boolean;\n\n  /**\n   * Specifies that the generated password shouldn't include lowercase letters.\n   *\n   * @default false\n   */\n  readonly excludeLowercase?: boolean;\n\n  /**\n   * Specifies that the generated password shouldn't include digits.\n   *\n   * @default false\n   */\n  readonly excludeNumbers?: boolean;\n\n  /**\n   * A properly structured JSON string that the generated password can be added to. The ``generateStringKey`` is\n   * combined with the generated random string and inserted into the JSON structure that's specified by this parameter.\n   * The merged JSON string is returned as the completed SecretString of the secret. If you specify ``secretStringTemplate``\n   * then ``generateStringKey`` must be also be specified.\n   */\n  readonly secretStringTemplate?: string;\n\n  /**\n   * The JSON key name that's used to add the generated password to the JSON structure specified by the\n   * ``secretStringTemplate`` parameter. If you specify ``generateStringKey`` then ``secretStringTemplate``\n   * must be also be specified.\n   */\n  readonly generateStringKey?: string;\n}\n\n/** Parses the secret name from the ARN. */\nfunction parseSecretName(construct: IConstruct, secretArn: string) {\n  const resourceName = Stack.of(construct).splitArn(secretArn, ArnFormat.COLON_RESOURCE_NAME).resourceName;\n  if (resourceName) {\n    // Can't operate on the token to remove the SecretsManager suffix, so just return the full secret name\n    if (Token.isUnresolved(resourceName)) {\n      return resourceName;\n    }\n\n    // Secret resource names are in the format `${secretName}-${6-character SecretsManager suffix}`\n    // If there is no hyphen (or 6-character suffix) assume no suffix was provided, and return the whole name.\n    const lastHyphenIndex = resourceName.lastIndexOf('-');\n    const hasSecretsSuffix = lastHyphenIndex !== -1 && resourceName.substr(lastHyphenIndex + 1).length === 6;\n    return hasSecretsSuffix ? resourceName.substr(0, lastHyphenIndex) : resourceName;\n  }\n  throw new Error('invalid ARN format; no secret name provided');\n}\n\n/**\n * Parses the secret name from the ARN of an owned secret. With owned secrets we know a few things we don't with imported secrets:\n * - The ARN is guaranteed to be a full ARN, with suffix.\n * - The name -- if provided -- will tell us how many hyphens to expect in the final secret name.\n * - If the name is not provided, we know the format used by CloudFormation for auto-generated names.\n *\n * Note: This is done rather than just returning the secret name passed in by the user to keep the relationship\n * explicit between the Secret and wherever the secretName might be used (i.e., using Tokens).\n */\nfunction parseSecretNameForOwnedSecret(construct: Construct, secretArn: string, secretName?: string) {\n  const resourceName = Stack.of(construct).splitArn(secretArn, ArnFormat.COLON_RESOURCE_NAME).resourceName;\n  if (!resourceName) {\n    throw new Error('invalid ARN format; no secret name provided');\n  }\n\n  // Secret name was explicitly provided, but is unresolved; best option is to use it directly.\n  // If it came from another Secret, it should (hopefully) already be properly formatted.\n  if (secretName && Token.isUnresolved(secretName)) {\n    return secretName;\n  }\n\n  // If no secretName was provided, the name will be automatically generated by CloudFormation.\n  // The autogenerated names have the form of `${logicalID}-${random}`.\n  // Otherwise, we can use the existing secretName to determine how to parse the resulting resourceName.\n  const secretNameHyphenatedSegments = secretName ? secretName.split('-').length : 2;\n  // 2 => [0, 1]\n  const segmentIndexes = [...new Array(secretNameHyphenatedSegments)].map((_, i) => i);\n\n  // Create the secret name from the resource name by joining all the known segments together.\n  // This should have the effect of stripping the final hyphen and SecretManager suffix.\n  return Fn.join('-', segmentIndexes.map(i => Fn.select(i, Fn.split('-', resourceName))));\n}\n\n/** Performs a best guess if an ARN is complete, based on if it ends with a 6-character suffix. */\nfunction arnIsComplete(secretArn: string): boolean {\n  return Token.isUnresolved(secretArn) || /-[a-z0-9]{6}$/i.test(secretArn);\n}\n"],
  "mappings": "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",
  "names": []
}
