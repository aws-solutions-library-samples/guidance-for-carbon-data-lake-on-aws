{
  "version": 3,
  "sources": ["chain.ts"],
  "sourcesContent": ["import { Parallel, ParallelProps } from './states/parallel';\nimport { State } from './states/state';\nimport { IChainable, INextable } from './types';\n\n/**\n * A collection of states to chain onto\n *\n * A Chain has a start and zero or more chainable ends. If there are\n * zero ends, calling next() on the Chain will fail.\n */\nexport class Chain implements IChainable {\n  /**\n   * Begin a new Chain from one chainable\n   */\n  public static start(state: IChainable) {\n    return new Chain(state.startState, state.endStates, state);\n  }\n\n  /**\n   * Make a Chain with the start from one chain and the ends from another\n   */\n  public static sequence(start: IChainable, next: IChainable) {\n    return new Chain(start.startState, next.endStates, next);\n  }\n\n  /**\n   * Make a Chain with specific start and end states, and a last-added Chainable\n   */\n  public static custom(startState: State, endStates: INextable[], lastAdded: IChainable) {\n    return new Chain(startState, endStates, lastAdded);\n  }\n\n  /**\n   * Identify this Chain\n   */\n  public readonly id: string;\n\n  /**\n   * The start state of this chain\n   */\n  public readonly startState: State;\n\n  /**\n   * The chainable end state(s) of this chain\n   */\n  public readonly endStates: INextable[];\n\n  private constructor(startState: State, endStates: INextable[], private readonly lastAdded: IChainable) {\n    this.id = lastAdded.id;\n    this.startState = startState;\n    this.endStates = endStates;\n  }\n\n  /**\n   * Continue normal execution with the given state\n   */\n  public next(next: IChainable): Chain {\n    if (this.endStates.length === 0) {\n      throw new Error(`Cannot add to chain: last state in chain (${this.lastAdded.id}) does not allow it`);\n    }\n\n    for (const endState of this.endStates) {\n      endState.next(next);\n    }\n\n    return new Chain(this.startState, next.endStates, next);\n  }\n\n  /**\n   * Return a single state that encompasses all states in the chain\n   *\n   * This can be used to add error handling to a sequence of states.\n   *\n   * Be aware that this changes the result of the inner state machine\n   * to be an array with the result of the state machine in it. Adjust\n   * your paths accordingly. For example, change 'outputPath' to\n   * '$[0]'.\n   */\n  public toSingleState(id: string, props: ParallelProps = {}): Parallel {\n    return new Parallel(this.startState, id, props).branch(this);\n  }\n}"],
  "mappings": "4MAAA,WAAA,QAAA,qBAUA,WAAkB,CAqChB,YAAoB,WAAmB,UAAyC,UAAqB,CAArB,KAAA,UAAA,UAC9E,KAAK,GAAK,UAAU,GACpB,KAAK,WAAa,WAClB,KAAK,UAAY,gBApCL,OAAM,MAAiB,gFAC5B,GAAI,OAAM,MAAM,WAAY,MAAM,UAAW,aAMxC,UAAS,MAAmB,KAAgB,uJACjD,GAAI,OAAM,MAAM,WAAY,KAAK,UAAW,YAMvC,QAAO,WAAmB,UAAwB,UAAqB,4JAC5E,GAAI,OAAM,WAAY,UAAW,WA2BnC,KAAK,KAAgB,CAC1B,0EAAI,KAAK,UAAU,SAAW,EAC5B,KAAM,IAAI,OAAM,6CAA6C,KAAK,UAAU,yBAG9E,SAAW,YAAY,MAAK,UAC1B,SAAS,KAAK,MAGhB,MAAO,IAAI,OAAM,KAAK,WAAY,KAAK,UAAW,MAa7C,cAAc,GAAY,MAAuB,GAAE,mFACjD,GAAI,YAAA,SAAS,KAAK,WAAY,GAAI,OAAO,OAAO,OArE3D,QAAA,MAAA",
  "names": []
}
