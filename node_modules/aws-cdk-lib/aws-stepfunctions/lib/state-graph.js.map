{
  "version": 3,
  "sources": ["state-graph.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport { Duration } from '../../core';\nimport { State } from './states/state';\n\n/**\n * A collection of connected states\n *\n * A StateGraph is used to keep track of all states that are connected (have\n * transitions between them). It does not include the substatemachines in\n * a Parallel's branches: those are their own StateGraphs, but the graphs\n * themselves have a hierarchical relationship as well.\n *\n * By assigning states to a definitive StateGraph, we verify that no state\n * machines are constructed. In particular:\n *\n * - Every state object can only ever be in 1 StateGraph, and not inadvertently\n *   be used in two graphs.\n * - Every stateId must be unique across all states in the entire state\n *   machine.\n *\n * All policy statements in all states in all substatemachines are bubbled so\n * that the top-level StateMachine instantiation can read them all and add\n * them to the IAM Role.\n *\n * You do not need to instantiate this class; it is used internally.\n */\nexport class StateGraph {\n  /**\n   * Set a timeout to render into the graph JSON.\n   *\n   * Read/write. Only makes sense on the top-level graph, subgraphs\n   * do not support this feature.\n   *\n   * @default No timeout\n   */\n  public timeout?: Duration;\n\n  /**\n   * The accumulated policy statements\n   */\n  public readonly policyStatements = new Array<iam.PolicyStatement>();\n\n  /**\n   * All states in this graph\n   */\n  private readonly allStates = new Set<State>();\n\n  /**\n   * A mapping of stateId -> Graph for all states in this graph and subgraphs\n   */\n  private readonly allContainedStates = new Map<string, StateGraph>();\n\n  /**\n   * Containing graph of this graph\n   */\n  private superGraph?: StateGraph;\n\n  /**\n   * @param startState state that gets executed when the state machine is launched\n   * @param graphDescription description of the state machine\n   */\n  constructor(public readonly startState: State, private readonly graphDescription: string) {\n    this.allStates.add(startState);\n    startState.bindToGraph(this);\n  }\n\n  /**\n   * Register a state as part of this graph\n   *\n   * Called by State.bindToGraph().\n   */\n  public registerState(state: State) {\n    this.registerContainedState(state.stateId, this);\n    this.allStates.add(state);\n  }\n\n  /**\n   * Register a Policy Statement used by states in this graph\n   */\n  public registerPolicyStatement(statement: iam.PolicyStatement) {\n    if (this.superGraph) {\n      this.superGraph.registerPolicyStatement(statement);\n    } else {\n      this.policyStatements.push(statement);\n    }\n  }\n\n  /**\n   * Register this graph as a child of the given graph\n   *\n   * Resource changes will be bubbled up to the given graph.\n   */\n  public registerSuperGraph(graph: StateGraph) {\n    if (this.superGraph === graph) { return; }\n    if (this.superGraph) {\n      throw new Error('Every StateGraph can only be registered into one other StateGraph');\n    }\n    this.superGraph = graph;\n    this.pushContainedStatesUp(graph);\n    this.pushPolicyStatementsUp(graph);\n  }\n\n  /**\n   * Return the Amazon States Language JSON for this graph\n   */\n  public toGraphJson(): object {\n    const states: any = {};\n    for (const state of this.allStates) {\n      states[state.stateId] = state.toStateJson();\n    }\n\n    return {\n      StartAt: this.startState.stateId,\n      States: states,\n      TimeoutSeconds: this.timeout && this.timeout.toSeconds(),\n    };\n  }\n\n  /**\n   * Return a string description of this graph\n   */\n  public toString() {\n    const someNodes = Array.from(this.allStates).slice(0, 3).map(x => x.stateId);\n    if (this.allStates.size > 3) { someNodes.push('...'); }\n    return `${this.graphDescription} (${someNodes.join(', ')})`;\n  }\n\n  /**\n   * Register a stateId and graph where it was registered\n   */\n  private registerContainedState(stateId: string, graph: StateGraph) {\n    if (this.superGraph) {\n      this.superGraph.registerContainedState(stateId, graph);\n    } else {\n      const existingGraph = this.allContainedStates.get(stateId);\n      if (existingGraph) {\n        throw new Error(`State with name '${stateId}' occurs in both ${graph} and ${existingGraph}. All states must have unique names.`);\n      }\n\n      this.allContainedStates.set(stateId, graph);\n    }\n  }\n\n  /**\n   * Push all contained state info up to the given super graph\n   */\n  private pushContainedStatesUp(superGraph: StateGraph) {\n    for (const [stateId, graph] of this.allContainedStates) {\n      superGraph.registerContainedState(stateId, graph);\n    }\n  }\n\n  /**\n   * Push all policy statements to into the given super graph\n   */\n  private pushPolicyStatementsUp(superGraph: StateGraph) {\n    for (const policyStatement of this.policyStatements) {\n      superGraph.registerPolicyStatement(policyStatement);\n    }\n  }\n\n}\n"],
  "mappings": "iNA0BA,gBAAuB,CAmCrB,YAA4B,WAAoC,iBAAwB,CAA5D,KAAA,WAAA,WAAoC,KAAA,iBAAA,iBArBhD,KAAA,iBAAmB,GAAI,OAKtB,KAAA,UAAY,GAAI,KAKhB,KAAA,mBAAqB,GAAI,6EAYxC,KAAK,UAAU,IAAI,YACnB,WAAW,YAAY,MAQlB,cAAc,MAAY,oEAC/B,KAAK,uBAAuB,MAAM,QAAS,MAC3C,KAAK,UAAU,IAAI,OAMd,wBAAwB,UAA8B,wEAC3D,AAAI,KAAK,WACP,KAAK,WAAW,wBAAwB,WAExC,KAAK,iBAAiB,KAAK,WASxB,mBAAmB,MAAiB,CACzC,2EAAI,KAAK,aAAe,MACxB,IAAI,KAAK,WACP,KAAM,IAAI,OAAM,qEAElB,KAAK,WAAa,MAClB,KAAK,sBAAsB,OAC3B,KAAK,uBAAuB,QAMvB,aAAW,CAChB,KAAM,QAAc,GACpB,SAAW,SAAS,MAAK,UACvB,OAAO,MAAM,SAAW,MAAM,cAGhC,MAAO,CACL,QAAS,KAAK,WAAW,QACzB,OAAQ,OACR,eAAgB,KAAK,SAAW,KAAK,QAAQ,aAO1C,UAAQ,CACb,KAAM,WAAY,MAAM,KAAK,KAAK,WAAW,MAAM,EAAG,GAAG,IAAI,GAAK,EAAE,SACpE,MAAI,MAAK,UAAU,KAAO,GAAK,UAAU,KAAK,OACvC,GAAG,KAAK,qBAAqB,UAAU,KAAK,SAM7C,uBAAuB,QAAiB,MAAiB,CAC/D,GAAI,KAAK,WACP,KAAK,WAAW,uBAAuB,QAAS,WAC3C,CACL,KAAM,eAAgB,KAAK,mBAAmB,IAAI,SAClD,GAAI,cACF,KAAM,IAAI,OAAM,oBAAoB,2BAA2B,aAAa,qDAG9E,KAAK,mBAAmB,IAAI,QAAS,QAOjC,sBAAsB,WAAsB,CAClD,SAAW,CAAC,QAAS,QAAU,MAAK,mBAClC,WAAW,uBAAuB,QAAS,OAOvC,uBAAuB,WAAsB,CACnD,SAAW,mBAAmB,MAAK,iBACjC,WAAW,wBAAwB,kBAnIzC,QAAA,WAAA",
  "names": []
}
